import io
import logging
import os
import sys
import tempfile
from abc import (
    ABC,
    abstractmethod,
)

from .. import _log as lg
from ..nls import _


class LogRedirect(ABC):
    """Super Class `LogRedirect` implements a generic log redirection scheme.

    Allows redirection of output (like `print()`, `logging`, etc.) to a temporary file, with
    options to redirect to existing file and reprint captured text to streams.

    # Motivation
      - during a procedure call, console output may be come from a variety of sources
        - print statements
        - logging package
        - C code
      - depending on the execution environment, some sources
        - may not appear in the console
        - may appear out of order
        - may not respect caller's redirection attempts
      - by capturing all output generated by the procedure during execution, all these sources
        can be effectively merged into a single stream of output, which we can then send to
        streams of our choosing

    # Derived classes
      This abstract super class implements code common to log redirection in general,
      derived classes must be created to manage redirection of specific sources.
      Implement `start_redirection()` and `.end_redirection()` methods in derived classes
        These methods will redirect some text or binary output to `self.tfile`,
        and restore the original output destination, respectively.

    *OPTIONAL*: specify to enable optional function
    `enabled`           - <bool> Any value other than `True` totally disables this feature
    `existing_tfile`    - (OPTIONAL) specify an existing file, captured output will be written there
    `reprint`           - <bool> whether to "reprint" captured output
    `reprint_file`      - (OPTIONAL) when `reprint`, write captured contents to `reprint_file.write()`
                            otherwise, written using `print()`
                            if a list of files specified, will write to each

    Use as a context manager:
        `.__enter__()`
            - create a temporary file or use `.existing_tfile`
            - redirect output
        `.__exit__()`
            - restore output destination
            - close temporary file or flush borrowed file
            - if `reprint`, print captured output using `.print_captured_text()`


    Derived classes
    implements members and methods common to
    Python and C log redirector classes
    """

    def __init__(self, enabled=False, reprint=False, reprint_file=None, existing_tfile=None):
        self.enabled=enabled
        if self.enabled is not True:
            return

        self.reprint = reprint
        self.existing_tfile=existing_tfile
        self.reprint_file = reprint_file
        # make `reprint_file` into a list
        if self.reprint_file is not None and not isinstance(self.reprint_file, list):
            self.reprint_file = [self.reprint_file]
        self.captured_text = ""

    def __enter__(self):
        if self.enabled is not True:
            return

        ## initialize captured text
        self.captured_text = _("<nothing was captured>")

        # create temporary file, or use `existing_tfile`'s file in append+ binary mode
        if self.existing_tfile is None:
            self.tfile_create()
        else:
            self.tfile_open_existing_tfile()

        # call derived class' `start_redirection()`
        self.start_redirection()

    def __exit__(self, exc_type, exc_value, traceback):
        if self.enabled is not True:
            return

        # call derived class' `end_redirection()`
        self.end_redirection()

        if self.reprint:
            self.captured_text = self.tfile_read_captured_text()
        self.tfile_release()

        self.print_captured_text()

    @abstractmethod
    def end_redirection():
        return

    @abstractmethod
    def start_redirection():
        return

    def print_captured_text(self):
        """Print captured text.

        Use `.reprint_file` if defined, otherwise just `print()` the output
        """
        if self.reprint:
            if self.reprint_file is None:
                print(self.captured_text)  # noqa: T201
            else:
                for rf in self.reprint_file:
                    if isinstance(rf, logging.Logger):
                        rf.info(f"\n{self.captured_text}")
                    else:
                        rf.write(self.captured_text)

    def tfile_create(self):
        """Create a binary temporary file and wrapper for captured output, will close upon exit."""
        # Use `mode='w+b'` so we can read and write BINARY data (like from C code)
        self.tfile = tempfile.TemporaryFile(mode="w+b")
        self.tfile_close_on_exit = True # we opened (created) it, we'll close it

        self.tfile_tell = 0 # just created, so it's at the beginning

        # create tfile wrapper: to write TEXT data (like from loggers or `print()`)
        self.tfile_wrapper = io.TextIOWrapper(self.tfile, write_through=True, encoding="utf-8")

    def tfile_open_existing_tfile(self):
        """Flush and open `.existing_tfile` for appending, leave open upon exit."""
        # `flush()` should ensure any buffered Python output is written to file
        self.existing_tfile.flush()

        # use `mode='a+b'` so we can read and APPEND binary data (like from C code) to the existing file
        self.tfile = open(self.existing_tfile.name, mode="a+b")  # noqa: PTH123

        # record it's current position for later use
        self.tfile_tell = self.tfile.tell()
        self.tfile_close_on_exit = False # leave open, managed by logging

        # create tfile wrapper: to write TEXT data (like from loggers or `print()`)
        self.tfile_wrapper = io.TextIOWrapper(self.tfile, write_through=True, encoding="utf-8")

    def tfile_read_captured_text(self, encoding="utf-8"):
        """Read `self.tfile` from `self.tfile_tell` until end.

        - return decoded contents (specify `encoding` or use default)
        """
        # read captured binary into memory
        captured_bytes = io.BytesIO()

        # flush buffered contents to file
        self.tfile.flush()

        # read from recorded location until end of file
        self.tfile.seek(self.tfile_tell, io.SEEK_SET)
        captured_bytes.write(self.tfile.read())

        # decode and print captured output
        return captured_bytes.getvalue().decode(encoding)

    def tfile_release(self):
        """Close temporary file, or set borrowed file's *tell* to end-of-file and release the reference."""
        # close temporary file (if applicable)
        if self.tfile_close_on_exit:
            self.tfile.close()
        else:
            self.tfile.seek(0, io.SEEK_END)
            self.tfile = None

class proc_py_log_redirect(LogRedirect):
    """Derived class redirects a Procedure's logger and Python `print()` (stdout and stderr) to a file."""

    def __init__(self, enabled=False, reprint=False, reprint_file=None, existing_tfile=None):
        super().__init__(
            enabled=enabled,
            reprint=reprint,
            reprint_file=reprint_file,
            existing_tfile=existing_tfile,
        )
        if self.enabled is not True:
            return
        # insert any post-super-init actions BELOW, so they're skipped if disabled

    def end_redirection(self):
        ## restore Python
        # standard output
        sys.stdout = self.py_stdout_backup
        self.py_stdout_backup = None
        # standard error
        sys.stderr = self.py_stderr_backup
        self.py_stderr_backup = None

        ## restore loggers
        # IMPORTANT: this MUST be done BEFORE the temporary file is closed, because its buffer
        # will be flushed when `setStream()` is called, exceptions to occur if not open :(
        for h in self.logger_stream_backups:
            h[0].setStream(h[1])

    def start_redirection(self):
        ## redirect Python `print()` statements
        # standard output
        self.py_stdout_backup = sys.stdout
        sys.stdout = self.tfile_wrapper
        # standard error
        self.py_stderr_backup = sys.stderr
        sys.stderr = self.tfile_wrapper

        ## redirect logger stream handler
        # NOTE: dynamically backup and replace all `StreamHandlers`.
        #       `handler_list` may be exposed in the future
        handler_list = lg.get_top_logger().handlers

        self.logger_stream_backups = []
        for h in handler_list:
            if isinstance(h, logging.StreamHandler):
                og_stream = h.setStream(self.tfile_wrapper)
                self.logger_stream_backups.append((h, og_stream))

class c_log_redirect(LogRedirect):
    """Derived class `c_log_redirect` redirects C code (OS level) stdout and stderr."""

    def __init__(self, enabled=False, reprint=False, reprint_file=None, existing_tfile=None):
        super().__init__(
            enabled=enabled,
            reprint=reprint,
            reprint_file=reprint_file,
            existing_tfile=existing_tfile,
        )
        if self.enabled is not True:
            return
        # insert any post-super-init actions BELOW, so they're skipped if disabled

    def end_redirection(self):

        ## restore C code, clean up backups
        # standard output
        os.dup2(self.c_stdout_dup, self.c_stdout_fd)
        os.close(self.c_stdout_dup)
        # standard error
        os.dup2(self.c_stderr_dup, self.c_stderr_fd)
        os.close(self.c_stderr_dup)

    def start_redirection(self):
        ## backup C code
        # standard output
        self.c_stdout_fd = sys.__stdout__.fileno()
        self.c_stdout_dup = os.dup(self.c_stdout_fd)
        # standard error
        self.c_stderr_fd = sys.__stderr__.fileno()
        self.c_stderr_dup = os.dup(self.c_stderr_fd)

        ## redirect C code
        # standard output
        os.dup2(self.tfile.fileno(), self.c_stdout_fd)
        # standard error
        os.dup2(self.tfile.fileno(), self.c_stderr_fd)
