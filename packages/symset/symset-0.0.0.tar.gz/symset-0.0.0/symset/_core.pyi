# pyright: reportIncompatibleMethodOverride=false

from collections.abc import Iterable, Set as AbstractSet
from typing import Any, Literal, Never, Self, final
from typing_extensions import TypeAliasType, TypeVar, override

_AnySet = TypeAliasType("_AnySet", AbstractSet[Any])
_SetT = TypeVar("_SetT", bound=_AnySet)

@final
class EmptyType(AbstractSet[Never]):
    @staticmethod
    def get() -> EmptyType: ...
    def __new__(cls: Never, /) -> Never: ...  # raises TypeError
    def __init__(self: Never, /) -> Never: ...  # raises TypeError
    def __bool__(self, /) -> Literal[False]: ...
    @override
    def __len__(self, /) -> Literal[0]: ...
    @override
    def __iter__(self, /) -> Self: ...
    def __next__(self, /) -> Never: ...
    @override
    def __contains__(self, x: object, /) -> Literal[False]: ...
    @override
    def __hash__(self, /) -> int: ...
    @override
    def __eq__(self, other: object, /) -> bool: ...
    @override
    def __ne__(self, other: object, /) -> bool: ...
    @override
    def __lt__(self, other: _AnySet, /) -> bool: ...
    @override
    def __le__(self, other: _AnySet, /) -> Literal[True]: ...
    @override
    def __gt__(self, other: _AnySet, /) -> Literal[False]: ...
    @override
    def __ge__(self, other: _AnySet, /) -> bool: ...
    @override
    def __and__(self, other: _AnySet, /) -> Self: ...
    @override
    def __sub__(self, other: _AnySet, /) -> Self: ...
    def __rsub__(self, other: _SetT, /) -> _SetT: ...
    @override
    def __or__(self, other: _SetT, /) -> _SetT: ...
    @override
    def __xor__(self, other: _SetT, /) -> _SetT: ...
    @override
    def isdisjoint(self, other: Iterable[Any], /) -> Literal[True]: ...
    @property
    def C(self, /) -> UniverseType: ...  # noqa: N802

@final
class UniverseType(AbstractSet[object]):
    @staticmethod
    def get() -> UniverseType: ...
    def __new__(cls: Never, /) -> Never: ...  # raises TypeError
    def __init__(self: Never, /) -> Never: ...  # raises TypeError
    def __bool__(self, /) -> Literal[True]: ...
    @override
    def __len__(self, /) -> Never: ...  # raises OverflowError
    @override
    def __iter__(self, /) -> Never: ...  # raises OverflowError
    @override
    def __contains__(self, x: object, /) -> Literal[True]: ...
    @override
    def __hash__(self, /) -> int: ...
    @override
    def __eq__(self, other: object, /) -> bool: ...
    @override
    def __ne__(self, other: object, /) -> bool: ...
    @override
    def __lt__(self, other: _AnySet, /) -> Literal[False]: ...
    @override
    def __le__(self, other: _AnySet, /) -> bool: ...
    @override
    def __gt__(self, other: _AnySet, /) -> bool: ...
    @override
    def __ge__(self, other: _AnySet, /) -> Literal[True]: ...
    @override
    def __and__(self, other: _SetT, /) -> _SetT: ...
    @override
    def __sub__(self, other: _AnySet, /) -> Self | EmptyType: ...  # might raise
    def __rsub__(self, other: _AnySet, /) -> EmptyType: ...
    @override
    def __or__(self, other: _AnySet, /) -> Self: ...
    @override
    def __xor__(self, other: _SetT, /) -> _SetT | EmptyType: ...
    @override
    def isdisjoint(self, other: Iterable[Any], /) -> bool: ...  # raises if not a set
    @property
    def C(self, /) -> EmptyType: ...  # noqa: N802
