# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""

Copyright (C) 2023 Basler AG
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.
    3. Neither the name of the copyright holder nor the names of its contributors
       may be used to endorse or promote products derived from this software
       without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pylondataprocessing
else:
    import _pylondataprocessing

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylondataprocessing.delete_SwigPyIterator

    def value(self):
        return _pylondataprocessing.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _pylondataprocessing.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _pylondataprocessing.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _pylondataprocessing.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _pylondataprocessing.SwigPyIterator_equal(self, x)

    def copy(self):
        return _pylondataprocessing.SwigPyIterator_copy(self)

    def next(self):
        return _pylondataprocessing.SwigPyIterator_next(self)

    def __next__(self):
        return _pylondataprocessing.SwigPyIterator___next__(self)

    def previous(self):
        return _pylondataprocessing.SwigPyIterator_previous(self)

    def advance(self, n):
        return _pylondataprocessing.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _pylondataprocessing.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _pylondataprocessing.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _pylondataprocessing.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _pylondataprocessing.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _pylondataprocessing.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _pylondataprocessing.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _pylondataprocessing:
_pylondataprocessing.SwigPyIterator_swigregister(SwigPyIterator)

try:
  from types import ModuleType
  import numpy as _pylon_numpy
except:
  pass

def needs_numpy(func):
 def func_wrapper(*args, **kwargs):
    e = None
    try:
      if not isinstance(_pylon_numpy, ModuleType):
        e = RuntimeError("_pylon_numpy not a module - not good!")
    except NameError:
      e = NotImplementedError("please install numpy to use this method")
    if e: raise e
    return func(*args, **kwargs)
 return func_wrapper

import pypylon.genicam
import pypylon.pylon
PYLON_DATAPROCESSING_VERSION_MAJOR = _pylondataprocessing.PYLON_DATAPROCESSING_VERSION_MAJOR
PYLON_DATAPROCESSING_VERSION_MINOR = _pylondataprocessing.PYLON_DATAPROCESSING_VERSION_MINOR
PYLON_DATAPROCESSING_VERSION_SUBMINOR = _pylondataprocessing.PYLON_DATAPROCESSING_VERSION_SUBMINOR
PYLON_DATAPROCESSING_VERSION_BUILD = _pylondataprocessing.PYLON_DATAPROCESSING_VERSION_BUILD
PYLON_DATAPROCESSING_VERSIONSTRING_MAJOR = _pylondataprocessing.PYLON_DATAPROCESSING_VERSIONSTRING_MAJOR
PYLON_DATAPROCESSING_VERSIONSTRING_MINOR = _pylondataprocessing.PYLON_DATAPROCESSING_VERSIONSTRING_MINOR
PYLON_DATAPROCESSING_VERSIONSTRING_SUBMINOR = _pylondataprocessing.PYLON_DATAPROCESSING_VERSIONSTRING_SUBMINOR
PYLON_DATAPROCESSING_VERSIONSTRING_BUILD = _pylondataprocessing.PYLON_DATAPROCESSING_VERSIONSTRING_BUILD
PYLON_DATAPROCESSING_VERSIONSTRING_EXTENSION = _pylondataprocessing.PYLON_DATAPROCESSING_VERSIONSTRING_EXTENSION
PYLON_DATAPROCESSING_GIT_REVISION = _pylondataprocessing.PYLON_DATAPROCESSING_GIT_REVISION
PYLON_DATAPROCESSING_VERSION_SUFFIX = _pylondataprocessing.PYLON_DATAPROCESSING_VERSION_SUFFIX

def GetVersion():
    return _pylondataprocessing.GetVersion()
AcquisitionMode_Unchanged = _pylondataprocessing.AcquisitionMode_Unchanged
AcquisitionMode_SingleFrame = _pylondataprocessing.AcquisitionMode_SingleFrame
AcquisitionMode_Continuous = _pylondataprocessing.AcquisitionMode_Continuous
class PointF2D(object):
    r"""


    The data of a CVariant object with the VariantDataType_PointF2D data type.
    PointF2D can provide image coordinates in pixels and world coordinates in
    meters. The origin (0,0) of image coordinates defined by a PointF2D is the
    center of the top left image pixel.  

    C++ includes: PointF2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    X = property(_pylondataprocessing.PointF2D_X_get, _pylondataprocessing.PointF2D_X_set)
    Y = property(_pylondataprocessing.PointF2D_Y_get, _pylondataprocessing.PointF2D_Y_set)

    def __str__(self):
        result = "X = {0}; Y = {1}".format(self.X,self.Y)
        return result


    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::SPointF2D::SPointF2D
        Creates a point and initializes it with (x,y).  

        """
        _pylondataprocessing.PointF2D_swiginit(self, _pylondataprocessing.new_PointF2D(*args))
    __swig_destroy__ = _pylondataprocessing.delete_PointF2D

# Register PointF2D in _pylondataprocessing:
_pylondataprocessing.PointF2D_swigregister(PointF2D)
class LineF2D(object):
    r"""


    The data of a CVariant object with the VariantDataType_LineF2D data type.  

    C++ includes: LineF2D.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _PointA = property(_pylondataprocessing.LineF2D__PointA_get, _pylondataprocessing.LineF2D__PointA_set)
    _PointB = property(_pylondataprocessing.LineF2D__PointB_get, _pylondataprocessing.LineF2D__PointB_set)

    def _Get_PointA(self):
        result = self._PointA#creates a new 1 wrapper containing a pointer to the wrapped C++ object of self
        result._myParentStruct = self#we add a reference to the parent here to work around lifetime issues
        return result
    def _Set_PointA(self, value):
        self._PointA = value
    PointA = property(_Get_PointA, _Set_PointA )


    def _Get_PointB(self):
        result = self._PointB#creates a new 1 wrapper containing a pointer to the wrapped C++ object of self
        result._myParentStruct = self#we add a reference to the parent here to work around lifetime issues
        return result
    def _Set_PointB(self, value):
        self._PointB = value
    PointB = property(_Get_PointB, _Set_PointB )


    def __str__(self):
        result = "PointA: ({0}); PointB: ({1})".format(self.PointA,self.PointB)
        return result


    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::SLineF2D::SLineF2D
        Creates a line and initializes it.  

        Parameters
        ----------
        * `pointA` :  
            Point A of the line.  
        * `pointB` :  
            Point B of the line.  

        """
        _pylondataprocessing.LineF2D_swiginit(self, _pylondataprocessing.new_LineF2D(*args))
    __swig_destroy__ = _pylondataprocessing.delete_LineF2D

# Register LineF2D in _pylondataprocessing:
_pylondataprocessing.LineF2D_swigregister(LineF2D)
class EllipseF(object):
    r"""


    The data of a CVariant object with the VariantDataType_EllipseF data type.  

    C++ includes: EllipseF.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _Center = property(_pylondataprocessing.EllipseF__Center_get, _pylondataprocessing.EllipseF__Center_set)
    Radius1 = property(_pylondataprocessing.EllipseF_Radius1_get, _pylondataprocessing.EllipseF_Radius1_set)
    Radius2 = property(_pylondataprocessing.EllipseF_Radius2_get, _pylondataprocessing.EllipseF_Radius2_set)
    Rotation = property(_pylondataprocessing.EllipseF_Rotation_get, _pylondataprocessing.EllipseF_Rotation_set)

    def _Get_Center(self):
        result = self._Center#creates a new 1 wrapper containing a pointer to the wrapped C++ object of self
        result._myParentStruct = self#we add a reference to the parent here to work around lifetime issues
        return result
    def _Set_Center(self, value):
        self._Center = value
    Center = property(_Get_Center, _Set_Center )


    def __str__(self):
        result = "Center: ({0}); Radius1 = {1}; Radius2 = {2}; Rotation = {3} rad".format(self.Center, self.Radius1, self.Radius2, self.Rotation)
        return result


    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::SEllipseF::SEllipseF
        Creates an ellipse and initializes it.  

        Parameters
        ----------
        * `center` :  
            The center of the ellipse.  
        * `radius1` :  
            The radius of the ellipse that is parallel to the x axis when the ellipse is
            in its original state, i.e., it hasn't been rotated.  
        * `radius2` :  
            The radius of the ellipse that is parallel to the y axis when the ellipse is
            in its original state, i.e., it hasn't been rotated.  
        * `rotation` :  
            The rotation of the ellipse in radiant.  

        """
        _pylondataprocessing.EllipseF_swiginit(self, _pylondataprocessing.new_EllipseF(*args))
    __swig_destroy__ = _pylondataprocessing.delete_EllipseF

# Register EllipseF in _pylondataprocessing:
_pylondataprocessing.EllipseF_swigregister(EllipseF)
class CircleF(object):
    r"""


    The data of a CVariant object with the VariantDataType_CircleF data type.  

    C++ includes: CircleF.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _Center = property(_pylondataprocessing.CircleF__Center_get, _pylondataprocessing.CircleF__Center_set)
    Radius = property(_pylondataprocessing.CircleF_Radius_get, _pylondataprocessing.CircleF_Radius_set)

    def _Get_Center(self):
        result = self._Center#creates a new 1 wrapper containing a pointer to the wrapped C++ object of self
        result._myParentStruct = self#we add a reference to the parent here to work around lifetime issues
        return result
    def _Set_Center(self, value):
        self._Center = value
    Center = property(_Get_Center, _Set_Center )


    def __str__(self):
        result = "Center: ({0}); Radius = {1}".format(self.Center, self.Radius)
        return result


    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::SCircleF::SCircleF
        Creates a circle and initializes it.  

        Parameters
        ----------
        * `center` :  
            The center of the circle.  
        * `radius` :  
            The radius of the circle.  

        """
        _pylondataprocessing.CircleF_swiginit(self, _pylondataprocessing.new_CircleF(*args))
    __swig_destroy__ = _pylondataprocessing.delete_CircleF

# Register CircleF in _pylondataprocessing:
_pylondataprocessing.CircleF_swigregister(CircleF)
class RectangleF(object):
    r"""


    The data of a CVariant object with the VariantDataType_RectangleF data type.  

    C++ includes: RectangleF.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _Center = property(_pylondataprocessing.RectangleF__Center_get, _pylondataprocessing.RectangleF__Center_set)
    Width = property(_pylondataprocessing.RectangleF_Width_get, _pylondataprocessing.RectangleF_Width_set)
    Height = property(_pylondataprocessing.RectangleF_Height_get, _pylondataprocessing.RectangleF_Height_set)
    Rotation = property(_pylondataprocessing.RectangleF_Rotation_get, _pylondataprocessing.RectangleF_Rotation_set)

    def _Get_Center(self):
        result = self._Center#creates a new 1 wrapper containing a pointer to the wrapped C++ object of self
        result._myParentStruct = self#we add a reference to the parent here to work around lifetime issues
        return result
    def _Set_Center(self, value):
        self._Center = value
    Center = property(_Get_Center, _Set_Center )


    def __str__(self):
        result = "Center: ({0}); Width = {1}; Height = {2}; Rotation = {3} rad".format(self.Center, self.Width, self.Height, self.Rotation)
        return result


    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::SRectangleF::SRectangleF
        Creates a rectangle and initializes it.  

        Parameters
        ----------
        * `center` :  
            The center of the rectangle.  
        * `width` :  
            The width of the rectangle.  
        * `height` :  
            The height of the rectangle.  
        * `rotation` :  
            The rotation of the rectangle in radiant.  

        """
        _pylondataprocessing.RectangleF_swiginit(self, _pylondataprocessing.new_RectangleF(*args))
    __swig_destroy__ = _pylondataprocessing.delete_RectangleF

# Register RectangleF in _pylondataprocessing:
_pylondataprocessing.RectangleF_swigregister(RectangleF)
class RegionEntryRLE32(object):
    r"""


    Entry for the run-length encoded pixels of a region. Region entries must be
    sorted line-wise starting with line 0 and then column-wise starting with column
    0.  

    C++ includes: RegionEntry.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    StartX = property(_pylondataprocessing.RegionEntryRLE32_StartX_get, _pylondataprocessing.RegionEntryRLE32_StartX_set)
    EndX = property(_pylondataprocessing.RegionEntryRLE32_EndX_get, _pylondataprocessing.RegionEntryRLE32_EndX_set)
    Y = property(_pylondataprocessing.RegionEntryRLE32_Y_get, _pylondataprocessing.RegionEntryRLE32_Y_set)

    def __init__(self, *args):
        _pylondataprocessing.RegionEntryRLE32_swiginit(self, _pylondataprocessing.new_RegionEntryRLE32(*args))

    def __str__(self):
        result = "StartX = {0}; EndX = {1}; Y = {2}".format(self.StartX, self.EndX, self.Y)
        return result

    __swig_destroy__ = _pylondataprocessing.delete_RegionEntryRLE32

# Register RegionEntryRLE32 in _pylondataprocessing:
_pylondataprocessing.RegionEntryRLE32_swigregister(RegionEntryRLE32)
PYLON_REGIONTYPE_CUSTOM = _pylondataprocessing.PYLON_REGIONTYPE_CUSTOM
RegionType_Undefined = _pylondataprocessing.RegionType_Undefined
RegionType_RLE32 = _pylondataprocessing.RegionType_RLE32

def IsValidRegionType(regionType):
    r"""

    Pylon::DataProcessing::IsValidRegionType
    Checks whether a given region type is valid.  

    Parameters
    ----------
    * `regionType` :  
        The region type to check.  

    Returns
    -------
    Returns true if the region type is valid or false otherwise.  

    \error Doesn't throw C++ exceptions.  

    """
    return _pylondataprocessing.IsValidRegionType(regionType)

def BitPerRegionElement(regionType):
    r"""

    Pylon::DataProcessing::BitPerRegionElement
    Determines the element size in bits of a given region type.  

    Parameters
    ----------
    * `regionType` :  
        The region type to get the element size of.  

    pre:  

        *   The region type must be valid.  

    Returns
    -------
    Returns the size of an element of a region type in bits.  

    \error Throws an exception if the preconditions aren't met.  

    """
    return _pylondataprocessing.BitPerRegionElement(regionType)

def ComputeRegionSize(regionType, elementCount):
    r"""

    Pylon::DataProcessing::ComputeRegionSize
    Determines the required data size of a region with a given region type and
    number of region elements.  

    Parameters
    ----------
    * `regionType` :  
        The region type to be used.  
    * `elementCount` :  
        The number of region elements.  

    pre:  

        *   The region type must be valid.  

    Returns
    -------
    Returns the required data size of a region with a given region type and number
    of region elements.  

    \error Throws an exception if the preconditions aren't met.  

    """
    return _pylondataprocessing.ComputeRegionSize(regionType, elementCount)

def ComputeRegionEntryCount(regionType, regionSize):
    return _pylondataprocessing.ComputeRegionEntryCount(regionType, regionSize)
class TransformationData(object):
    r"""


    Describes a transformation data class that represents a mathematical matrix with
    a specific number of columns and rows.  

    \threading The CTransformationData class isn't thread-safe.  

    C++ includes: TransformationData.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::CTransformationData::CTransformationData
        Move constructs the transformation data properties and values from the source
        transformation data.  

        Parameters
        ----------
        * `source` :  
            The source transformation data (will be invalid after the call).  

        \error Doesn't throw C++ exceptions.  

        """
        _pylondataprocessing.TransformationData_swiginit(self, _pylondataprocessing.new_TransformationData(*args))
    __swig_destroy__ = _pylondataprocessing.delete_TransformationData

    def Reset(self, columns, rows):
        r"""

        Pylon::DataProcessing::CTransformationData::Reset
        Resets the transformation data using the specified number of columns and rows.  

        Parameters
        ----------
        * `columns` :  
            The number of columns that the transformation data should have (must be
            higher than 0).  
        * `rows` :  
            The number of rows that the transformation data should have (must be higher
            than 0).  

        pre:  

            *   Argument columns must be higher than 0.  
            *   Argument rows must be higher than 0.  

        post:  

            *   IsValid() will return true.  
            *   All entries will be reset to 0.0.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.TransformationData_Reset(self, columns, rows)

    def IsValid(self):
        r"""

        Pylon::DataProcessing::CTransformationData::IsValid
        Can be used to check whether the transformation data is valid.  

        Returns
        -------
        Returns false if the transformation data is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.TransformationData_IsValid(self)

    def GetColumnCount(self):
        r"""

        Pylon::DataProcessing::CTransformationData::GetColumnCount
        Get the number of columns of the transformation data.  

        Returns
        -------
        Returns the number of columns or 0 if the transformation data is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.TransformationData_GetColumnCount(self)

    def GetRowCount(self):
        r"""

        Pylon::DataProcessing::CTransformationData::GetRowCount
        Get the number of rows of the transformation data.  

        Returns
        -------
        Returns the number of rows or 0 if the transformation data is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.TransformationData_GetRowCount(self)

    def GetEntry(self, column, row):
        r"""

        Pylon::DataProcessing::CTransformationData::GetEntry
        Get an entry at a specific position of the transformation data.  

        Parameters
        ----------
        * `column` :  
            The column of the entry to retrieve (must be lower than number of columns).  
        * `row` :  
            The row of the entry to retrieve (must be lower than number of rows).  

        pre:  

            *   Transformation data must be valid.  
            *   Argument column must be lower than number of columns.  
            *   Argument row must be lower than number of rows.  

        Returns
        -------
        Returns the entry retrieved at the specified position.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.TransformationData_GetEntry(self, column, row)

    def SetEntry(self, column, row, value):
        r"""

        Pylon::DataProcessing::CTransformationData::SetEntry
        Set an entry at a specific position in the transformation data.  

        Parameters
        ----------
        * `column` :  
            The column of the entry to set (must be lower than number of columns).  
        * `row` :  
            The row of the entry to set (must be lower than number of rows).  
        * `value` :  
            The new value to set the entry to.  

        pre:  

            *   Transformation data must be valid.  
            *   Argument column must be lower than number of columns.  
            *   Argument row must be lower than number of rows.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.TransformationData_SetEntry(self, column, row, value)

    def __str__(self):
        resultList = []
        for rowIndex in range(self.RowCount):
            if rowIndex != 0:
                resultList.append("\n")
            for columnIndex in range(self.ColumnCount):
                if columnIndex != 0:
                    resultList.append(", ")
                resultList.append(str(self.GetEntry(columnIndex, rowIndex)))
        result = "".join(resultList)
        return result


# Register TransformationData in _pylondataprocessing:
_pylondataprocessing.TransformationData_swigregister(TransformationData)
class Region(object):
    r"""


    Describes a region and takes care of the buffer handling and lifetime.  

    *   Automatically handles size and lifetime of the region buffer.  
    *   Allows you to connect user buffers or buffers provided by third-party
        software packages.  

    par: Buffer Handling:
        The buffer that is automatically created by the CRegion class or is replaced
        by a larger buffer if Reset() is called (only if required). The size of the
        allocated buffer is never decreased. Referenced user buffers are never
        automatically replaced by a larger buffer. See the Reset() method for more
        details. The Release() method can be used to detach a user buffer or to free
        an allocated buffer.  

    \threading The CRegion class isn't thread-safe.  

    C++ includes: Region.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::CRegion::CRegion
        Copies the region properties and creates a reference to the buffer of the source
        region.  

        Parameters
        ----------
        * `source` :  
            The source region.  

        post:  

            *   Another reference to the source region buffer is created.  
            *   Creates an invalid region if the source region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        _pylondataprocessing.Region_swiginit(self, _pylondataprocessing.new_Region(*args))
    __swig_destroy__ = _pylondataprocessing.delete_Region

    def CopyRegion(self, *args):
        r"""

        Pylon::DataProcessing::CRegion::CopyRegion
        Copies the region data from a buffer provided.  

        This method is used for making a full copy of a region. Calls the Reset() method
        to set the same region properties as the source region and copies the region
        data.  

        Parameters
        ----------
        * `pBuffer` :  
            The pointer to the buffer of the source region.  
        * `dataSize` :  
            The size of the region in bytes. For run-length encoded formats, the size in
            bytes defines the number of entries, e.g., 24 bytes result in 2 RLE32
            entries for RegionType_RLE32.  
        * `regionType` :  
            The type of the new region.  
        * `referenceWidth` :  
            The width of the source of the region if available, 0 otherwise.  
        * `referenceHeight` :  
            The height of the source of the region if available, 0 otherwise.  
        * `boundingBoxTopLeftX` :  
            The smallest horizontal pixel position of the region if available, 0
            otherwise.  
        * `boundingBoxTopLeftY` :  
            The smallest vertical pixel position of the region if available, 0
            otherwise.  
        * `boundingBoxWidth` :  
            The width of the bounding box of the region if available, 0 otherwise.  
        * `boundingBoxHeight` :  
            The height of the bounding box of the region if available, 0 otherwise.  

        pre:  

            *   The region type must be valid.  
            *   `pBuffer` must not be NULL.  
            *   The preconditions of the Reset() method must be met.  
            *   Either all bounding box values are 0, or `boundingBoxWidth` and
                `boundingBoxHeight` are both greater than 0.  

        post: A copy of the source region buffer's region is made.  

        \error Throws an exception if no buffer with the required size could be
        allocated. Throws an exception if the preconditions of the Reset() method aren't
        met.  

        """
        return _pylondataprocessing.Region_CopyRegion(self, *args)

    def IsValid(self):
        r"""

        Pylon::DataProcessing::CRegion::IsValid
        Can be used to check whether a region is valid.  

        Returns
        -------
        Returns false if the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_IsValid(self)

    def IsReadOnly(self):
        r"""

        Pylon::DataProcessing::CRegion::IsReadOnly
        Can be used to check whether a region data buffer is read-only.  

        Returns
        -------
        Returns true if the region data buffer is read-only or the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_IsReadOnly(self)

    def GetRegionType(self):
        r"""

        Pylon::DataProcessing::CRegion::GetRegionType
        Get the current region type.  

        Returns
        -------
        Returns the Region type or RegionType_Undefined if the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_GetRegionType(self)

    def IsUserBufferAttached(self):
        r"""

        Pylon::DataProcessing::CRegion::IsUserBufferAttached
        Indicates whether a user buffer is attached.  

        Returns
        -------
        Returns true if a user buffer is attached. Returns false if the region is
        invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_IsUserBufferAttached(self)

    def GetAllocatedBufferSize(self):
        r"""

        Pylon::DataProcessing::CRegion::GetAllocatedBufferSize
        Returns the size of the buffer used.  

        This method is useful when working with so-called user buffers.  

        Returns
        -------
        Returns the size of the buffer used in bytes or 0 if the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_GetAllocatedBufferSize(self)

    def GetDataSize(self):
        r"""

        Pylon::DataProcessing::CRegion::GetDataSize
        Get the size of the region in bytes.  

        Returns
        -------
        Returns the size of the region in bytes or 0 if the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_GetDataSize(self)

    def IsUnique(self):
        r"""

        Pylon::DataProcessing::CRegion::IsUnique
        Indicates whether the referenced buffer is only referenced by this region.  

        Returns
        -------
        Returns true if the referenced buffer is only referenced by this region. Returns
        false if the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_IsUnique(self)

    def HasReferenceSize(self):
        r"""

        Pylon::DataProcessing::CRegion::HasReferenceSize
        Indicates whether reference size information is available.  

        Returns
        -------
        Returns true if reference width or height aren't equal to zero. Returns false if
        the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_HasReferenceSize(self)

    def GetReferenceWidth(self):
        r"""

        Pylon::DataProcessing::CRegion::GetReferenceWidth
        Get the reference width in pixels.  

        Returns
        -------
        Returns the reference width or 0 if the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_GetReferenceWidth(self)

    def GetReferenceHeight(self):
        r"""

        Pylon::DataProcessing::CRegion::GetReferenceHeight
        Get the reference height in pixels.  

        Returns
        -------
        Returns the reference height or 0 if the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_GetReferenceHeight(self)

    def HasBoundingBox(self):
        r"""

        Pylon::DataProcessing::CRegion::HasBoundingBox
        Indicates whether bounding box information is available.  

        Returns
        -------
        Returns true if boundingBoxWidth and boundingBoxHeight aren't equal to zero.
        Returns false if the region is invalid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_HasBoundingBox(self)

    def GetBoundingBoxTopLeftX(self):
        r"""

        Pylon::DataProcessing::CRegion::GetBoundingBoxTopLeftX
        Use this method to get the smallest horizontal pixel position of the region.
        \error Doesn't throw C++ exceptions.  

        Returns
        -------
        Returns the smallest horizontal pixel position of the region. Returns 0 if the
        region is invalid.  

        """
        return _pylondataprocessing.Region_GetBoundingBoxTopLeftX(self)

    def GetBoundingBoxTopLeftY(self):
        r"""

        Pylon::DataProcessing::CRegion::GetBoundingBoxTopLeftY
        Use this method to get the smallest vertical pixel position of the region.
        \error Doesn't throw C++ exceptions.  

        Returns
        -------
        Returns the smallest vertical pixel position of the region. Returns 0 if the
        region is invalid.  

        """
        return _pylondataprocessing.Region_GetBoundingBoxTopLeftY(self)

    def GetBoundingBoxWidth(self):
        r"""

        Pylon::DataProcessing::CRegion::GetBoundingBoxWidth
        Use this method to get the width of the region's bounding box. \error Doesn't
        throw C++ exceptions.  

        Returns
        -------
        Returns the width of the region's bounding box. Returns 0 if the region is
        invalid.  

        """
        return _pylondataprocessing.Region_GetBoundingBoxWidth(self)

    def GetBoundingBoxHeight(self):
        r"""

        Pylon::DataProcessing::CRegion::GetBoundingBoxHeight
        Use this method to get the height of the region's bounding box. \error Doesn't
        throw C++ exceptions.  

        Returns
        -------
        Returns the height of the region's bounding box. Returns 0 if the region is
        invalid.  

        """
        return _pylondataprocessing.Region_GetBoundingBoxHeight(self)

    def Reset(self, regionType, dataSize, referenceWidth=0, referenceHeight=0, boundingBoxTopLeftX=0, boundingBoxTopLeftY=0, boundingBoxWidth=0, boundingBoxHeight=0):
        r"""

        Pylon::DataProcessing::CRegion::Reset
        Resets the region properties and allocates a new buffer if required.  

        Parameters
        ----------
        * `regionType` :  
            The type of the new region.  
        * `dataSize` :  
            The size of the region in bytes. For run-length encoded formats, the size in
            bytes defines the number of entries, e.g., 24 bytes result in 2 RLE32
            entries for RegionType_RLE32.  
        * `referenceWidth` :  
            The width of the source of the region if available, 0 otherwise.  
        * `referenceHeight` :  
            The height of the source of the region if available, 0 otherwise.  
        * `boundingBoxTopLeftX` :  
            The smallest horizontal pixel position of the region if available, 0
            otherwise.  
        * `boundingBoxTopLeftY` :  
            The smallest vertical pixel position of the region if available, 0
            otherwise.  
        * `boundingBoxWidth` :  
            The width of the bounding box of the region if available, 0 otherwise.  
        * `boundingBoxHeight` :  
            The height of the bounding box of the region if available, 0 otherwise.  

        pre:  

            *   The region type must be valid.  
            *   If a user buffer is referenced, this buffer must not be referenced by
                another pylon region. See the IsUnique() and IsUserBufferAttached()
                methods.  
            *   If a user buffer is referenced, this buffer must be large enough to hold
                the destination region. See the GetAllocatedBufferSize() and
                IsUserBufferAttached() methods.  
            *   Either all bounding box values are 0, or `boundingBoxWidth` and
                `boundingBoxHeight` are both greater than 0.  

        post:  

            *   If the previously referenced buffer is also referenced by another pylon
                region, a new buffer has been allocated.  
            *   If the previously referenced buffer isn't large enough to hold a region
                with the specified properties, a new buffer has been allocated.  
            *   If no buffer has been allocated before, a buffer has been allocated.  

        \error Throws an exception if the preconditions aren't met. Throws an exception
        if no buffer with the required size could be allocated.  

        """
        return _pylondataprocessing.Region_Reset(self, regionType, dataSize, referenceWidth, referenceHeight, boundingBoxTopLeftX, boundingBoxTopLeftY, boundingBoxWidth, boundingBoxHeight)

    def Resize(self, dataSize):
        r"""

        Pylon::DataProcessing::CRegion::Resize
        Resizes the region.  

        Parameters
        ----------
        * `dataSize` :  
            The size of the region in bytes. For run-length encoded formats, the size in
            bytes defines the number of entries, e.g., 24 bytes result in 2 RLE32
            entries for RegionType_RLE32.  

        pre:  

            *   The region must be valid.  
            *   If a user buffer is referenced, this buffer must not be referenced by
                another pylon region. See the IsUnique() and IsUserBufferAttached()
                methods.  
            *   If a user buffer is referenced, this buffer must be large enough to hold
                the new data size. See the GetAllocatedBufferSize() and
                IsUserBufferAttached() methods.  

        post:  

            *   If the previously referenced buffer is also referenced by another pylon
                region, a new buffer has been allocated.  
            *   A new buffer is allocated if necessary.  
            *   If a new buffer is allocated, the old data (old data size bytes) is
                copied to the new buffer.  
            *   The data size is changed.  

        """
        return _pylondataprocessing.Region_Resize(self, dataSize)

    def Release(self):
        r"""

        Pylon::DataProcessing::CRegion::Release
        Releases the region buffer and resets to an invalid region.  

        post:  

            *   RegionType = RegionType_Undefined.  
            *   DataSize=0.  
            *   ReferenceWidth = 0.  
            *   ReferenceHeight = 0.  
            *   boundingBoxTopLeftX = 0.  
            *   boundingBoxTopLeftY = 0.  
            *   boundingBoxWidth = 0.  
            *   boundingBoxHeight = 0.  
            *   No buffer is allocated.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Region_Release(self)

    def GetBuffer(self):
        return _pylondataprocessing.Region_GetBuffer(self)

    def GetMemoryView(self):
        return _pylondataprocessing.Region_GetMemoryView(self)

    def ToArray(self):
        return _pylondataprocessing.Region_ToArray(self)

# Register Region in _pylondataprocessing:
_pylondataprocessing.Region_swigregister(Region)
VariantDataType_Int64 = _pylondataprocessing.VariantDataType_Int64
VariantDataType_UInt64 = _pylondataprocessing.VariantDataType_UInt64
VariantDataType_Boolean = _pylondataprocessing.VariantDataType_Boolean
VariantDataType_String = _pylondataprocessing.VariantDataType_String
VariantDataType_Float = _pylondataprocessing.VariantDataType_Float
VariantDataType_PylonImage = _pylondataprocessing.VariantDataType_PylonImage
VariantDataType_Region = _pylondataprocessing.VariantDataType_Region
VariantDataType_TransformationData = _pylondataprocessing.VariantDataType_TransformationData
VariantDataType_Composite = _pylondataprocessing.VariantDataType_Composite
VariantDataType_PointF2D = _pylondataprocessing.VariantDataType_PointF2D
VariantDataType_LineF2D = _pylondataprocessing.VariantDataType_LineF2D
VariantDataType_RectangleF = _pylondataprocessing.VariantDataType_RectangleF
VariantDataType_CircleF = _pylondataprocessing.VariantDataType_CircleF
VariantDataType_EllipseF = _pylondataprocessing.VariantDataType_EllipseF
VariantDataType_None = _pylondataprocessing.VariantDataType_None
VariantDataType_Generic = _pylondataprocessing.VariantDataType_Generic
VariantDataType_Unsupported = _pylondataprocessing.VariantDataType_Unsupported
VariantContainerType_None = _pylondataprocessing.VariantContainerType_None
VariantContainerType_Array = _pylondataprocessing.VariantContainerType_Array
VariantContainerType_Unsupported = _pylondataprocessing.VariantContainerType_Unsupported
class Variant(object):
    r"""


    A variant class that can be used to represent any data type processed by a
    `CRecipe`.  

    \threading The `CVariant` class isn't thread-safe.  

    C++ includes: Variant.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::CVariant::CVariant
        Move constructs a variant.  

        Parameters
        ----------
        * `other` :  
            The variant to move the content from.  

        post:  

            *   The content of the `other` variant passed will be moved to the new
                instance without any copy.  
            *   The `other` variant will be reset to its initial state afterwards.  

        \error Doesn't throw C++ exceptions.  

        """
        _pylondataprocessing.Variant_swiginit(self, _pylondataprocessing.new_Variant(*args))

    def IsEqualInstance(self, rhs):
        r"""

        Pylon::DataProcessing::CVariant::IsEqualInstance
        Compares a variant object.  

        Parameters
        ----------
        * `rhs` :  
            The variant to compare to.  

        Returns
        -------
        `true` if the same data in variant objects is referenced.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_IsEqualInstance(self, rhs)

    def __eq__(self, rhs):
        return _pylondataprocessing.Variant___eq__(self, rhs)

    def Copy(self):
        r"""

        Pylon::DataProcessing::CVariant::Copy
        Returns a deep copy of the variant object.  

        Returns
        -------
        A deep copy of the variant object.  

        post:  

            *   The value the variant references to is copied.  
            *   If the current variant references a subvalue of a composite type, only
                the subtype of the composite type is copied.  
            *   The deep copy is held by the variant returned.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_Copy(self)
    __swig_destroy__ = _pylondataprocessing.delete_Variant

    def GetDataType(self):
        r"""

        Pylon::DataProcessing::CVariant::GetDataType
        Returns the data type of the variant.  

        Returns
        -------
        The data type of the data held.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_GetDataType(self)

    def GetContainerType(self):
        r"""

        Pylon::DataProcessing::CVariant::GetContainerType
        Returns the container type of the variant.  

        Returns
        -------
        The container type of the data held.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_GetContainerType(self)

    def GetNumSubValues(self):
        r"""

        Pylon::DataProcessing::CVariant::GetNumSubValues
        Returns the number of subvalues.  

        Returns
        -------
        The number of subvalues. For example, returns 2 for a PointF{double X, double
        Y}.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_GetNumSubValues(self)

    def GetSubValueName(self, index):
        r"""

        Pylon::DataProcessing::CVariant::GetSubValueName
        Returns the name of a subvalue of the value referenced by the variant.  

        note: The position of a subvalue is not fixed and can change for different
            versions of pylon.  

        Parameters
        ----------
        * `index` :  
            The index.  

        Returns
        -------
        The name of a subvalue of the value referenced by the variant. For example,
        returns "X" for a PointF{double X, double Y} if 0 is passed as `index`. For
        example, returns "Y" for a PointF{double X, double Y} if 1 is passed as
        `index`.  

        pre:  

            *   `GetNumSubValues()` returns a value larger than zero.  
            *   The `index` passed is smaller than the value returned by
                `GetNumSubValues()`.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_GetSubValueName(self, index)

    def HasSubValue(self, subValueName):
        r"""

        Pylon::DataProcessing::CVariant::HasSubValue
        Returns `true` if a sub alue of the value referenced by the variant with the
        name passed exists.  

        Parameters
        ----------
        * `subValueName` :  
            The name of the subvalue.  

        Returns
        -------
        `true` if a subvalue of the value referenced by the variant with the name passed
        exists. For example, returns `true` for a PointF{double X, double Y} if "X" is
        passed. For example, returns `false` for a PointF{double X, double Y} if "Z"
        is passed.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_HasSubValue(self, subValueName)

    def GetSubValue(self, subValueName):
        r"""

        Pylon::DataProcessing::CVariant::GetSubValue
        Returns a variant object referencing the subvalue.  

        Parameters
        ----------
        * `subValueName` :  
            The name of the subvalue.  

        Returns
        -------
        A variant object referencing the subvalue with name `subValueName`.  

        pre:  

            *   A subvalue of the value referenced by the variant with the
                `subValueName` passed exists.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_GetSubValue(self, subValueName)

    def SetSubValue(self, subValueName, newValue):
        r"""

        Pylon::DataProcessing::CVariant::SetSubValue
        Changes the value of a subvalue of the value referenced by this variant.  

        Parameters
        ----------
        * `subValueName` :  
            The name of the subvalue.  
        * `newValue` :  
            The new value for the subvalue.  

        pre:  

            *   A subvalue with the `subValueName` passed exists in the value referenced
                by the variant.  
            *   `newValue` must be compatible in type with the subvalue to change.  

        post:  

            *   The subvalue has been changed to the new value.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_SetSubValue(self, subValueName, newValue)

    def GetValueName(self, pOptionalRootValueName=None):
        r"""

        Pylon::DataProcessing::CVariant::GetValueName
        Returns the name of the value referenced by the variant.  

        Parameters
        ----------
        * `pOptionalRootValueName` :  
            The name of the root value that can optionally be provided by the user. The
            name of root value depends on the context the variant is used in. For
            example, "lineStartPoint" can be used for a PointF{double X, double Y}.  

        Returns
        -------
        The name of the value referenced by the variant if it references a subvalue.
        `pOptionalRootValueName` or an empty string if it doesn't reference a subvalue.
        The name of the value with index in square brackets, e.g., `line`[2], referenced
        by the variant if it references an array item.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_GetValueName(self, pOptionalRootValueName)

    def IsArray(self):
        r"""

        Pylon::DataProcessing::CVariant::IsArray
        Returns `true` if the value referenced is an array.  

        Returns
        -------
        `true` if the value referenced is an array.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_IsArray(self)

    def GetNumArrayValues(self):
        r"""

        Pylon::DataProcessing::CVariant::GetNumArrayValues
        Returns the number of values in an array.  

        Returns
        -------
        The number of values in an array. Returns 0 if the value is not an array.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_GetNumArrayValues(self)

    def GetArrayValue(self, index):
        r"""

        Pylon::DataProcessing::CVariant::GetArrayValue
        Returns a variant object referencing the array item value.  

        Parameters
        ----------
        * `index` :  
            The index.  

        Returns
        -------
        A variant object referencing the array item value.  

        pre:  

            *   `GetNumArrayValues()` returns a value larger than zero.  
            *   The `index` passed is smaller than the value returned by
                `GetNumArrayValues()`.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_GetArrayValue(self, index)

    def ChangeArraySize(self, size):
        r"""

        Pylon::DataProcessing::CVariant::ChangeArraySize
        Changes the size of an array so that it contains `size` items.  

        If `size` is smaller than the current array size, the array size is reduced to
        its first `size` elements, removing those beyond.  

        If `size` is greater than the current array size, the array size is increased by
        inserting as many elements as needed at the end to reach a size of `size`.  

        Inserted elements will be of type `VariantDataType_None`.  

        Parameters
        ----------
        * `size` :  
            The new size.  

        pre:  

            *   `IsArray()` returns `true`.  

        post:  

            *   The array size has changed.  
            *   Any old values inside the array are preserved if the new `size` is
                greater or equal than the previous array size.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   Memory allocation fails.  

        """
        return _pylondataprocessing.Variant_ChangeArraySize(self, size)

    def SetArrayItemValue(self, index, newValue):
        r"""

        Pylon::DataProcessing::CVariant::SetArrayItemValue
        Changes the value of an array item of the value referenced by this variant.  

        Parameters
        ----------
        * `index` :  
            The index.  
        * `newValue` :  
            The new value for the array item.  

        pre:  

            *   `IsArray()` returns `true`.  
            *   `GetNumArrayValues()` is greater than `index`.  
            *   The `newValue` must be compatible in type with the array item to change.  

        post:  

            *   The entry in the array at the given index has been changed to the new
                value.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_SetArrayItemValue(self, index, newValue)

    def CanConvert(self, targetType):
        r"""

        Pylon::DataProcessing::CVariant::CanConvert
        Checks whether the value can be converted to target type.  

        Parameters
        ----------
        * `targetType` :  
            The target variant data type for conversion.  

        Returns
        -------
        `true` if the value can be converted to target type.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_CanConvert(self, targetType)

    def Convert(self, targetType):
        r"""

        Pylon::DataProcessing::CVariant::Convert
        Converts value to target type.  

        `CanConvert()` can be used to check whether this `CVariant` can be converted to
        `targetType`.  

        Parameters
        ----------
        * `targetType` :  
            The target variant data type for conversion.  

        Returns
        -------
        A variant object referencing the converted item value.  

        pre:  

            *   `CanConvert()` returns `true`.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_Convert(self, targetType)

    def ToBool(self):
        r"""

        Pylon::DataProcessing::CVariant::ToBool
        Returns the value of the variant for a basic type as bool.  

        note: Conversions exist for `VariantDataType_Boolean`, `VariantDataType_Int64`,
            `VariantDataType_UInt64`, `VariantDataType_Float`, and
            `VariantDataType_String`. Can be checked with
            `CanConvert(VariantDataType_Boolean)`.  

        Returns
        -------
        The value of the variant as `bool`.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, or `VariantDataType_String`.  
            *   `CanConvert(VariantDataType_Boolean)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToBool(self)

    def ToInt64(self):
        r"""

        Pylon::DataProcessing::CVariant::ToInt64
        Returns the value of the variant for a basic type as int64_t.  

        note: The value is undefined if a conversion exceeds the range of the target
            value.  

        Conversions exist for `VariantDataType_Boolean`, `VariantDataType_Int64`,
        `VariantDataType_UInt64`, `VariantDataType_Float`, and `VariantDataType_String`.
        Can be checked with `CanConvert(VariantDataType_Int64)`.  

        Returns
        -------
        Returns the value of the variant as int64_t.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, or `VariantDataType_String`.  
            *   `CanConvert(VariantDataType_Int64)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToInt64(self)

    def ToUInt64(self):
        r"""

        Pylon::DataProcessing::CVariant::ToUInt64
        Returns the value of the variant for a basic type as uint64_t.  

        note: The value is undefined if a conversion exceeds the range of the target
            value.  

        Conversions exist for `VariantDataType_Boolean`, `VariantDataType_Int64`,
        `VariantDataType_UInt64`, `VariantDataType_Float`, or `VariantDataType_String`.
        Can be checked with `CanConvert(VariantDataType_UInt64)`.  

        Returns
        -------
        Returns the value of the variant as uint64_t.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, or `VariantDataType_String`.  
            *   `CanConvert(VariantDataType_UInt64)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToUInt64(self)

    def ToDouble(self):
        r"""

        Pylon::DataProcessing::CVariant::ToDouble
        Returns the value of the variant for a basic type as double.  

        note: Conversions exist for `VariantDataType_Boolean`, `VariantDataType_Int64`,
            `VariantDataType_UInt64`, `VariantDataType_Float`, or
            `VariantDataType_String`. Can be checked with
            `CanConvert(VariantDataType_Float)`.  

        Returns
        -------
        Returns the value of the variant as double.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, or `VariantDataType_String`.  
            *   `CanConvert(VariantDataType_Float)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToDouble(self)

    def ToString(self):
        r"""

        Pylon::DataProcessing::CVariant::ToString
        Returns the value of the variant for a basic type as string.  

        note: The string conversion always uses a dot for decimals.  

        Conversions exist for `VariantDataType_Boolean`, `VariantDataType_Int64`,
        `VariantDataType_UInt64`, `VariantDataType_Float`, or `VariantDataType_String`.
        Can be checked with `CanConvert(VariantDataType_String)`.  

        Returns
        -------
        Returns the value of the variant as string.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, `VariantDataType_String` or
                `VariantDataType_Composite`  
            *   `CanConvert(VariantDataType_String)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToString(self)

    def ToImage(self):
        r"""

        Pylon::DataProcessing::CVariant::ToImage
        Returns the value of the variant for a basic type as CPylonImage.  

        Returns
        -------
        Returns the value of the variant as CPylonImage.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_PylonImage`.  
            *   `CanConvert(VariantDataType_PylonImage)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToImage(self)

    def ToRegion(self):
        r"""

        Pylon::DataProcessing::CVariant::ToRegion
        Returns the value of the variant for a basic type as CRegion.  

        Returns
        -------
        Returns the value of the variant as CRegion.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_Region`.  
            *   `CanConvert(VariantDataType_Region)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToRegion(self)

    def ToTransformationData(self):
        r"""

        Pylon::DataProcessing::CVariant::ToTransformationData
        Returns the value of the variant for a basic type as CTransformationData.  

        Returns
        -------
        Returns the value of the variant as CTransformationData.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_TransformationData`.  
            *   `CanConvert(VariantDataType_TransformationData)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToTransformationData(self)

    def ToPointF2D(self):
        r"""

        Pylon::DataProcessing::CVariant::ToPointF2D
        Returns the value of the variant as SPointF2D.  

        Returns
        -------
        Returns the value of the variant as SPointF2D.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_PointF2D`.  
            *   `CanConvert(VariantDataType_PointF2D)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToPointF2D(self)

    def ToLineF2D(self):
        r"""

        Pylon::DataProcessing::CVariant::ToLineF2D
        Returns the value of the variant as SLineF2D.  

        Returns
        -------
        Returns the value of the variant as SLineF2D.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_LineF2D`.  
            *   `CanConvert(VariantDataType_LineF2D)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToLineF2D(self)

    def ToRectangleF(self):
        r"""

        Pylon::DataProcessing::CVariant::ToRectangleF
        Returns the value of the variant as SRectangleF.  

        Returns
        -------
        Returns the value of the variant as SRectangleF.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_RectangleF`.  
            *   `CanConvert(VariantDataType_RectangleF)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToRectangleF(self)

    def ToCircleF(self):
        r"""

        Pylon::DataProcessing::CVariant::ToCircleF
        Returns the value of the variant as SCircleF.  

        Returns
        -------
        Returns the value of the variant as SCircleF.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_CircleF`.  
            *   `CanConvert(VariantDataType_CircleF)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToCircleF(self)

    def ToEllipseF(self):
        r"""

        Pylon::DataProcessing::CVariant::ToEllipseF
        Returns the value of the variant as SEllipseF.  

        Returns
        -------
        Returns the value of the variant as SEllipseF.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_EllipseF`.  
            *   `CanConvert(VariantDataType_EllipseF)` returns `true`.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_ToEllipseF(self)

    def FromBool(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromBool
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, or `VariantDataType_String`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromBool(self, newValue)

    def FromInt64(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromInt64
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The variant data type is able to represent the value.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, or `VariantDataType_String`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromInt64(self, newValue)

    def FromUInt64(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromUInt64
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The variant data type is able to represent the value.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, or `VariantDataType_String`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromUInt64(self, newValue)

    def FromDouble(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromDouble
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The variant data type is able to represent the value.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, or `VariantDataType_String`.  

        attention: If data type is an integer data type, the value is NOT rounded in a
            mathematical way. It is truncated equivalent to static_cast<int64_t>.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromDouble(self, newValue)

    def FromString(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromString
        Changes the value referenced by the variant.  

        note: This method will fail if the content of `newValue` is not convertible to
            the type of this `CVariant`.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The variant data type is able to represent the value.  
            *   The type of this `CVariant` is `VariantDataType_Boolean`,
                `VariantDataType_Int64`, `VariantDataType_UInt64`,
                `VariantDataType_Float`, or `VariantDataType_String`.  

        post:  

            *   The referenced value has been changed to the value of `newValue` if the
                conversion succeeded.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The conversion fails.  

        """
        return _pylondataprocessing.Variant_FromString(self, newValue)

    def FromImage(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromImage
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `newValue` must be a valid image.  
            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_PylonImage`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromImage(self, newValue)

    def FromRegion(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromRegion
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `newValue` must be a valid region.  
            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_Region`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromRegion(self, newValue)

    def FromTransformationData(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromTransformationData
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `newValue` must be valid transformation data.  
            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_TransformationData`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromTransformationData(self, newValue)

    def FromPointF2D(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromPointF2D
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_PointF2D`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromPointF2D(self, newValue)

    def FromLineF2D(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromLineF2D
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_LineF2D`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromLineF2D(self, newValue)

    def FromRectangleF(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromRectangleF
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_RectangleF`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromRectangleF(self, newValue)

    def FromCircleF(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromCircleF
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_CircleF`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromCircleF(self, newValue)

    def FromEllipseF(self, newValue):
        r"""

        Pylon::DataProcessing::CVariant::FromEllipseF
        Changes the value referenced by the variant.  

        Parameters
        ----------
        * `newValue` :  
            The new value for the referenced value.  

        pre:  

            *   `IsArray()` returns `false`.  
            *   The type of this `CVariant` is `VariantDataType_EllipseF`.  

        post:  

            *   The referenced value has been changed to the value of `newValue`.  
            *   The data type returned by `GetDataType()` hasn't changed.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_FromEllipseF(self, newValue)

    def GetErrorDescription(self, checkSubValues=True):
        r"""

        Pylon::DataProcessing::CVariant::GetErrorDescription
        Use this method to get the error description of the value.  

        Parameters
        ----------
        * `checkSubValues` :  
            Optionally, also check the subvalues.  

        Returns
        -------
        Error description if the value is in error state, an empty string otherwise.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_GetErrorDescription(self, checkSubValues)

    def HasError(self, checkSubValues=True):
        r"""

        Pylon::DataProcessing::CVariant::HasError
        Use this method to check the error state of the value.  

        Parameters
        ----------
        * `checkSubValues` :  
            Optionally, check also the subvalues.  

        Returns
        -------
        `true` if the value is in error state.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Variant_HasError(self, checkSubValues)

    def SetError(self, message):
        r"""

        Pylon::DataProcessing::CVariant::SetError
        Sets an invalid data error.  

        This method is mainly intended for testing how invalid data are handled by a
        recipe when a variant is provided as input value.  

        Parameters
        ----------
        * `message` :  
            The error message text.  

        pre: The data type is not VariantDataType_None.  

        post:  

            *   An invalid data error with the message text provided has been added to
                the value.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Variant_SetError(self, message)

    @staticmethod
    def MakeVariant(*args):
        return _pylondataprocessing.Variant_MakeVariant(*args)

    def __str__(self):
        resultList = ["Type = "]
        dt = self.GetDataType()
        hasString = False
        if (dt == VariantDataType_None):
            resultList.append("None")
        elif (dt == VariantDataType_Int64):
            resultList.append("Int64")
            hasString = True
        elif (dt == VariantDataType_UInt64):
            resultList.append("UInt64")
            hasString = True
        elif (dt == VariantDataType_Boolean):
            resultList.append("Boolean")
            hasString = True
        elif (dt == VariantDataType_String):
            resultList.append("String")
            hasString = True
        elif (dt == VariantDataType_Float):
            resultList.append("Float")
            hasString = True
        elif (dt == VariantDataType_PylonImage):
            resultList.append("PylonImage")
        elif (dt == VariantDataType_Region):
            resultList.append("Region")
        elif (dt == VariantDataType_TransformationData):
            resultList.append("TransformationData")
            hasString = True
        elif (dt == VariantDataType_PointF2D):
            resultList.append("PointF2D")
            hasString = True
        elif (dt == VariantDataType_LineF2D):
            resultList.append("LineF2D")
            hasString = True
        elif (dt == VariantDataType_RectangleF):
            resultList.append("RectangleF")
            hasString = True
        elif (dt == VariantDataType_CircleF):
            resultList.append("CircleF")
            hasString = True
        elif (dt == VariantDataType_EllipseF):
            resultList.append("EllipseF")
            hasString = True
        else:
            resultList.append("?")

        if self.HasError():
            resultList.append("; Error = ")
            resultList.append(self.GetErrorDescription())
        elif hasString:
            resultList.append("; ")
            resultList.append(self.ToString())

        result = "".join(resultList)
        return result


# Register Variant in _pylondataprocessing:
_pylondataprocessing.Variant_swigregister(Variant)
class Update(object):
    r"""


    The `CUpdate` class can be used to check which output data has been generated by
    which `CRecipe` data update operation and what the corresponding input data is.  

    The pylon recipe uses the concept of updates. An update can consist of the
    synchronized processing of a defined set of data by one or more vTools at the
    same time. Some vTools can trigger updates on their own, e.g., when triggered by
    a preceding update. This causes a chain of updates.  

    \threading The CUpdate class isn't thread-safe.  

    C++ includes: Update.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylondataprocessing.delete_Update

    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::CUpdate::CUpdate
        Copies a `CUpdate` object.  

        Parameters
        ----------
        * `rhs` :  
            The update to copy.  

        post:  

            *   The update data has been copied.  

        \error Doesn't throw C++ exceptions.  

        """
        _pylondataprocessing.Update_swiginit(self, _pylondataprocessing.new_Update(*args))

    def __eq__(self, rhs):
        return _pylondataprocessing.Update___eq__(self, rhs)

    def __lt__(self, rhs):
        return _pylondataprocessing.Update___lt__(self, rhs)

    def GetNumPrecedingUpdates(self):
        r"""

        Pylon::DataProcessing::CUpdate::GetNumPrecedingUpdates
        Get the number of updates that directly caused this update.  

        Returns
        -------
        The number of updates that caused this update.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Update_GetNumPrecedingUpdates(self)

    def GetPrecedingUpdate(self, index):
        r"""

        Pylon::DataProcessing::CUpdate::GetPrecedingUpdate
        Returns the preceding update at the corresponding index.  

        Parameters
        ----------
        * `index` :  
            The index.  

        Returns
        -------
        The preceding update at the corresponding `index`.  

        pre:  

            *   `GetNumPrecedingUpdates()` returns a value larger than zero.  
            *   The `index` passed is smaller than the value returned by
                `GetNumPrecedingUpdates()`.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.Update_GetPrecedingUpdate(self, index)

    def HasBeenTriggeredBy(self, rhs):
        r"""

        Pylon::DataProcessing::CUpdate::HasBeenTriggeredBy
        Checks whether the update passed has triggered this update.  

        Parameters
        ----------
        * `rhs` :  
            The update to compare to.  

        Returns
        -------
        `true` if this update is equal to `rhs`. True if `rhs` is contained in the list
        of preceding updates.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Update_HasBeenTriggeredBy(self, rhs)

    def IsValid(self):
        r"""

        Pylon::DataProcessing::CUpdate::IsValid
        Checks whether the update is valid.  

        Returns
        -------
        `true` if this update is valid.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Update_IsValid(self)

# Register Update in _pylondataprocessing:
_pylondataprocessing.Update_swigregister(Update)
QueueMode_Unlimited = _pylondataprocessing.QueueMode_Unlimited
QueueMode_DropOldest = _pylondataprocessing.QueueMode_DropOldest
QueueMode_DropNewest = _pylondataprocessing.QueueMode_DropNewest
QueueMode_Blocking = _pylondataprocessing.QueueMode_Blocking
class VariantContainer(object):
    r"""


    `CVariantContainer` is a map-like container providing an interface like a C++
    standard library.  

    Values can be processed like this:  

    \threading The `CVariantContainer` class isn't thread-safe.  

    C++ includes: VariantContainer.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Pylon::DataProcessing::CVariantContainer::CVariantContainer
        Move constructs a variant container object.  

        Parameters
        ----------
        * `rhs` :  
            The variant container to move the data from.  

        \error Doesn't throw C++ exceptions.  

        """
        _pylondataprocessing.VariantContainer_swiginit(self, _pylondataprocessing.new_VariantContainer(*args))
    __swig_destroy__ = _pylondataprocessing.delete_VariantContainer

    def count(self, key):
        r"""

        Pylon::DataProcessing::CVariantContainer::count
        Number of elements with key.  

        Parameters
        ----------
        * `key` :  
            The key as string value, typically the name of an input or an output.  

        Returns
        -------
        The number of elements with key, which is either 1 or 0.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.VariantContainer_count(self, key)

    def clear(self):
        r"""

        Pylon::DataProcessing::CVariantContainer::clear
        Clears all elements.  

        post:  

            *   The `CVariantContainer` has no elements.<
                -   >  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.VariantContainer_clear(self)

    def empty(self):
        r"""

        Pylon::DataProcessing::CVariantContainer::empty
        Checks `CVariantContainer` has no elements.  

        Returns
        -------
        `true` if empty, `false` otherwise.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.VariantContainer_empty(self)

    def size(self):
        r"""

        Pylon::DataProcessing::CVariantContainer::size
        Returns the number of elements.  

        Returns
        -------
        The number of elements.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.VariantContainer_size(self)

    def erase(self, key):
        r"""

        Pylon::DataProcessing::CVariantContainer::erase
        Erases an element by key.  

        Parameters
        ----------
        * `key` :  
            The key as string value, typically the name of an input or an output.  

        Returns
        -------
        The number of deletions, which is either 0 or 1.  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.VariantContainer_erase(self, key)

    def getValue(self, key):
        return _pylondataprocessing.VariantContainer_getValue(self, key)

    def setValue(self, key, v):
        return _pylondataprocessing.VariantContainer_setValue(self, key, v)

# Register VariantContainer in _pylondataprocessing:
_pylondataprocessing.VariantContainer_swigregister(VariantContainer)
class OutputObserver(object):
    r"""


    An interface that can be used to receive output data from a `CRecipe`.  

    \threading This interface is called from multiple internal threads of the
    `CRecipe`.  

    C++ includes: IOutputObserver.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylondataprocessing.delete_OutputObserver

    def OutputDataPush(self, recipe, value, update, userProvidedId):
        r"""

        Pylon::DataProcessing::IOutputObserver::OutputDataPush
        This method is called when an output of the `CRecipe` pushes data out.  

        Parameters
        ----------
        * `recipe` :  
            The recipe that produced the output.  
        * `value` :  
            A variant container containing the output data.  
        * `update` :  
            The corresponding update.  
        * `userProvidedId` :  
            This ID is passed to distinguish between different events. This ID has been
            passed when calling `CRecipe::RegisterOutputObserver()`.  

        \error C++ exceptions thrown by this method are caught and ignored.  

        """
        return _pylondataprocessing.OutputObserver_OutputDataPush(self, recipe, value, update, userProvidedId)

    def OnDeregistered(self, recipe):
        r"""

        Pylon::DataProcessing::IOutputObserver::OnDeregistered
        This method is called when the output observer is deregistered from the recipe.
        It can be used to delete the output observer by overloading the method.  

        Parameters
        ----------
        * `recipe` :  
            The recipe that the observer is deregistered from.  

        \error C++ Exceptions thrown by this method are caught and ignored.  

        """
        return _pylondataprocessing.OutputObserver_OnDeregistered(self, recipe)

    def __init__(self):
        if self.__class__ == OutputObserver:
            _self = None
        else:
            _self = self
        _pylondataprocessing.OutputObserver_swiginit(self, _pylondataprocessing.new_OutputObserver(_self, ))
    def __disown__(self):
        self.this.disown()
        _pylondataprocessing.disown_OutputObserver(self)
        return weakref.proxy(self)

# Register OutputObserver in _pylondataprocessing:
_pylondataprocessing.OutputObserver_swigregister(OutputObserver)
class GenericOutputObserverResult(object):
    r"""


    A container for recipe output data.  

    C++ includes: GenericOutputObserver.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Update = property(_pylondataprocessing.GenericOutputObserverResult_Update_get, _pylondataprocessing.GenericOutputObserverResult_Update_set)
    UserProvidedID = property(_pylondataprocessing.GenericOutputObserverResult_UserProvidedID_get, _pylondataprocessing.GenericOutputObserverResult_UserProvidedID_set)
    Container = property(_pylondataprocessing.GenericOutputObserverResult_Container_get, _pylondataprocessing.GenericOutputObserverResult_Container_set)

    def GetContainer(self):
        return _pylondataprocessing.GenericOutputObserverResult_GetContainer(self)

    def __init__(self):
        _pylondataprocessing.GenericOutputObserverResult_swiginit(self, _pylondataprocessing.new_GenericOutputObserverResult())
    __swig_destroy__ = _pylondataprocessing.delete_GenericOutputObserverResult

# Register GenericOutputObserverResult in _pylondataprocessing:
_pylondataprocessing.GenericOutputObserverResult_swigregister(GenericOutputObserverResult)
class GenericOutputObserver(OutputObserver):
    r"""


    A simple Recipe Output Observer that collects recipe outputs in a queue.  

    C++ includes: GenericOutputObserver.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        Pylon::DataProcessing::CGenericOutputObserver::CGenericOutputObserver
        Creates a `CGenericOutputObserver` object.  

        \error Doesn't throw C++ exceptions.  

        """
        _pylondataprocessing.GenericOutputObserver_swiginit(self, _pylondataprocessing.new_GenericOutputObserver())

    def OutputDataPush(self, recipe, value, update, userProvidedId):
        r"""

        Pylon::DataProcessing::IOutputObserver::OutputDataPush
        This method is called when an output of the `CRecipe` pushes data out.  

        Parameters
        ----------
        * `recipe` :  
            The recipe that produced the output.  
        * `value` :  
            A variant container containing the output data.  
        * `update` :  
            The corresponding update.  
        * `userProvidedId` :  
            This ID is passed to distinguish between different events. This ID has been
            passed when calling `CRecipe::RegisterOutputObserver()`.  

        \error C++ exceptions thrown by this method are caught and ignored.  

        """
        return _pylondataprocessing.GenericOutputObserver_OutputDataPush(self, recipe, value, update, userProvidedId)

    def GetWaitObject(self):
        r"""

        Pylon::DataProcessing::CGenericOutputObserver::GetWaitObject
        Returns a WaitObject that is in Signaled state if the queue is not empty and in
        Reset state if it is empty.  

        Returns
        -------
        `WaitObject` of the GenericOutputObserver.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is thread safe.  

        """
        return _pylondataprocessing.GenericOutputObserver_GetWaitObject(self)

    def GetNumResults(self):
        r"""

        Pylon::DataProcessing::CGenericOutputObserver::GetNumResults
        Gets the number of SGenericOutputObserverResults in the queue.  

        Returns
        -------
        `The` number of elements in the queue.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is thread safe.  

        """
        return _pylondataprocessing.GenericOutputObserver_GetNumResults(self)

    def Clear(self):
        r"""

        Pylon::DataProcessing::CGenericOutputObserver::Clear
        Removes all CVariantContainers from the queue.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is thread safe.  

        """
        return _pylondataprocessing.GenericOutputObserver_Clear(self)

    def RetrieveResult(self):
        return _pylondataprocessing.GenericOutputObserver_RetrieveResult(self)

    def RetrieveFullResult(self):
        return _pylondataprocessing.GenericOutputObserver_RetrieveFullResult(self)
    __swig_destroy__ = _pylondataprocessing.delete_GenericOutputObserver

# Register GenericOutputObserver in _pylondataprocessing:
_pylondataprocessing.GenericOutputObserver_swigregister(GenericOutputObserver)
GenericOutputObserverResult.Container = property(GenericOutputObserverResult.GetContainer) 
class UpdateObserver(object):
    r"""


    An interface that can be used to get notified about the processing of updates.  

    \threading This interface is called from multiple internal threads of the
    `Pylon::DataProcessing::CRecipe`.  

    C++ includes: IUpdateObserver.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylondataprocessing.delete_UpdateObserver

    def UpdateDone(self, recipe, update, userProvidedId):
        r"""

        Pylon::DataProcessing::IUpdateObserver::UpdateDone
        This method is called when an update of a `Pylon::DataProcessing::CRecipe` has
        been processed completely.  

        note: If this update has triggered further updates, depending on the vTools used
            in an recipe, the output data may not be available yet.  

        Parameters
        ----------
        * `recipe` :  
            The recipe that processed the update.  
        * `update` :  
            The update that was processed completely.  
        * `userProvidedId` :  
            This ID is passed to distinguish between different events. This ID has been
            passed when calling `CRecipe::TriggerUpdateAsync()` or
            `CRecipe:TriggerUpdate()`.  

        \error C++ Exceptions thrown by this method are caught and ignored.  

        """
        return _pylondataprocessing.UpdateObserver_UpdateDone(self, recipe, update, userProvidedId)

    def __init__(self):
        if self.__class__ == UpdateObserver:
            _self = None
        else:
            _self = self
        _pylondataprocessing.UpdateObserver_swiginit(self, _pylondataprocessing.new_UpdateObserver(_self, ))
    def __disown__(self):
        self.this.disown()
        _pylondataprocessing.disown_UpdateObserver(self)
        return weakref.proxy(self)

# Register UpdateObserver in _pylondataprocessing:
_pylondataprocessing.UpdateObserver_swigregister(UpdateObserver)
class EventData(object):
    r"""


    Data associated with an event inside the recipe. Currently, only errors are
    supported.  

    C++ includes: IEventObserver.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    EventType_Error = _pylondataprocessing.EventData_EventType_Error
    EventType_ErrorReset = _pylondataprocessing.EventData_EventType_ErrorReset
    EventType = property(_pylondataprocessing.EventData_EventType_get, _pylondataprocessing.EventData_EventType_set)
    Description = property(_pylondataprocessing.EventData_Description_get, _pylondataprocessing.EventData_Description_set)
    EventClass = property(_pylondataprocessing.EventData_EventClass_get, _pylondataprocessing.EventData_EventClass_set)
    EventSourceName = property(_pylondataprocessing.EventData_EventSourceName_get, _pylondataprocessing.EventData_EventSourceName_set)

    def __str__(self):
        result = "EventType: {0}; Description = {1};  EventClass = {2}; EventSourceName = {3}".format(self.EventType, self.Description, self.EventClass, self.EventSourceName)
        return result


    def __init__(self):
        _pylondataprocessing.EventData_swiginit(self, _pylondataprocessing.new_EventData())
    __swig_destroy__ = _pylondataprocessing.delete_EventData

# Register EventData in _pylondataprocessing:
_pylondataprocessing.EventData_swigregister(EventData)
class EventObserver(object):
    r"""


    An interface that can be used to receive event data from a `CRecipe`.  

    \threading This interface is called from multiple internal threads of the
    `CRecipe`.  

    C++ includes: IEventObserver.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylondataprocessing.delete_EventObserver

    def OnEventSignaled(self, recipe, pEvents, numEvents):
        r"""

        Pylon::DataProcessing::IEventObserver::OnEventSignaled
        This method is called when the graph of the `CRecipe` detects an event, e.g., an
        error change of a vtool.  

        Parameters
        ----------
        * `recipe` :  
            The recipe that produced the output.  
        * `pEvents` :  
            List of event infos as plain C array.  
        * `numEvents` :  
            Number of entries in that list.  

        \error C++ Exceptions thrown by this method are caught and ignored.  

        """
        return _pylondataprocessing.EventObserver_OnEventSignaled(self, recipe, pEvents, numEvents)

    def OnDeregistered(self, recipe):
        r"""

        Pylon::DataProcessing::IEventObserver::OnDeregistered
        This method is called when the event observer is deregistered from the recipe.
        It can be used to delete the event observer by overloading the method. The
        default implementation of this method does nothing.  

        Parameters
        ----------
        * `recipe` :  
            The recipe that the observer is deregistered from.  

        \error C++ Exceptions thrown by this method are caught and ignored.  

        """
        return _pylondataprocessing.EventObserver_OnDeregistered(self, recipe)

    def __init__(self):
        if self.__class__ == EventObserver:
            _self = None
        else:
            _self = self
        _pylondataprocessing.EventObserver_swiginit(self, _pylondataprocessing.new_EventObserver(_self, ))
    def __disown__(self):
        self.this.disown()
        _pylondataprocessing.disown_EventObserver(self)
        return weakref.proxy(self)

# Register EventObserver in _pylondataprocessing:
_pylondataprocessing.EventObserver_swigregister(EventObserver)
class Recipe(object):
    r"""


    Provides convenient access to a data processing design described by a recipe
    file.  

    C++ includes: Recipe.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        Pylon::DataProcessing::CRecipe::CRecipe
        Creates a `CRecipe` object with no recipe loaded.  

        \error Doesn't throw C++ exceptions.  

        """
        _pylondataprocessing.Recipe_swiginit(self, _pylondataprocessing.new_Recipe())
    __swig_destroy__ = _pylondataprocessing.delete_Recipe

    def Load(self, filename):
        r"""

        Pylon::DataProcessing::CRecipe::Load
        Loads a recipe from disk and creates the objects of the design described by the
        recipe. Relative paths, i.e., relative to the directory the recipe file is
        located in, are used for loading external recipe components, e.g., images.  

        Parameters
        ----------
        * `filename` :  
            The name and path of the recipe.  

        pre:  

            *   The given file name must be a valid file path of an existing file
                containing valid recipe data.  

        post:  

            *   A recipe is loaded. You can use `IsLoaded()` to check whether a recipe
                is loaded. Implicitly calls `Unload()` and unregisters all observers
                already connected.  

        \error Throws an exception if the recipe can't be loaded. No recipe is loaded
        if an error occurred.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_Load(self, filename)

    def LoadFromBinary(self, *args):
        r"""

        Pylon::DataProcessing::CRecipe::LoadFromBinary
        Loads a recipe from binary buffer and creates the objects of the design
        described by the recipe.  

        Parameters
        ----------
        * `pBuffer` :  
            Buffer pointer to binary recipe.  
        * `bufferSize` :  
            Buffer size for binary recipe buffer in bytes.  
        * `directory` :  
            External recipe components, e.g., images, will be loaded relative to this
            directory.  

        pre:  

            *   The buffer specified by pBuffer and bufferSize must contain valid recipe
                data.  

        post:  

            *   A recipe is loaded. You can use `IsLoaded()` to check whether a recipe
                is loaded. Implicitly calls `Unload()` and unregisters all observers
                already connected.  

        \error Throws an exception if the recipe can't be loaded. No recipe is loaded
        if an error occurred.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_LoadFromBinary(self, *args)

    def IsLoaded(self):
        r"""

        Pylon::DataProcessing::CRecipe::IsLoaded
        Checks whether a recipe is loaded.  

        Returns
        -------
        `true` if a recipe is loaded.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_IsLoaded(self)

    def PreAllocateResources(self):
        r"""

        Pylon::DataProcessing::CRecipe::PreAllocateResources
        Optional method to pre-allocate resources.  

        All resources that could be allocated successfully stay allocated until a call
        to `DeallocateResources()`.  

        pre:  

            *   A recipe is loaded.  
            *   The recipe must not be started.  

        post:  

            *   All resources are allocated.  

        \error Throws an exception if:  

        *   The preconditions aren't met.  
        *   The resources couldn't be allocated.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_PreAllocateResources(self)

    def Start(self, *args):
        r"""

        Pylon::DataProcessing::CRecipe::Start
        Prepares the data processing and allocates resources required by the design. In
        addition, the acquisition mode for all Camera and Image Loading vTools can be
        specified (see `EAcquisitionMode` for more details).  

        Parameters
        ----------
        * `acquisitionMode` :  
            The acquisition mode used to start the recipe (see `EAcquisitionMode` for
            more details).  

        pre:  

            *   A recipe has been loaded.  

        \error The recipe is not started if an error occurred. Throws an exception if
        the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_Start(self, *args)

    def IsStarted(self):
        r"""

        Pylon::DataProcessing::CRecipe::IsStarted
        Returns information about the recipe being started.  

        Returns
        -------
        `true` if the recipe has been started.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_IsStarted(self)

    def Stop(self, *args):
        r"""

        Pylon::DataProcessing::CRecipe::Stop
        Finishes the data processing and deallocates all resources allocated at start.  

        Updates may accumulate at some places in the design, e.g., when updates are
        triggered more frequently than can be processed and the queue mode of the
        connections is not set properly. `timeoutMs` describes the time these
        accumulated updates are tolerated before they will be cleared. Updates that are
        already being processed by a vTool will not be aborted when the timeout expires.  

        Parameters
        ----------
        * `timeoutMs` :  
            Time to wait for updates not yet started to be processed.  

        \error Doesn't throw C++ exceptions.  

        post:  

            *   The recipe is stopped.  
            *   Resources allocated when calling `Start()` are deallocated.  
            *   Resources allocated when calling `PreAllocateResources()` are still
                allocated.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_Stop(self, *args)

    def DeallocateResources(self):
        r"""

        Pylon::DataProcessing::CRecipe::DeallocateResources
        Deallocates all resources used by the recipe.  

        Calls `Stop()` if the design described by the recipe has been started.  

        post:  

            *   No resources are allocated.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_DeallocateResources(self)

    def Unload(self):
        r"""

        Pylon::DataProcessing::CRecipe::Unload
        Unloads the recipe currently loaded.  

        Calls `DeallocateResources()` if the design described by the recipe has
        allocated resources. Unregisters all observers that have been connected.  

        pre:  

            *   Data received via `IOutputObserver::OutputDataPush` must be freed.  

        post:  

            *   No recipe is loaded.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_Unload(self)

    def SetRecipeContext(self, context):
        r"""

        Pylon::DataProcessing::CRecipe::SetRecipeContext
        Sets a context.  

        This is useful when handling multiple recipes.  

        You can access the context using `GetRecipeContext()`, e.g., in
        `IOutputObserver::OutputDataPush()`, when receiving data from multiple recipes.  

        Parameters
        ----------
        * `context` :  
            The user-defined context.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using an internal lock for the recipe
        context.  

        """
        return _pylondataprocessing.Recipe_SetRecipeContext(self, context)

    def GetRecipeContext(self):
        r"""

        Pylon::DataProcessing::CRecipe::GetRecipeContext
        Returns the context.  

        This is useful when handling multiple recipes.  

        You can access the context using `GetRecipeContext()`, e.g., in
        `IOutputObserver::OutputDataPush()`, when receiving data from multiple recipes.  

        Returns
        -------
        The context.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using an internal lock for the recipe
        context.  

        """
        return _pylondataprocessing.Recipe_GetRecipeContext(self)

    def HasInput(self, inputFullName):
        r"""

        Pylon::DataProcessing::CRecipe::HasInput
        Checks whether an input pin is available.  

        Parameters
        ----------
        * `inputFullName` :  
            The identifier of the input pin.  

        Returns
        -------
        `true` if the input pin is available.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_HasInput(self, inputFullName)

    def HasOutput(self, outputFullName):
        r"""

        Pylon::DataProcessing::CRecipe::HasOutput
        Checks whether an output pin is available.  

        Parameters
        ----------
        * `outputFullName` :  
            The identifier of the output pin.  

        Returns
        -------
        `true` if the output pin is available.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_HasOutput(self, outputFullName)

    def GetInputType(self, inputFullName):
        r"""

        Pylon::DataProcessing::CRecipe::GetInputType
        Returns the variant data type of the input pin.  

        Parameters
        ----------
        * `inputFullName` :  
            The identifier of the input pin.  

        Returns
        -------
        The variant data type of the input pin.  

        pre:  

            *   An input pin with the name `inputFullName` must exist.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_GetInputType(self, inputFullName)

    def GetInputContainerType(self, inputFullName):
        r"""

        Pylon::DataProcessing::CRecipe::GetInputContainerType
        Returns the variant container type of the input pin.  

        Parameters
        ----------
        * `inputFullName` :  
            The identifier of the input pin.  

        Returns
        -------
        The variant container type of the input pin.  

        pre:  

            *   An input pin with the name `inputFullName` must exist.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_GetInputContainerType(self, inputFullName)

    def GetOutputType(self, outputFullName):
        r"""

        Pylon::DataProcessing::CRecipe::GetOutputType
        Returns the variant data type of the output pin.  

        Parameters
        ----------
        * `outputFullName` :  
            The identifier of the output pin.  

        Returns
        -------
        The variant data type of the output pin.  

        pre:  

            *   An output pin with the name `outputFullName` must exist.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_GetOutputType(self, outputFullName)

    def GetOutputContainerType(self, outputFullName):
        r"""

        Pylon::DataProcessing::CRecipe::GetOutputContainerType
        Returns the variant container type of the output pin.  

        Parameters
        ----------
        * `outputFullName` :  
            The identifier of the output pin.  

        Returns
        -------
        The variant container type of the output pin.  

        pre:  

            *   An output pin with the name `outputFullName` must exist.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_GetOutputContainerType(self, outputFullName)

    def CanTriggerUpdate(self):
        r"""

        Pylon::DataProcessing::CRecipe::CanTriggerUpdate
        Checks whether triggering an update is possible.  

        An update can't be triggered if the recipe is not started or at least one
        connection connected to the input terminal has its queue mode set to blocking
        and there is no space available.  

        Returns
        -------
        `true` if an update can be triggered, `false` otherwise.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_CanTriggerUpdate(self)

    def TriggerUpdateWithReturn(self, *args):
        r"""

        Pylon::DataProcessing::CRecipe::TriggerUpdateWithReturn
        Starts an update in a blocking call for a number of input pins. After the update
        has been processed, a variant container containing the recipe output is
        returned. This method is only intended for cases where the input triggers
        exactly one result.  

        Parameters
        ----------
        * `inputCollection` :  
            Provides the input names and the values.  
        * `timeoutMs` :  
            The timeout for the update to finish completely.  
        * `timeoutHandling` :  
            If timeoutHandling equals TimeoutHandling_ThrowException, a timeout
            exception is thrown on timeout.  

        Returns
        -------
        The variant container that has been output by the recipe.  

        pre:  

            *   The recipe is started.  
            *   The `inputCollection` argument is not empty.  
            *   The input pins exist.  
            *   The types of the values in `inputCollection` are compatible with the
                input data types.  
            *   `CanTriggerUpdate()` must return `true`.  

        \error Throws an exception if the preconditions aren't met. Throws an exception
        if the update couldn't be processed in the time specified by `timeoutMs` and
        `timeoutHandling` == TimeoutHandling_ThrowException.  

        \threading This method is synchronized using the lock provided by `GetLock()`
        while not waiting for the update to finish completely.  

        """
        return _pylondataprocessing.Recipe_TriggerUpdateWithReturn(self, *args)

    def RegisterAllOutputsObserver(self, pObserver, mode, userProvidedId=0):
        r"""

        Pylon::DataProcessing::CRecipe::RegisterAllOutputsObserver
        Adds an output observer to the list of registered output observers.  

        If `mode` equals `RegistrationMode_ReplaceAll`, the list of registered observes
        is cleared.  

        note:  

            *   The observer must not be deleted before the `CRecipe` is destroyed while
                it is registered.  
            *   If the `IOutputObserver` and the `CRecipe` are created on the stack in
                the same scope, the observer must be created prior to the `CRecipe` it
                is registered to because the objects are destroyed in reverse order.  

        Parameters
        ----------
        * `pObserver` :  
            The receiver of events.  
        * `mode` :  
            Indicates how to register the new observer.  
        * `userProvidedId` :  
            This optional ID is passed to distinguish between different events. This ID
            is provided to `IUpdateObserver::UpdateDone`.  

        pre:  

            *   A recipe is loaded.  
            *   `pObserver` is not nullptr.  

        post:  

            *   The observer is registered and called when any output data is available.  

        \error Throws an exception if the preconditions aren't met. If an exception is
        thrown, the observer is not registered and its `OnDeregistered` method will not
        be called.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.Recipe_RegisterAllOutputsObserver(self, pObserver, mode, userProvidedId)

    def RegisterEventObserver(self, pObserver):
        r"""

        Pylon::DataProcessing::CRecipe::RegisterEventObserver
        Registers an event observer to the recipe. Only one single observer per recipe
        is supported. Registering a new one automatically unregisters the old one.
        Registered observers must be unregistered before destruction.  

        Parameters
        ----------
        * `pObserver` :  
            The receiver of events.  

        pre:  

            *   `pObserver` is not nullptr.  

        post:  

            *   The observer is registered and called when events occur, e.g., an error
                is detected by a vTool.  

        \error Throws an exception if the preconditions aren't met. If an exception is
        thrown, the observer is not registered and its `OnDeregistered` method will not
        be called.  

        \threading This method is synchronized using an internal lock for event
        observer handling.  

        """
        return _pylondataprocessing.Recipe_RegisterEventObserver(self, pObserver)

    def UnregisterEventObserver(self):
        r"""

        Pylon::DataProcessing::CRecipe::UnregisterEventObserver
        Removes any registered event observer from the recipe and calls the observer's
        `OnDeregistered` method.  

        If an observer is not found, nothing is done.  

        \error Doesn't throw C++ exceptions.  

        \threading This method is synchronized using an internal lock for event
        observer handling.  

        """
        return _pylondataprocessing.Recipe_UnregisterEventObserver(self)

    def GetLock(self):
        r"""

        Pylon::DataProcessing::CRecipe::GetLock
        Provides access to the lock used for synchronizing the access to the recipe.  

        This lock can be used when extending the Recipe class.  

        Example:  

        \error Doesn't throw C++ exceptions.  

        """
        return _pylondataprocessing.Recipe_GetLock(self)

    def GetOutputNames(self):
        return _pylondataprocessing.Recipe_GetOutputNames(self)

    def GetAllParameterNames(self):
        return _pylondataprocessing.Recipe_GetAllParameterNames(self)

    def ContainsParameter(self, fullname):
        return _pylondataprocessing.Recipe_ContainsParameter(self, fullname)

    def GetParameter(self, fullname):
        return _pylondataprocessing.Recipe_GetParameter(self, fullname)

    def RegisterOutputObserver(self, outputFullNames, pObserver, mode, userProvidedId=0):
        return _pylondataprocessing.Recipe_RegisterOutputObserver(self, outputFullNames, pObserver, mode, userProvidedId)

    def UnregisterOutputObserver(self, pObserver, userProvidedId=0):
        return _pylondataprocessing.Recipe_UnregisterOutputObserver(self, pObserver, userProvidedId)

    def TriggerUpdateAsync(self, inputCollection, pObserver=None, userProvidedId=0):
        return _pylondataprocessing.Recipe_TriggerUpdateAsync(self, inputCollection, pObserver, userProvidedId)

    def TriggerUpdate(self, *args):
        return _pylondataprocessing.Recipe_TriggerUpdate(self, *args)

# Register Recipe in _pylondataprocessing:
_pylondataprocessing.Recipe_swigregister(Recipe)
RecipeFileFormat_JsonDefault = _pylondataprocessing.RecipeFileFormat_JsonDefault
RecipeFileFormat_JsonCompressedBinaryData = _pylondataprocessing.RecipeFileFormat_JsonCompressedBinaryData
class BuildersRecipe(Recipe):
    r"""


    This class can be used to build recipes programmatically and run them.  

    C++ includes: BuildersRecipe.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::CBuildersRecipe
        Creates a `CBuildersRecipe` object.  

        \error Doesn't throw C++ exceptions.  

        """
        _pylondataprocessing.BuildersRecipe_swiginit(self, _pylondataprocessing.new_BuildersRecipe())
    __swig_destroy__ = _pylondataprocessing.delete_BuildersRecipe

    def GetVToolDisplayNameForTypeID(self, vToolTypeID):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::GetVToolDisplayNameForTypeID
        Retrieves the display name of the vTool type identified by the given type ID.  

        Parameters
        ----------
        * `vToolTypeID` :  
            The type ID of the vTool type whose display name is retrieved.  

        pre:  

            *   `vToolTypeID` refers to an available vTool type (use
                `GetAvailableVToolTypeIDs()` to get a list of all available vTool type
                IDs).  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        The display name of the vTool type identified by `vToolTypeID`.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_GetVToolDisplayNameForTypeID(self, vToolTypeID)

    def AddVTool(self, *args):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::AddVTool
        Creates a vTool of a specific type and adds it to the recipe with an
        automatically generated identifier.  

        Parameters
        ----------
        * `vToolTypeID` :  
            Type ID specifying the vTool type of the vTool to be added.  

        pre:  

            *   `vToolTypeID` refers to an available vTool type (use
                `GetAvailableVToolTypeIDs()` to get a list of all available vTool type
                IDs).  
            *   Your license allows instantiating the requested vTool type from the Data
                Processing SDK.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   A new vTool of the type identified by `vToolTypeID` has been added to
                the recipe with a unique identifier.  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        Returns the identifier of the newly created vTool instance.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_AddVTool(self, *args)

    def GetVToolTypeID(self, identifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::GetVToolTypeID
        Returns the type ID of the vTool instance with the given identifier.  

        Parameters
        ----------
        * `identifier` :  
            Identifier of the vTool whose type ID is retrieved.  

        pre:  

            *   The recipe contains a vTool with the identifier `identifier`.  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        The type ID of the vTool instance with the identifier `identifier`.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_GetVToolTypeID(self, identifier)

    def HasVTool(self, identifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::HasVTool
        Checks whether the recipe contains a vTool with a specific identifier.  

        Parameters
        ----------
        * `identifier` :  
            Identifier of the vTool.  

        \error Doesn't throw C++ exceptions.  

        Returns
        -------
        Returns true if the recipe contains a vTool with the identifier `identifier`,
        otherwise false.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_HasVTool(self, identifier)

    def RenameVTool(self, oldIdentifier, newIdentifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::RenameVTool
        Assigns a new identifier to an existing vTool instance.  

        Parameters
        ----------
        * `oldIdentifier` :  
            The identifier of the vTool to be renamed.  
        * `newIdentifier` :  
            The new identifier of the vTool.  

        pre:  

            *   The recipe contains a vTool with the identifier `oldIdentifier`.  
            *   `newIdentifier` is a valid C++ identifier and must not start with an
                underscore.  
            *   The recipe doesn't contain a vTool with the identifier `newIdentifier`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The vTool with the identifier `oldIdentifier` has been renamed to
                `newIdentifier`.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_RenameVTool(self, oldIdentifier, newIdentifier)

    def RemoveVTool(self, identifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::RemoveVTool
        Removes an existing vTool instance. Any connections attached to any of the
        vTool's pins will be removed as well.  

        Parameters
        ----------
        * `identifier` :  
            The identifier of the vTool to be removed.  

        pre:  

            *   The recipe contains a vTool with the identifier `identifier`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The vTool with the identifier `identifier` has been removed from the
                recipe.  
            *   Any connections attached to any of the vTool's pins have been removed
                from the recipe.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_RemoveVTool(self, identifier)

    def AddInput(self, *args):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::AddInput
        Adds an input of a specific type to the recipe with an automatically generated
        identifier.  

        Parameters
        ----------
        * `inputDataType` :  
            Data type of the new input.  
        * `inputContainerType` :  
            Container type of the new input.  

        pre:  

            *   `inputDataType` refers to an actual data type and is not equal to
                `VariantDataType_Composite`, `VariantDataType_None`, or
                `VariantDataType_Unsupported`.  
            *   `inputContainerType` refers to an actual container type and is not equal
                to `VariantContainerType_Unsupported`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   An input with the type identified by `inputDataType` and
                `inputContainerType` has been added to the recipe.  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        Returns the automatically generated identifier of the newly created input.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_AddInput(self, *args)

    def RenameInput(self, oldInputFullName, newInputFullName):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::RenameInput
        Assigns a new identifier to an existing input.  

        Parameters
        ----------
        * `oldInputFullName` :  
            The identifier of the input to be renamed.  
        * `newInputFullName` :  
            The new identifier of the input.  

        pre:  

            *   The recipe contains an input with the identifier `oldInputFullName`.  
            *   `newInputFullName` is a valid C++ identifier and must not start with an
                underscore.  
            *   The recipe doesn't contain an input with the identifier
                `newInputFullName`.  
            *   The input with the given identifier isn't connected.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The input with the identifier `oldInputFullName` has been renamed to
                `newInputFullName`.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_RenameInput(self, oldInputFullName, newInputFullName)

    def RemoveInput(self, inputFullName):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::RemoveInput
        Removes an input from the recipe. If any connections are attached to this input,
        they will be removed as well.  

        Parameters
        ----------
        * `inputFullName` :  
            The identifiers of the input to be removed.  

        pre:  

            *   The recipe has an input with the identifier `inputFullName`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The input with the identifier `inputFullName` has been removed from the
                recipe.  
            *   Any connections attached to the removed input have been removed.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_RemoveInput(self, inputFullName)

    def AddOutput(self, *args):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::AddOutput
        Adds an output of a specific type to the recipe with an automatically generated
        identifier.  

        Parameters
        ----------
        * `outputDataType` :  
            Data type of the new output.  
        * `outputContainerType` :  
            Container type of the new output.  

        pre:  

            *   `outputDataType` refers to an actual data type and is not equal to
                `VariantDataType_Composite`, `VariantDataType_None`, or
                `VariantDataType_Unsupported`.  
            *   `outputContainerType` refers to an actual container type and is not
                equal to `VariantContainerType_Unsupported`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   An output with the type identified by `outputDataType` and
                `outputContainerType` has been added to the recipe.  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        Returns the automatically generated identifier of the newly created output.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_AddOutput(self, *args)

    def RenameOutput(self, oldOutputFullName, newOutputFullName):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::RenameOutput
        Assigns a new identifier to an existing output.  

        Parameters
        ----------
        * `oldOutputFullName` :  
            The identifier of the output to be renamed.  
        * `newOutputFullName` :  
            The new identifier of the output.  

        pre:  

            *   The recipe contains an output with the identifier `oldOutputFullName`.  
            *   `newOutputFullName` is a valid C++ identifier and must not start with an
                underscore.  
            *   The recipe doesn't contain an output with the identifier
                `newOutputFullName`.  
            *   The output with the given identifier isn't connected.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The output with the identifier `oldOutputFullName` has been renamed to
                `newOutputFullName`.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_RenameOutput(self, oldOutputFullName, newOutputFullName)

    def RemoveOutput(self, outputFullName):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::RemoveOutput
        Removes an output from the recipe. If a connection is attached to this output,
        it will be removed as well.  

        Parameters
        ----------
        * `outputFullName` :  
            The identifier of the output to be removed.  

        pre:  

            *   The recipe contains an output with the identifier `outputFullName`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The output with the identifier `outputFullName` has been removed from
                the recipe.  
            *   If a connection was attached to this output, it has been removed from
                the recipe.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_RemoveOutput(self, outputFullName)

    def AddConnection(self, *args):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::AddConnection
        Creates a connection between vTool pins and/or recipe inputs or outputs with an
        automatically generated identifier.  

        Parameters
        ----------
        * `sourceFullName` :  
            Full name of the source of the connection in the form
            "[vToolIdentifier].[vToolOutputIdentifier]" (e.g., "Camera.Image" or
            "myVTool.Point"). To create a connection from a recipe input, use
            <RecipeInput> as the vToolIdentifier (e.g., "\<RecipeInput\>.Image").  
        * `destinationFullName` :  
            Full name of the destination of the connection
            "[vToolIdentifier].[vToolInputIdentifier]" (e.g.,
            "ImageFormatConverter.Image" or "myVTool.Point"). To create a connection
            to a recipe output, use <RecipeOutput> as the vToolIdentifier (e.g.,
            "\<RecipeOutput\>.Image").  
        * `queueMode` :  
            The queue mode for the connection queue (see `EQueueMode` for all available
            queue modes). The default value is QueueMode_Blocking.  
        * `maxQueueSize` :  
            The initial maximum size of the connection queue. The default value is 1. If
            `queueMode` is `QueueMode_Unlimited`, this has no effect.  

        pre:  

            *   `sourceFullName` must specify the full name of an existing vTool output
                pin or an existing recipe input.  
            *   `destinationFullName` must specify the full name of an existing vTool
                input pin or an existing recipe output.  
            *   `sourceFullName` and `destinationFullName` must have compatible data
                types.  
            *   `maxQueueSize` must be greater than 0 and lower than the maximum value
                of size_t.  
            *   The destination must not be connected.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   A new connection has been created in the recipe connecting
                `sourceFullName` to `destinationFullName`.  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        Returns the identifier of the newly created connection.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_AddConnection(self, *args)

    def GetConnectionMaxQueueSize(self, identifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::GetConnectionMaxQueueSize
        Gets the current maximum queue size for a connection identified by its
        identifier.  

        Parameters
        ----------
        * `identifier` :  
            Identifier of the connection whose maximum queue size is retrieved.  

        pre:  

            *   The recipe contains a connection with the identifier `identifier`.  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        The maximum queue size of the connection with the identifier `identifier`.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_GetConnectionMaxQueueSize(self, identifier)

    def GetConnectionSource(self, identifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::GetConnectionSource
        Gets the full name of a connection's source.  

        Parameters
        ----------
        * `identifier` :  
            Identifier of the connection.  

        pre:  

            *   The recipe contains a connection with the identifier `identifier`.  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        The full name of the connection's source.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_GetConnectionSource(self, identifier)

    def GetConnectionDestination(self, identifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::GetConnectionDestination
        Gets the full name of a connection's destination.  

        Parameters
        ----------
        * `identifier` :  
            Identifier of the connection.  

        pre:  

            *   The recipe contains a connection with the identifier `identifier`.  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        The full name of the connection's destination.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_GetConnectionDestination(self, identifier)

    def GetConnectionQueueMode(self, identifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::GetConnectionQueueMode
        Gets the current queue mode for a connection identified by its identifier.  

        Parameters
        ----------
        * `identifier` :  
            Identifier of the connection whose queue mode is retrieved.  

        pre:  

            *   The recipe contains a connection with the identifier `identifier`.  

        \error Throws an exception if the preconditions aren't met.  

        Returns
        -------
        The queue mode of the connection with the identifier `identifier`.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_GetConnectionQueueMode(self, identifier)

    def HasConnection(self, identifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::HasConnection
        Checks whether the recipe contains a connection with a specific identifier.  

        Parameters
        ----------
        * `identifier` :  
            Identifier of the connection.  

        \error Doesn't throw C++ exceptions.  

        Returns
        -------
        Returns true if the recipe contains a connection with the identifier
        `identifier`, otherwise false.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_HasConnection(self, identifier)

    def RenameConnection(self, oldIdentifier, newIdentifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::RenameConnection
        Assigns a new identifier to an existing connection.  

        Parameters
        ----------
        * `oldIdentifier` :  
            The identifier of the connection to be renamed.  
        * `newIdentifier` :  
            The new identifier of the connection.  

        pre:  

            *   The recipe contains a connection with the identifier `oldIdentifier`.  
            *   `newIdentifier` is a valid C++ identifier and must not start with an
                underscore.  
            *   The recipe doesn't contain a connection with the identifier
                `newIdentifier`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The connection with the identifier `oldIdentifier` has been renamed to
                `newIdentifier`.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_RenameConnection(self, oldIdentifier, newIdentifier)

    def SetConnectionSettings(self, identifier, queueMode, maxQueueSize):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::SetConnectionSettings
        Modifies the settings of an existing connection.  

        Parameters
        ----------
        * `identifier` :  
            The identifier of the connection to be modified.  
        * `queueMode` :  
            The new queue mode of the connection.  
        * `maxQueueSize` :  
            The new maximum queue size of the connection.  

        pre:  

            *   The recipe contains a connection with the identifier `identifier`.  
            *   `maxQueueSize` must be greater than 0 and lower than the maximum value
                of size_t.  

        post:  

            *   The connection's queue mode has been set to `queueMode`.  
            *   The connection's maximum queue size has been set to `maxQueueSize`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_SetConnectionSettings(self, identifier, queueMode, maxQueueSize)

    def SetConnectionQueueMode(self, identifier, queueMode):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::SetConnectionQueueMode
        Modifies the queue mode of an existing connection.  

        Parameters
        ----------
        * `identifier` :  
            The identifier of the connection to be modified.  
        * `queueMode` :  
            The new queue mode of the connection.  

        pre:  

            *   The recipe contains a connection with the identifier `identifier`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The connection's queue mode has been set to `queueMode`.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_SetConnectionQueueMode(self, identifier, queueMode)

    def SetConnectionMaxQueueSize(self, identifier, maxQueueSize):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::SetConnectionMaxQueueSize
        Modifies the maximum queue size of an existing connection.  

        Parameters
        ----------
        * `identifier` :  
            The identifier of the connection to be modified.  
        * `maxQueueSize` :  
            The new maximum queue size of the connection.  

        pre:  

            *   The recipe contains a connection with the identifier `identifier`.  
            *   `maxQueueSize` must be greater than 0 and lower than the maximum value
                of size_t.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The connection's maximum queue size has been set to `maxQueueSize`.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_SetConnectionMaxQueueSize(self, identifier, maxQueueSize)

    def RemoveConnection(self, identifier):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::RemoveConnection
        Removes an existing connection.  

        Parameters
        ----------
        * `identifier` :  
            The identifier of the connection to be removed.  

        pre:  

            *   The recipe contains a connection with the identifier `identifier`.  
            *   The recipe hasn't been started (i.e., IsStarted() must return false).  

        post:  

            *   The connection with the identifier `identifier` has been removed from
                the recipe.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_RemoveConnection(self, identifier)

    def Save(self, fileName):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::Save
        Writes the recipe to a recipe file.  

        Parameters
        ----------
        * `fileName` :  
            Path to the file to store the recipe in. This can be an absolute or a
            relative path. If it is relative, the file will be saved relative to your
            current working directory.  

        pre:  

            *   `fileName` is a writable file path and a valid file path for your
                platform.  

        post:  

            *   The recipe has been written to the specified file path and can be loaded
                using the `CRecipe` API.  

        \error Throws an exception if the preconditions aren't met.  

        \threading This method is synchronized using the lock provided by `GetLock()`.  

        """
        return _pylondataprocessing.BuildersRecipe_Save(self, fileName)

    def SaveAs(self, format, fileName):
        return _pylondataprocessing.BuildersRecipe_SaveAs(self, format, fileName)

    def ResetToEmpty(self):
        r"""

        Pylon::DataProcessing::CBuildersRecipe::ResetToEmpty
        Resets the recipe by removing all vTools, inputs, outputs, connections, and
        observers. Stop() is called implicitly with an infinite timeout if the recipe
        has been started.  

        post:  

            *   The recipe is empty, i.e., all vTools, inputs, outputs, connections, and
                observers have been removed.  
            *   `IsStarted()` returns false.  
            *   `IsLoaded()` returns true.  
            *   The recipe can be modified.  

        \error Throws an exception if the preconditions aren't met.  

        """
        return _pylondataprocessing.BuildersRecipe_ResetToEmpty(self)

    def GetAvailableVToolTypeIDs(self):
        return _pylondataprocessing.BuildersRecipe_GetAvailableVToolTypeIDs(self)

    def GetVToolIdentifiers(self):
        return _pylondataprocessing.BuildersRecipe_GetVToolIdentifiers(self)

    def GetInputNames(self):
        return _pylondataprocessing.BuildersRecipe_GetInputNames(self)

    def GetConnectionIdentifiers(self):
        return _pylondataprocessing.BuildersRecipe_GetConnectionIdentifiers(self)

# Register BuildersRecipe in _pylondataprocessing:
_pylondataprocessing.BuildersRecipe_swigregister(BuildersRecipe)
TransformationData.ColumnCount = property(TransformationData.GetColumnCount) 
TransformationData.RowCount = property(TransformationData.GetRowCount) 
Region.RegionType = property(Region.GetRegionType) 
Region.AllocatedBufferSize = property(Region.GetAllocatedBufferSize) 
Region.DataSize = property(Region.GetDataSize) 
Region.ReferenceWidth = property(Region.GetReferenceWidth) 
Region.ReferenceHeight = property(Region.GetReferenceHeight) 
Region.BoundingBoxTopLeftX = property(Region.GetBoundingBoxTopLeftX) 
Region.BoundingBoxTopLeftY = property(Region.GetBoundingBoxTopLeftY) 
Region.BoundingBoxWidth = property(Region.GetBoundingBoxWidth) 
Region.BoundingBoxHeight = property(Region.GetBoundingBoxHeight) 
Variant.DataType = property(Variant.GetDataType) 
Variant.NumSubValues = property(Variant.GetNumSubValues) 
Variant.NumArrayValues = property(Variant.GetNumArrayValues) 
Update.NumPrecedingUpdates = property(Update.GetNumPrecedingUpdates) 
Recipe.RecipeContext = property(Recipe.GetRecipeContext) 
GenericOutputObserver.NumResults = property(GenericOutputObserver.GetNumResults) 
GenericOutputObserver.WaitObject = property(GenericOutputObserver.GetWaitObject) 


__version__ = '4.2.0'
