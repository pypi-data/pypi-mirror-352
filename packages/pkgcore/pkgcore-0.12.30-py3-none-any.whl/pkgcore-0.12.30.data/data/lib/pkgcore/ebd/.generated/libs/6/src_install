best_version () 
{ 
    __ebd_ipc_cmd ${FUNCNAME} "" "$@"
}
debug-print () 
{ 
    :
}
debug-print-function () 
{ 
    :
}
debug-print-section () 
{ 
    :
}
default () 
{ 
    if __is_function default_pkg_${EBUILD_PHASE}; then
        default_pkg_${EBUILD_PHASE};
    else
        if __is_function default_src_${EBUILD_PHASE}; then
            default_src_${EBUILD_PHASE};
        else
            die "default is not available in ebuild phase '${EBUILD_PHASE}'";
        fi;
    fi
}
default_src_install () 
{ 
    __phase_src_install
}
diropts () 
{ 
    export DIROPTIONS=$@
}
docinto () 
{ 
    ${PKGCORE_PREFIX_SUPPORT} || local ED=${D};
    if [[ $1 == "/" ]]; then
        export PKGCORE_DOCDESTTREE="";
    else
        export PKGCORE_DOCDESTTREE=$1;
    fi
}
docompress () 
{ 
    __ebd_ipc_cmd ${FUNCNAME} "" "$@"
}
ebegin () 
{ 
    local msg="$* ...";
    einfon "${msg}";
    echo;
    PKGCORE_RC_LAST_CMD="ebegin";
    return 0
}
eend () 
{ 
    local retval=${1:-0};
    shift;
    local msg;
    if [[ ${retval} == 0 ]]; then
        msg="${PKGCORE_RC_BRACKET}[ ${PKGCORE_RC_GOOD}ok${PKGCORE_RC_BRACKET} ]${PKGCORE_RC_NORMAL}";
    else
        if [[ $# -ne 0 ]]; then
            eerror "$*";
        fi;
        msg="${PKGCORE_RC_BRACKET}[ ${PKGCORE_RC_BAD}!!${PKGCORE_RC_BRACKET} ]${PKGCORE_RC_NORMAL}";
    fi;
    echo -e "${PKGCORE_RC_ENDCOL} ${msg}" 1>&2;
    return ${retval}
}
eerror () 
{ 
    __elog_base ERROR "$*";
    printf " ${PKGCORE_RC_BAD}*${PKGCORE_RC_NORMAL} %b\n" "${*}" 1>&2;
    PKGCORE_RC_LAST_CMD="eerror";
    return 0
}
einfo () 
{ 
    printf " ${PKGCORE_RC_GOOD}*${PKGCORE_RC_NORMAL} %b\n" "${*}" 1>&2;
    PKGCORE_RC_LAST_CMD="einfo";
    return 0
}
einfon () 
{ 
    __elog_base INFO "$*";
    printf " ${PKGCORE_RC_GOOD}*${PKGCORE_RC_NORMAL} %b" "${*}" 1>&2;
    PKGCORE_RC_LAST_CMD="einfon";
    return 0
}
einstall () 
{ 
    die "${FUNCNAME}: banned in EAPI 6"
}
einstalldocs () 
{ 
    local docs PKGCORE_DOCDESTTREE=;
    if ! docs=$(declare -p DOCS 2> /dev/null); then
        local -a DOCS;
        for docs in README* ChangeLog AUTHORS NEWS TODO CHANGES THANKS BUGS FAQ CREDITS CHANGELOG;
        do
            [[ -s ${docs} ]] && DOCS+=(${docs});
        done;
        if [[ ${#DOCS[@]} -gt 0 ]]; then
            dodoc "${DOCS[@]}" || return $?;
        fi;
    else
        if [[ ${docs} == "declare -a "* ]]; then
            if [[ ${#DOCS[@]} -gt 0 ]]; then
                dodoc -r "${DOCS[@]}" || return $?;
            fi;
        else
            if [[ -n ${DOCS} ]]; then
                dodoc -r ${DOCS} || return $?;
            fi;
        fi;
    fi;
    PKGCORE_DOCDESTTREE=html;
    if ! docs=$(declare -p HTML_DOCS 2> /dev/null); then
        :;
    else
        if [[ ${docs} == "declare -a "* ]]; then
            if [[ ${#HTML_DOCS[@]} -gt 0 ]]; then
                dodoc -r "${HTML_DOCS[@]}" || return $?;
            fi;
        else
            if [[ -n ${HTML_DOCS} ]]; then
                dodoc -r ${HTML_DOCS} || return $?;
            fi;
        fi;
    fi;
    return 0
}
elog () 
{ 
    __elog_base LOG "$*";
    printf " ${PKGCORE_RC_GOOD}*${PKGCORE_RC_NORMAL} %b\n" "${*}" 1>&2;
    PKGCORE_RC_LAST_CMD="elog";
    return 0
}
eqawarn () 
{ 
    __elog_base QA "$*";
    printf " ${PKGCORE_RC_WARN}*${PKGCORE_RC_NORMAL} %b\n" "${*}" 1>&2;
    PKGCORE_RC_LAST_CMD="eqawarn";
    return 0
}
ewarn () 
{ 
    __elog_base WARN "$*";
    printf " ${PKGCORE_RC_WARN}*${PKGCORE_RC_NORMAL} %b\n" "${*}" 1>&2;
    PKGCORE_RC_LAST_CMD="ewarn";
    return 0
}
exeinto () 
{ 
    ${PKGCORE_PREFIX_SUPPORT} || local ED=${D};
    if [[ $1 == "/" ]]; then
        export PKGCORE_EXEDESTTREE="";
    else
        export PKGCORE_EXEDESTTREE=$1;
    fi
}
exeopts () 
{ 
    { 
        has -s "$@" || has --strip "$@"
    } && ewarn "exeopts shouldn't be given -s; stripping should be left to the manager.";
    export EXEOPTIONS=$@
}
get_libdir () 
{ 
    __get_libdir lib
}
has () 
{ 
    local needle=$1;
    shift;
    local IFS='';
    [[ "${IFS}${*}${IFS}" != *"${IFS}${needle}${IFS}"* ]] && return 1;
    IFS=' ';
    [[ *''* != $* ]] && return 0;
    __shopt_push +x;
    local x;
    for x in "$@";
    do
        if [[ ${x} == ${needle} ]]; then
            __shopt_pop;
            return 0;
        fi;
    done;
    __shopt_pop;
    return 1
}
has_version () 
{ 
    return $(__ebd_ipc_cmd ${FUNCNAME} "" "$@")
}
hasq () 
{ 
    has ${EBUILD_PHASE} prerm postrm || eqawarn "QA Notice: The 'hasq' function is deprecated (replaced by 'has')";
    has "$@"
}
hasv () 
{ 
    has "$@" && echo "$1"
}
in_iuse () 
{ 
    [[ $1 =~ ${PKGCORE_IUSE_EFFECTIVE} ]]
}
insinto () 
{ 
    ${PKGCORE_PREFIX_SUPPORT} || local ED=${D};
    if [[ $1 == "/" ]]; then
        export PKGCORE_INSDESTTREE="";
    else
        export PKGCORE_INSDESTTREE=$1;
    fi;
    ${PKGCORE_HAS_DESTTREE} && export INSDESTTREE=${PKGCORE_INSDESTTREE}
}
insopts () 
{ 
    { 
        has -s "$@" || has --strip "$@"
    } && ewarn "insopts shouldn't be given -s; stripping should be left to the manager.";
    export INSOPTIONS=$@
}
into () 
{ 
    ${PKGCORE_PREFIX_SUPPORT} || local ED=${D};
    if [[ $1 == "/" ]]; then
        export PKGCORE_DESTTREE="";
    else
        export PKGCORE_DESTTREE=$1;
    fi;
    ${PKGCORE_HAS_DESTTREE} && export DESTTREE=${PKGCORE_DESTTREE}
}
libopts () 
{ 
    { 
        has -s "$@" || has --strip "$@"
    } && ewarn "libopts shouldn't be given -s; stripping should be left to the manager.";
    export LIBOPTIONS=$@
}
nonfatal () 
{ 
    PKGCORE_NONFATAL=true "$@"
}
unpack () 
{ 
    __ebd_ipc_cmd ${FUNCNAME} "" "$@"
}
use () 
{ 
    if [[ ! ${1#!} =~ ${PKGCORE_IUSE_EFFECTIVE} ]]; then
        die "USE flag '${1#!}' not in IUSE for ${CATEGORY}/${PF}";
    fi;
    local IFS=' 	
';
    if [[ ${1:0:1} == "!" ]]; then
        ! __safe_has "${1#!}" ${USE};
    else
        __safe_has "$1" ${USE};
    fi
}
use_enable () 
{ 
    if [[ -z $1 ]]; then
        echo "!!! use_enable() called without a parameter." 1>&2;
        echo "!!! use_enable <USEFLAG> [<flagname> [value]]" 1>&2;
        return;
    fi;
    local ue_suffix="";
    if __safe_has "${EAPI}" 0 1 2 3; then
        ue_suffix=${3:+=$3};
    else
        ue_suffix=${3+=$3};
    fi;
    local uword=$2;
    if [[ -z ${uword} ]]; then
        uword=$1;
    fi;
    if use "$1"; then
        echo "--enable-${uword}${ue_suffix}";
        return 0;
    fi;
    echo "--disable-${uword}";
    return 1
}
use_with () 
{ 
    if [[ -z $1 ]]; then
        echo "!!! use_with() called without a parameter." 1>&2;
        echo "!!! use_with <USEFLAG> [<flagname> [value]]" 1>&2;
        return;
    fi;
    local uw_suffix="";
    if __safe_has "${EAPI}" 0 1 2 3; then
        uw_suffix=${3:+=$3};
    else
        uw_suffix=${3+=$3};
    fi;
    local uword=$2;
    if [[ -z ${uword} ]]; then
        uword=$1;
    fi;
    if use "$1"; then
        echo "--with-${uword}${uw_suffix}";
        return 0;
    fi;
    echo "--without-${uword}";
    return 1
}
useq () 
{ 
    use "$@"
}
usev () 
{ 
    if use "$1"; then
        echo "${1#!}";
        return 0;
    fi;
    return 1
}
usex () 
{ 
    use "$1" && echo "${2-yes}$4" || echo "${3-no}$5";
    return 0
}
