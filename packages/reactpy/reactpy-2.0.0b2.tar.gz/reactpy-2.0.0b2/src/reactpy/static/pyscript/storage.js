const{ArrayBuffer:e}=globalThis,{getPrototypeOf:t}=Object,s=t(Int32Array),{assign:n}=Object,r="entries",a="readonly",i="readwrite",c={durability:"default",prefix:"IDBMap"},o=({target:{result:e}})=>e;class u extends EventTarget{#e;#t;#s;async#n(e,t){const s=(await this.#e).transaction(r,t,this.#t);return new Promise(((t,a)=>n(e(s.objectStore(r)),{onsuccess:t,onerror:a})))}constructor(e,{durability:t=c.durability,prefix:s=c.prefix}=c){super(),this.#s=s,this.#t={durability:t},this.#e=new Promise(((t,s)=>{n(indexedDB.open(`${this.#s}/${e}`),{onupgradeneeded({target:{result:e,transaction:s}}){e.objectStoreNames.length||e.createObjectStore(r),s.oncomplete=()=>t(e)},onsuccess(e){t(o(e))},onerror(e){s(e),this.dispatchEvent(e)}})})).then((e=>{const t=this.dispatchEvent.bind(this);for(const s in e)s.startsWith("on")&&(e[s]=t);return e}))}dispatchEvent(e){const{type:t,message:s,isTrusted:r}=e;return super.dispatchEvent(r?n(new Event(t),{message:s}):e)}async close(){(await this.#e).close()}get size(){return this.#n((e=>e.count()),a).then(o)}async clear(){await this.#n((e=>e.clear()),i)}async delete(e){await this.#n((t=>t.delete(e)),i)}async entries(){const e=await this.keys();return Promise.all(e.map((e=>this.get(e).then((t=>[e,t])))))}async forEach(e,t=this){for(const[s,n]of await this.entries())await e.call(t,n,s,this)}async get(e){return await this.#n((t=>t.get(e)),a).then(o)}async has(e){return void 0!==await this.#n((t=>t.getKey(e)),a).then(o)}async keys(){return await this.#n((e=>e.getAllKeys()),a).then(o)}async set(e,t){return await this.#n((s=>s.put(t,e)),i),this}async values(){const e=await this.keys();return Promise.all(e.map((e=>this.get(e))))}get[Symbol.toStringTag](){return this.#s}}class l extends Map{#r;#a;constructor(...e){super(),this.#r=new u(...e),this.#a=this.#r.entries().then((e=>{for(const[t,s]of e)super.set(t,s)}))}async close(){await this.#a,await this.#r.close()}async sync(){await this.#a}clear(){return this.#a=this.#a.then((()=>this.#r.clear())),super.clear()}delete(e){return this.#a=this.#a.then((()=>this.#r.delete(e))),super.delete(e)}set(e,t){return this.#a=this.#a.then((()=>this.#r.set(e,t))),super.set(e,t)}}const{parse:h,stringify:y}=JSON,{keys:p}=Object,f=String,w="string",d={},g="object",m=(e,t)=>t,b=e=>e instanceof f?f(e):e,x=(e,t)=>typeof t===w?new f(t):t,v=(e,t,s,n)=>{const r=[];for(let a=p(s),{length:i}=a,c=0;c<i;c++){const i=a[c],o=s[i];if(o instanceof f){const a=e[o];typeof a!==g||t.has(a)?s[i]=n.call(s,i,a):(t.add(a),s[i]=d,r.push({k:i,a:[e,t,a,n]}))}else s[i]!==d&&(s[i]=n.call(s,i,o))}for(let{length:e}=r,t=0;t<e;t++){const{k:e,a:a}=r[t];s[e]=n.call(s,e,v.apply(null,a))}return s},q=(e,t,s)=>{const n=f(t.push(s)-1);return e.set(s,n),n},S=(e,t,s)=>{const n=m,r=new Map,a=[],i=[];let c=+q(r,a,n.call({"":e},"",e)),o=!c;for(;c<a.length;)o=!0,i[c]=y(a[c++],u,s);return"["+i.join(",")+"]";function u(e,t){if(o)return o=!o,t;const s=n.call(this,e,t);switch(typeof s){case g:if(null===s)return s;case w:return r.get(s)||q(r,a,s)}return s}},j=e=>{const[t,s]=(e=>{const t=h(e,x).map(b),s=t[0],n=m,r=typeof s===g&&s?v(t,new Set,s,n):s;return n.call({"":r},"",r)})(e);return"null"===t?null:"generic"===t?s:"bytearray"===t?new Uint8Array(e).buffer:"memoryview"===t?new Uint8Array(e):e},E=async t=>{if(!t)throw new SyntaxError("The storage name must be defined");const n=new l(`@pyscript/${t}`),r=new Map;await n.sync();for(const[e,t]of n.entries())r.set(e,j(t));const a=()=>{r.clear(),n.clear()},i=async()=>{await n.sync()};return new Proxy(r,{ownKeys:e=>[...e.keys()],has:(e,t)=>e.has(t),get:(e,t)=>"clear"===t?a:"sync"===t?i:e.get(t),set:(t,r,a)=>(t.set(r,a),n.set(r,(t=>{if(null==t)return S(["null",0]);switch(typeof t){case"object":if(t instanceof s)return S(["memoryview",[...t]]);if(t instanceof e)return S(["bytearray",[...new Uint8Array(t)]]);case"string":case"number":case"boolean":return S(["generic",t]);default:throw new TypeError(`Unexpected value: ${String(t)}`)}})(a)),!0),deleteProperty:(e,t)=>(e.has(t)&&(e.delete(t),n.delete(t)),!0)})};export{E as storage};
//# sourceMappingURL=storage.js.map
