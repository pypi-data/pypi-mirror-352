{"version":3,"file":"storage.js","sources":["../node_modules/sabayon/src/shared.js","../node_modules/@webreflection/idb-map/index.js","../node_modules/@webreflection/idb-map/sync.js","../node_modules/flatted/esm/index.js","../src/storage.js"],"sourcesContent":["// (c) Andrea Giammarchi - MIT\n\nconst ACTION_INIT = 0;\nconst ACTION_NOTIFY = 1;\nconst ACTION_WAIT = 2;\nconst ACTION_SW = 3;\n\nconst { ArrayBuffer, Atomics: $Atomics, Promise } = globalThis;\nconst { isArray } = Array;\nconst { create, getPrototypeOf, values } = Object;\n\nconst TypedArray = getPrototypeOf(Int32Array);\nconst Atomics = /** @type {globalThis.Atomics} */(create($Atomics));\n\nconst dispatch = ({ currentTarget, type, origin, lastEventId, source, ports }, data) =>\n  currentTarget.dispatchEvent(new MessageEvent(type, { data, origin, lastEventId, source, ports }));\n\nconst withResolvers = () => Promise.withResolvers();\n\nlet id = 0;\nconst views = new Map;\nconst extend = (Class, SharedArrayBuffer) => class extends Class {\n  constructor(value, ...rest) {\n    super(value, ...rest);\n    if (value instanceof SharedArrayBuffer)\n      views.set(this, [id++, 0, withResolvers()]);\n  }\n};\n\nconst ignoreList = new WeakSet;\n\n/**\n * @template {T}\n * @callback PassThrough\n * @param {T} value\n * @returns {T}\n */\n\n/** @type {PassThrough} */\nconst ignoreDirect = value => value;\n\n/** @type {PassThrough} */\nconst ignorePatch = value => {\n  ignoreList.add(value);\n  return value;\n};\n\nconst isChannel = (event, channel) => {\n  const { data } = event;\n  const yes = isArray(data) && (\n    data.at(0) === channel ||\n    (data.at(1) === ACTION_INIT && !channel)\n  );\n  if (yes) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  }\n  return yes;\n};\n\nconst isObject = value => (\n  value !== null &&\n  typeof value === 'object' &&\n  !ignoreList.has(value)\n);\n\nconst transferred = new WeakMap;\nconst transferViews = (data, transfer, visited) => {\n  if (views.has(data))\n    transfer.set(data, views.get(data)[0]);\n  else if (!(data instanceof TypedArray || data instanceof ArrayBuffer)) {\n    for (const value of values(data)) {\n      if (isObject(value) && !visited.has(value)) {\n        visited.add(value);\n        transferViews(value, transfer, visited);\n      }\n    }\n  }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/waitAsync#browser_compatibility\nlet intAsyncPatch = 0;\nconst waitAsyncPatch = (...args) => ({\n  value: new Promise(async resolve => {\n    // fallback to a local file to avoid CSP issues\n    // this file must contain: onmessage=e=>postMessage(!Atomics.wait(...e.data))\n    const url = '/__sabayon_wait_async.js';\n    const data = 'data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))';\n    // perform this check only once\n    if (!intAsyncPatch) {\n      const ok = fetch(url, { method: 'HEAD' }).then(r => r.ok, () => false);\n      intAsyncPatch = (await ok) ? 1 : -1;\n    }\n    const worker = new Worker(intAsyncPatch < 0 ? data : url);\n    worker.onmessage = () => {\n      worker.terminate();\n      resolve('ok');\n    };\n    worker.postMessage(args);\n  })\n});\n\nconst waitAsyncPoly = (view, index) => {\n  const value = views.get(view), [id, _, { promise }] = value;\n  value[1] = index;\n  return [id, promise];\n};\n\nconst actionNotify = (_view, _id, _index) => {\n  for (const [view, [id, index, { resolve }]] of views) {\n    if (_id === id && _index === index) {\n      view.set(_view);\n      views.delete(view);\n      resolve('ok');\n      break;\n    }\n  }\n};\n\nconst actionWait = (event, transfer, data) => {\n  for (const [view, id] of transfer)\n    transferred.set(view, [id, event.currentTarget]);\n  dispatch(event, data);\n};\n\nconst postData = (CHANNEL, data) => {\n  const transfer = new Map;\n  if (isObject(data)) transferViews(data, transfer, new Set);\n  return transfer.size ? [CHANNEL, ACTION_WAIT, transfer, data] : data;\n};\n\nconst getData = view => transferred.get(view);\n\nexport {\n  ACTION_INIT, ACTION_NOTIFY, ACTION_WAIT, ACTION_SW,\n\n  ArrayBuffer, Atomics, TypedArray,\n\n  actionNotify, actionWait,\n  getData, postData,\n  ignoreDirect, ignorePatch,\n  waitAsyncPatch, waitAsyncPoly,\n\n  dispatch,\n  extend,\n  isChannel,\n  views,\n  withResolvers,\n};\n","const { assign } = Object;\n\nconst STORAGE = 'entries';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\n/**\n * @typedef {Object} IDBMapOptions\n * @prop {'strict' | 'relaxed' | 'default'} [durability]\n * @prop {string} [prefix]\n */\n\n/** @typedef {[IDBValidKey, unknown]} IDBMapEntry */\n\n/** @type {IDBMapOptions} */\nconst defaultOptions = { durability: 'default', prefix: 'IDBMap' };\n\n/**\n * @template T\n * @param {{ target: IDBRequest<T> }} event\n * @returns {T}\n */\nconst result = ({ target: { result } }) => result;\n\nexport default class IDBMap extends EventTarget {\n  // Privates\n  /** @type {Promise<IDBDatabase>} */ #db;\n  /** @type {IDBMapOptions} */ #options;\n  /** @type {string} */ #prefix;\n\n  /**\n   * @template T\n   * @param {(store: IDBObjectStore) => IDBRequest<T>} what\n   * @param {'readonly' | 'readwrite'} how\n   * @returns {Promise<T>}\n   */\n  async #transaction(what, how) {\n    const db = await this.#db;\n    const t = db.transaction(STORAGE, how, this.#options);\n    return new Promise((onsuccess, onerror) => assign(\n      what(t.objectStore(STORAGE)),\n      {\n        onsuccess,\n        onerror,\n      }\n    ));\n  }\n\n  /**\n   * @param {string} name\n   * @param {IDBMapOptions} options\n   */\n  constructor(\n    name,\n    {\n      durability = defaultOptions.durability,\n      prefix = defaultOptions.prefix,\n    } = defaultOptions\n  ) {\n    super();\n    this.#prefix = prefix;\n    this.#options = { durability };\n    this.#db = new Promise((resolve, reject) => {\n      assign(\n        indexedDB.open(`${this.#prefix}/${name}`),\n        {\n          onupgradeneeded({ target: { result, transaction } }) {\n            if (!result.objectStoreNames.length)\n              result.createObjectStore(STORAGE);\n            transaction.oncomplete = () => resolve(result);\n          },\n          onsuccess(event) {\n            resolve(result(event));\n          },\n          onerror(event) {\n            reject(event);\n            this.dispatchEvent(event);\n          },\n        },\n      );\n    }).then(result => {\n      const boundDispatch = this.dispatchEvent.bind(this);\n      for (const key in result) {\n        if (key.startsWith('on'))\n          result[key] = boundDispatch;\n      }\n      return result;\n    });\n  }\n\n  // EventTarget Forwards\n  /**\n   * @param {Event} event\n   * @returns \n   */\n  dispatchEvent(event) {\n    const { type, message, isTrusted } = event;\n    return super.dispatchEvent(\n      // avoid re-dispatching of the same event\n      isTrusted ?\n        assign(new Event(type), { message }) :\n        event\n    );\n  }\n\n  // IDBDatabase Forwards\n  async close() {\n    (await this.#db).close();\n  }\n\n  // Map async API\n  get size() {\n    return this.#transaction(\n      store => store.count(),\n      READONLY,\n    ).then(result);\n  }\n\n  async clear() {\n    await this.#transaction(\n      store => store.clear(),\n      READWRITE,\n    );\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   */\n  async delete(key) {\n    await this.#transaction(\n      store => store.delete(key),\n      READWRITE,\n    );\n  }\n\n  /**\n   * @returns {Promise<IDBMapEntry[]>}\n   */\n  async entries() {\n    const keys = await this.keys();\n    return Promise.all(keys.map(key => this.get(key).then(value => [key, value])));\n  }\n\n  /**\n   * @param {(unknown, IDBValidKey, IDBMap) => void} callback\n   * @param {unknown} [context]\n   */\n  async forEach(callback, context = this) {\n    for (const [key, value] of await this.entries())\n      await callback.call(context, value, key, this);\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   * @returns {Promise<unknown | undefined>}\n   */\n  async get(key) {\n    const value = await this.#transaction(\n      store => store.get(key),\n      READONLY,\n    ).then(result);\n    return value;\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   */\n  async has(key) {\n    const k = await this.#transaction(\n      store => store.getKey(key),\n      READONLY,\n    ).then(result);\n    return k !== void 0;\n  }\n\n  async keys() {\n    const keys = await this.#transaction(\n      store => store.getAllKeys(),\n      READONLY,\n    ).then(result);\n    return keys;\n  }\n\n  /**\n   * @param {IDBValidKey} key\n   * @param {unknown} value\n   */\n  async set(key, value) {\n    await this.#transaction(\n      store => store.put(value, key),\n      READWRITE,\n    );\n    return this;\n  }\n\n  async values() {\n    const keys = await this.keys();\n    return Promise.all(keys.map(key => this.get(key)));\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.#prefix;\n  }\n}\n","import IDBMap from './index.js';\n\nexport default class IDBMapSync extends Map {\n  #map;\n  #queue;\n  constructor(...args) {\n    super();\n    this.#map = new IDBMap(...args);\n    this.#queue = this.#map.entries().then(entries => {\n      for (const [key, value] of entries)\n        super.set(key, value);\n    });\n  }\n  async close() {\n    await this.#queue;\n    await this.#map.close();\n  }\n  async sync() {\n    await this.#queue;\n  }\n  clear() {\n    this.#queue = this.#queue.then(() => this.#map.clear());\n    return super.clear();\n  }\n  delete(key) {\n    this.#queue = this.#queue.then(() => this.#map.delete(key));\n    return super.delete(key);\n  }\n  set(key, value) {\n    this.#queue = this.#queue.then(() => this.#map.set(key, value));\n    return super.set(key, value);\n  }\n}\n","/// <reference types=\"../types/index.d.ts\" />\n\n// (c) 2020-present Andrea Giammarchi\n\nconst {parse: $parse, stringify: $stringify} = JSON;\nconst {keys} = Object;\n\nconst Primitive = String;   // it could be Number\nconst primitive = 'string'; // it could be 'number'\n\nconst ignore = {};\nconst object = 'object';\n\nconst noop = (_, value) => value;\n\nconst primitives = value => (\n  value instanceof Primitive ? Primitive(value) : value\n);\n\nconst Primitives = (_, value) => (\n  typeof value === primitive ? new Primitive(value) : value\n);\n\nconst revive = (input, parsed, output, $) => {\n  const lazy = [];\n  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {\n    const k = ke[y];\n    const value = output[k];\n    if (value instanceof Primitive) {\n      const tmp = input[value];\n      if (typeof tmp === object && !parsed.has(tmp)) {\n        parsed.add(tmp);\n        output[k] = ignore;\n        lazy.push({k, a: [input, parsed, tmp, $]});\n      }\n      else\n        output[k] = $.call(output, k, tmp);\n    }\n    else if (output[k] !== ignore)\n      output[k] = $.call(output, k, value);\n  }\n  for (let {length} = lazy, i = 0; i < length; i++) {\n    const {k, a} = lazy[i];\n    output[k] = $.call(output, k, revive.apply(null, a));\n  }\n  return output;\n};\n\nconst set = (known, input, value) => {\n  const index = Primitive(input.push(value) - 1);\n  known.set(value, index);\n  return index;\n};\n\n/**\n * Converts a specialized flatted string into a JS value.\n * @param {string} text\n * @param {(this: any, key: string, value: any) => any} [reviver]\n * @returns {any}\n */\nexport const parse = (text, reviver) => {\n  const input = $parse(text, Primitives).map(primitives);\n  const value = input[0];\n  const $ = reviver || noop;\n  const tmp = typeof value === object && value ?\n              revive(input, new Set, value, $) :\n              value;\n  return $.call({'': tmp}, '', tmp);\n};\n\n/**\n * Converts a JS value into a specialized flatted string.\n * @param {any} value\n * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]\n * @param {string | number | undefined} [space]\n * @returns {string}\n */\nexport const stringify = (value, replacer, space) => {\n  const $ = replacer && typeof replacer === object ?\n            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :\n            (replacer || noop);\n  const known = new Map;\n  const input = [];\n  const output = [];\n  let i = +set(known, input, $.call({'': value}, '', value));\n  let firstRun = !i;\n  while (i < input.length) {\n    firstRun = true;\n    output[i] = $stringify(input[i++], replace, space);\n  }\n  return '[' + output.join(',') + ']';\n  function replace(key, value) {\n    if (firstRun) {\n      firstRun = !firstRun;\n      return value;\n    }\n    const after = $.call(this, key, value);\n    switch (typeof after) {\n      case object:\n        if (after === null) return after;\n      case primitive:\n        return known.get(after) || set(known, input, after);\n    }\n    return after;\n  }\n};\n\n/**\n * Converts a generic value into a JSON serializable object without losing recursion.\n * @param {any} value\n * @returns {any}\n */\nexport const toJSON = value => $parse(stringify(value));\n\n/**\n * Converts a previously serialized object with recursion into a recursive one.\n * @param {any} value\n * @returns {any}\n */\nexport const fromJSON = value => parse($stringify(value));\n","import { ArrayBuffer, TypedArray } from \"sabayon/shared\";\nimport IDBMapSync from \"@webreflection/idb-map/sync\";\nimport { parse, stringify } from \"flatted\";\n\nconst to_idb = (value) => {\n    if (value == null) return stringify([\"null\", 0]);\n    /* eslint-disable no-fallthrough */\n    switch (typeof value) {\n        case \"object\": {\n            if (value instanceof TypedArray)\n                return stringify([\"memoryview\", [...value]]);\n            if (value instanceof ArrayBuffer)\n                return stringify([\"bytearray\", [...new Uint8Array(value)]]);\n        }\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return stringify([\"generic\", value]);\n        default:\n            throw new TypeError(`Unexpected value: ${String(value)}`);\n    }\n};\n\nconst from_idb = (value) => {\n    const [kind, result] = parse(value);\n    if (kind === \"null\") return null;\n    if (kind === \"generic\") return result;\n    if (kind === \"bytearray\") return new Uint8Array(value).buffer;\n    if (kind === \"memoryview\") return new Uint8Array(value);\n    return value;\n};\n\n// this export simulate pyscript.storage exposed in the Python world\nexport const storage = async (name) => {\n    if (!name) throw new SyntaxError(\"The storage name must be defined\");\n\n    const store = new IDBMapSync(`@pyscript/${name}`);\n    const map = new Map();\n    await store.sync();\n    for (const [k, v] of store.entries()) map.set(k, from_idb(v));\n\n    const clear = () => {\n        map.clear();\n        store.clear();\n    };\n\n    const sync = async () => {\n        await store.sync();\n    };\n\n    return new Proxy(map, {\n        ownKeys: (map) => [...map.keys()],\n        has: (map, name) => map.has(name),\n        get: (map, name) => {\n            if (name === \"clear\") return clear;\n            if (name === \"sync\") return sync;\n            return map.get(name);\n        },\n        set: (map, name, value) => {\n            map.set(name, value);\n            store.set(name, to_idb(value));\n            return true;\n        },\n        deleteProperty: (map, name) => {\n            if (map.has(name)) {\n                map.delete(name);\n                store.delete(name);\n            }\n            return true;\n        },\n    });\n};\n"],"names":["ArrayBuffer","globalThis","getPrototypeOf","Object","TypedArray","Int32Array","assign","STORAGE","READONLY","READWRITE","defaultOptions","durability","prefix","result","target","IDBMap","EventTarget","db","options","transaction","what","how","t","this","Promise","onsuccess","onerror","objectStore","constructor","name","super","resolve","reject","indexedDB","open","onupgradeneeded","objectStoreNames","length","createObjectStore","oncomplete","event","dispatchEvent","then","boundDispatch","bind","key","startsWith","type","message","isTrusted","Event","close","size","store","count","clear","delete","entries","keys","all","map","get","value","forEach","callback","context","call","has","undefined","getKey","getAllKeys","set","put","values","Symbol","toStringTag","IDBMapSync","Map","queue","args","sync","parse","$parse","stringify","$stringify","JSON","Primitive","String","primitive","ignore","object","noop","_","primitives","Primitives","revive","input","parsed","output","$","lazy","ke","y","k","tmp","add","push","a","i","apply","known","index","replacer","space","firstRun","replace","join","after","from_idb","kind","text","Set","Uint8Array","buffer","storage","async","SyntaxError","v","Proxy","ownKeys","TypeError","to_idb","deleteProperty"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}