# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: data.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import executed_tests as _executed_tests__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class SmeltErrorType(betterproto.Enum):
    CLIENT_ERROR = 0
    """Client caused error"""

    INTERNAL_ERROR = 1
    """Internal error -- anything that is thrown by the smelt runtime"""

    INTERNAL_WARN = 2
    """
    Internal warning -- anything that the smelt runtime wants to broadcast back
    """


@dataclass(eq=False, repr=False)
class Event(betterproto.Message):
    """Event flows from server -> client only"""

    time: datetime = betterproto.message_field(1)
    trace_id: str = betterproto.string_field(2)
    """A globally-unique ID (UUIDv4) of this trace. Required."""

    command: "CommandEvent" = betterproto.message_field(15, group="et")
    invoke: "InvokeEvent" = betterproto.message_field(16, group="et")
    error: "SmeltError" = betterproto.message_field(17, group="et")


@dataclass(eq=False, repr=False)
class CommandEvent(betterproto.Message):
    """CommandEvents covers activity happening on a per target basis"""

    command_ref: str = betterproto.string_field(1)
    """
    test def id this ref should be consistent for the same test being executed
    """

    scheduled: "CommandScheduled" = betterproto.message_field(4, group="CommandVariant")
    started: "CommandStarted" = betterproto.message_field(5, group="CommandVariant")
    cancelled: "CommandCancelled" = betterproto.message_field(6, group="CommandVariant")
    finished: "CommandFinished" = betterproto.message_field(7, group="CommandVariant")
    stdout: "CommandStdout" = betterproto.message_field(8, group="CommandVariant")
    profile: "CommandProfile" = betterproto.message_field(9, group="CommandVariant")
    skipped: "CommandSkipped" = betterproto.message_field(10, group="CommandVariant")


@dataclass(eq=False, repr=False)
class CommandScheduled(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CommandStarted(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CommandCancelled(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CommandSkipped(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CommandStdout(betterproto.Message):
    output: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class CommandFinished(betterproto.Message):
    outputs: "_executed_tests__.TestOutputs" = betterproto.message_field(1)
    command_type: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class CommandProfile(betterproto.Message):
    memory_used: int = betterproto.uint64_field(1)
    """memory used by the command, in bytes"""

    cpu_load: float = betterproto.float_field(2)
    """cpu load as a fraction -- 1.0 is one cpu, 2.0 is 2 cpus, etc"""

    time_since_start_ms: int = betterproto.uint64_field(3)
    """Number of milliseconds since profiling began"""


@dataclass(eq=False, repr=False)
class InvokeEvent(betterproto.Message):
    """InvokeEvent demarcates the start of a graph execution."""

    start: "ExecutionStart" = betterproto.message_field(5, group="InvokeVariant")
    done: "AllCommandsDone" = betterproto.message_field(6, group="InvokeVariant")
    set: "SetGraph" = betterproto.message_field(7, group="InvokeVariant")


@dataclass(eq=False, repr=False)
class ExecutionStart(betterproto.Message):
    smelt_root: str = betterproto.string_field(1)
    username: str = betterproto.string_field(2)
    hostname: str = betterproto.string_field(3)
    git_hash: str = betterproto.string_field(4)
    git_repo: str = betterproto.string_field(5)
    git_branch: str = betterproto.string_field(6)


@dataclass(eq=False, repr=False)
class AllCommandsDone(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SetGraph(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class SmeltError(betterproto.Message):
    sig: "SmeltErrorType" = betterproto.enum_field(1)
    error_payload: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class TaggedResult(betterproto.Message):
    trace_id: str = betterproto.string_field(1)
    results: "_executed_tests__.TestResult" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ExecutionSubscribe(betterproto.Message):
    trace_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ExecutionFinish(betterproto.Message):
    trace_id: str = betterproto.string_field(1)


class EventListenerStub(betterproto.ServiceStub):
    async def send_event(
        self,
        event: "Event",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/smelt_telemetry.EventListener/SendEvent",
            event,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_outputs(
        self,
        tagged_result: "TaggedResult",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/smelt_telemetry.EventListener/SendOutputs",
            tagged_result,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class EventSubscriberStub(betterproto.ServiceStub):
    async def subscribe_received_events(
        self,
        execution_subscribe: "ExecutionSubscribe",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["Event"]:
        async for response in self._unary_stream(
            "/smelt_telemetry.EventSubscriber/SubscribeReceivedEvents",
            execution_subscribe,
            Event,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscription_complete(
        self,
        execution_finish: "ExecutionFinish",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        return await self._unary_unary(
            "/smelt_telemetry.EventSubscriber/SubscriptionComplete",
            execution_finish,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class EventListenerBase(ServiceBase):

    async def send_event(
        self, event: "Event"
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_outputs(
        self, tagged_result: "TaggedResult"
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_send_event(
        self,
        stream: "grpclib.server.Stream[Event, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_event(request)
        await stream.send_message(response)

    async def __rpc_send_outputs(
        self,
        stream: "grpclib.server.Stream[TaggedResult, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_outputs(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/smelt_telemetry.EventListener/SendEvent": grpclib.const.Handler(
                self.__rpc_send_event,
                grpclib.const.Cardinality.UNARY_UNARY,
                Event,
                betterproto_lib_google_protobuf.Empty,
            ),
            "/smelt_telemetry.EventListener/SendOutputs": grpclib.const.Handler(
                self.__rpc_send_outputs,
                grpclib.const.Cardinality.UNARY_UNARY,
                TaggedResult,
                betterproto_lib_google_protobuf.Empty,
            ),
        }


class EventSubscriberBase(ServiceBase):

    async def subscribe_received_events(
        self, execution_subscribe: "ExecutionSubscribe"
    ) -> AsyncIterator["Event"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield Event()

    async def subscription_complete(
        self, execution_finish: "ExecutionFinish"
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_subscribe_received_events(
        self, stream: "grpclib.server.Stream[ExecutionSubscribe, Event]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_received_events,
            stream,
            request,
        )

    async def __rpc_subscription_complete(
        self,
        stream: "grpclib.server.Stream[ExecutionFinish, betterproto_lib_google_protobuf.Empty]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.subscription_complete(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/smelt_telemetry.EventSubscriber/SubscribeReceivedEvents": grpclib.const.Handler(
                self.__rpc_subscribe_received_events,
                grpclib.const.Cardinality.UNARY_STREAM,
                ExecutionSubscribe,
                Event,
            ),
            "/smelt_telemetry.EventSubscriber/SubscriptionComplete": grpclib.const.Handler(
                self.__rpc_subscription_complete,
                grpclib.const.Cardinality.UNARY_UNARY,
                ExecutionFinish,
                betterproto_lib_google_protobuf.Empty,
            ),
        }
