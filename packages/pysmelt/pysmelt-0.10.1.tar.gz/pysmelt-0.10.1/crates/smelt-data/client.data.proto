syntax = "proto3";

package smelt_client.commands;
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

message ClientCommand {
  oneof ClientCommands {
    SetCommands setter = 1;
    RunOne runone = 2;
    RunType runtype = 3;
    RunMany runmany = 4;
    GetConfig getcfg = 5;
    GetCommands getcmds = 6;
  }
}

message SetCommands { string command_content = 1; string maybe_def_path = 2;}
message RunOne { string command_name = 1; }
message RunMany { repeated string command_names = 1; }

message GetCommands {}
message RunType {
  // Eventually, perhaps we should encode this as info in protobuf
  // not today babey
  string typeinfo = 1;
}
message GetConfig {};

// Responses to the client commands
message ClientResp {
  oneof ClientResponses { 
    ConfigureSmelt current_cfg = 1; 
    SerializedCommandGraph json_cmd_list= 2;
    }
}

message SerializedCommandGraph {
  // Just a list of Commands, serialized as json 
  string json_graph_content = 1;
}

// This configuration is done once, when SMELT is initialized
// The client should provide this when creating an smelt handle
message ConfigureSmelt {
  // Should be an absolute path
  string smelt_root = 1;
  // number of slots the entire executor has -- analogous to job slots in make
  uint64 job_slots = 2;
  // configures how we profile commands
  ProfilerCfg prof_cfg = 3;
  // If true, we ignore the non test commands
  bool test_only = 4;
  // If true, we do not transmit stdout from the server
  bool silent = 5;
  // if true, smelt execution will prepare the workspace to run tests in another stage
  // this is useful for splitting the work between a build and test stage
  bool prepare_workspace = 6;
  // if true, all commands will have their environment variables sandboxed 
  bool sandbox_env= 7;
  oneof InitExecutor {
    CfgLocal local = 10;
    CfgDocker docker = 11;
    CfgSlurm slurm = 12;
  }
}

message ProfilerCfg {
  // if we enable simple profiling
  ProfilingSelection prof_type = 1;
  uint64 sampling_period = 2;
}
enum ProfilingSelection {
  DISABLED = 0;
  // only memory and cpu
  SIMPLE_PROF = 1;
}

message CfgLocal {}
message CfgSlurm {
  AwsCreds creds = 1;
  ServerInfo maybe_info = 2;
  
  oneof SealedWorkspace {
    bool none = 10;
    DockerWorkspace dockerws = 11;
  } 
  
}


// Populate info for the slurm server
// 
// This is configured from the end-user side. 
// if these data is not provided, then smelt will execute `whoami` to derive hostname and will let the OS select the port
message ServerInfo {
  // this is the hostname used by smelt and all workers, by default
  string hostname = 1;
  // This is port supplied to each worker a. Sometimes you'll have a proxy in front of your smelt server to make deployment easier. e.g. 
  // this is practical for  deploying in non-LAN networking environments
  uint32 port = 2;
}


// credentials required to create an S3 Client and upload artifacts to it 
message AwsCreds {
    string key_id = 1;
    string key = 2;
    string bucket = 3;
    string key_base_path = 4;
}


message DockerWorkspace {
  string container_name = 1;
  string workspace_smelt_root = 2;
  repeated string docker_args = 3;
}




// Clone of Bollard proto message Ulimit
message Ulimit {
  optional string name = 1;
  optional int64 soft = 2;
  optional int64 hard = 3;
}

enum RunMode {
  Local = 0;
  Remote = 1;
}

message CfgDocker {
  string image_name = 1;
  map<string, string> additional_mounts = 2;
  repeated Ulimit ulimits = 3;
  optional string mac_address = 4;
  RunMode run_mode = 5;
  string artifact_bind_directory = 6;
}
