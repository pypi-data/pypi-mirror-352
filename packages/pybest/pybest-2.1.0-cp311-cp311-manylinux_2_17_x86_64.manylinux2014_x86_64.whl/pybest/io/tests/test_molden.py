# PyBEST: Pythonic Black-box Electronic Structure Tool
# Copyright (C) 2016-- The PyBEST Development Team
#
# This file is part of PyBEST.
#
# PyBEST is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# PyBEST is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>
# --


from pathlib import Path

import numpy as np
import pytest

from pybest import context, filemanager, periodic
from pybest.exceptions import ArgumentError
from pybest.gbasis import compute_overlap
from pybest.io.molden import dump_molden
from pybest.io.tests.common import Molecule, compute_mulliken_charges
from pybest.iodata import IOData
from pybest.linalg import DenseLinalgFactory
from pybest.scf.utils import compute_1dm_hf

test_load_molden = [
    (
        "li2.molden.input",
        {
            "title": "Molden file created by orca_2mkl for BaseName=li2",
            "charges": np.array([0.5, 0.5]),
        },
    ),
    (
        "h2o.molden.input",
        {
            "title": "Molden file created by orca_2mkl for BaseName=h2o",
            "charges": np.array([-0.816308, 0.408154, 0.408154]),
        },
    ),
    (
        "nh3_orca.molden",
        {
            "title": "Molden file created by orca_2mkl for BaseName=test",
            "charges": np.array([0.0380120, -0.2742807, 0.0120608, 0.2242079]),
        },
    ),
    (
        "nh3_psi4.molden",
        {
            "charges": np.array([0.0380120, -0.2742807, 0.0120608, 0.2242079]),
        },
    ),
    (
        "nh3_molpro2012.molden",
        {
            "title": "This title was manually added for the tests",
            "charges": np.array([0.0380120, -0.2742807, 0.0120608, 0.2242079]),
        },
    ),
]


def read_and_check_molden_files(fn_molden, expected):
    """Reads a molden file from fn_molden and checks if file contents agrees
    with reference values taken from expected (dict)."""
    mol = IOData.from_file(fn_molden)

    # Check title if present
    try:
        assert mol.title == expected["title"], "wrong title in molden file"
    except AttributeError:
        pass

    # Check normalization
    olp = compute_overlap(mol.basis)
    mol.orb_a.check_normalization(olp, 1e-4)
    try:
        mol.orb_b.check_normalization(olp, 1e-4)
    except AttributeError:
        pass

    # Check Mulliken charges
    numbers = np.array([periodic[i].number for i in mol.atom])
    dm_full = compute_1dm_hf(mol.orb_a)
    try:
        dm_full.iadd(compute_1dm_hf(mol.orb_b))
    except AttributeError:
        dm_full.iscale(2.0)

    lf = DenseLinalgFactory(mol.basis)
    charges = compute_mulliken_charges(mol.basis, lf, numbers, dm_full)

    assert (
        abs(charges - expected["charges"]).max() < 1e-5
    ), "wrong charges in molden file"

    return mol, charges


@pytest.mark.parametrize("fn,expected", test_load_molden)
def test_load_molden_files(fn, expected):
    """Test molden file reader for molden files generated by various QC
    programs (like PSI4, ORCA, etc.). All files should be read in properly by
    altering normalization conventions."""
    fn_molden = context.get_fn(f"test/{fn}")
    read_and_check_molden_files(fn_molden, expected)


test_load_dump_molden = [
    (
        "nh3_molden_pure.molden",
        {
            "title": "This title was manually added for the tests",
            "charges": np.array([0.0380613, -0.274243, 0.012071, 0.224221]),
        },
    ),
    (
        "nh3_molden_cart.molden",
        {
            "title": "This title was manually added for the tests",
            "charges": np.array([0.313801, -0.429974, -0.066706, 0.182856]),
        },
    ),
]


@pytest.mark.parametrize("fn,expected", test_load_dump_molden)
def test_load_dump_molden_files(fn, expected):
    """First read, and then dump a molden file. Check if they are the same."""
    fn_molden = context.get_fn(f"test/{fn}")
    mol, charges = read_and_check_molden_files(fn_molden, expected)

    # dump molden file it
    fn = f"{filemanager.temp_dir}/tmp.molden"
    dump_molden(fn, mol)

    # read the dump file again
    mol2 = IOData.from_file(fn)
    assert mol.basis.basisname == mol2.basis.basisname
    assert mol.basis.alpha == mol2.basis.alpha
    assert mol.basis.contraction == mol2.basis.contraction
    assert mol.basis.nbasis == mol2.basis.nbasis
    assert mol.basis.nprim == mol2.basis.nprim
    assert mol.basis.nshell == mol2.basis.nshell
    assert mol.basis.ncenter == mol2.basis.ncenter
    assert mol.basis.shell2atom == mol2.basis.shell2atom
    assert mol.basis.shell_types == mol2.basis.shell_types
    assert mol.basis.atom == mol2.basis.atom
    assert mol.basis.ncenter == mol2.basis.ncenter
    assert (
        abs(np.array(mol.basis.coordinates) - np.array(mol2.basis.coordinates))
        < 1e-8
    ).all()
    assert abs(charges - expected["charges"]).max() < 1e-3


test_mol = [
    ("h2o", "cc-pvdz", ("orb_a", "occ_model"), {}),
    ("h2o", "cc-pvdz", ("orb_a", "orb_b", "occ_model"), {}),
    ("h2o", "cc-pvdz", ("orb_a", "occ_model", "basis"), {}),
    ("h2o", "cc-pvdz", ("orb_a",), {"basis": None}),
    ("h2o", "cc-pvdz", ("orb_a",), {"occ_model": None}),
]


# We do not need to test for Cholesky as it has no effect at all, but we do it
# for reasons of consistency


@pytest.mark.parametrize("mol,basis,args,kwargs", test_mol)
def test_dump_molden_iodata(mol, basis, args, kwargs, linalg):
    """Test dumping of molden files using various IOData containers"""
    # generate molecule
    mol_ = Molecule(mol, basis, linalg)
    # Add args and kwargs to iodata attribute
    mol_.iodata = args
    mol_.iodata = kwargs
    # Now dump
    fn = f"{filemanager.temp_dir}/tmp.molden"
    dump_molden(fn, mol_.iodata)

    assert Path(fn).exists()


test_mol_error = [
    ("h2o", "cc-pvdz", ("orb_a",), {}, ArgumentError),
    ("h2o", "cc-pvdz", (), {"orb_a": None}, ArgumentError),
    ("h2o", "cc-pvdz", ("occ_model",), {}, AttributeError),
    ("h2o", "cc-pvdz", (), {"occ_model": None}, AttributeError),
]


# We do not need to test for Cholesky as it has no effect at all, but we do it
# for reasons of consistency
@pytest.mark.parametrize("mol,basis,args,kwargs,error", test_mol_error)
def test_dump_molden_error(mol, basis, args, kwargs, error, linalg):
    """Test dumping of molden files using incomplete IOData containers. An
    error should be raised."""
    # generate molecule
    mol_ = Molecule(mol, basis, linalg)
    # Add args and kwargs to iodata attribute
    mol_.iodata = args
    mol_.iodata = kwargs
    # Now dump
    fn = f"{filemanager.temp_dir}/tmp.molden"
    with pytest.raises(error):
        dump_molden(fn, mol_.iodata)
