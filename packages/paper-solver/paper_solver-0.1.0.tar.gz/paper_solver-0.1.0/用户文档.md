# paper solver

## 介绍

面向造纸的信赖域求解器开发

## 多元标量函数的约束最小化

该函数提供约束最小化的算法，即 `trust-constr`。它们需要约束使用略有不同的结构进行定义。该方法需要 `x` 要定义为对象序列的约束，另一方面，`c` 要求将约束定义为一系列字典，其中包含键 `fun` 和 `jac`。

举个例子，让我们考虑 Rosenbrock 函数的约束最小化：

```markdown
minimize f(x0, x1): 100 * (x1 - x0**2)**2 + (1 - x0)**2
    subject to: 
        x0^2 + x1 <= 1
        x0^2 - x1 <= 1
        2x0 + x1 <= 1
        0 <= x0 <= 1
        -0.5 <= x1 <= 2.0
```

这个优化问题有唯一的解。 `[x_0, x_1] = [0.4149, 0.1701]`

## 信任区域约束算法

信任区域约束方法处理以下形式的约束最小化问题：

```python
minimize f(x):
    subject to: 
        c_l <= c(x) <= c_u
        x_l <= x <= x_u
```

当该方法将 `-th` 约束读取为相等约束并相应地处理它。除此之外，单方面约束可以通过使用适当的符号设置上限或下限来指定。

对于相等约束问题，该实现基于信赖域SQP算法，对于具有不等约束的问题，基于信赖域内点法。两者都是适合的信任区域类型算法对于大规模问题。

### 定义边界约束

绑定约束 `x_l` 和 `x_u` 是使用对象定义的。

```
0 <= x0 <= 1
-0.5 <= x1 <= 2.0
```

```python
from paper_solver import BoxConstraint
box = BoxConstraint(("interval", (0,-0.5),(1,2)))
```

### 定义线性约束

约束条件可以用线性约束标准格式编写：

```python
2x0 + x1 <= 1
Ax <= b
```

并使用对象定义。

```python
from paper_solver import LinearConstraint
linear_constraint = LinearConstraint([[2,1]], ('less', 1))
```

### 定义非线性约束

非线性约束：

```
x0^2 + x1 <= 1
x0^2 - x1 <= 1
```

```python
def constraint_function(x):
    return np.array([
        x[0]**2 + x[1] - 1,  # 第一个约束
        x[0]**2 - x[1] - 1   # 第二个约束
    ])
```

使用雅可比矩阵：

```python
def jac_constraint_function(x):
    return np.array([
        [2*x[0], 1],   # 第一个约束的雅可比矩阵
        [2*x[0], -1]   # 第二个约束的雅可比矩阵
    ])
```

黑森矩阵的线性组合：

```python
def hess_constraint_function(x, v):
    return v[0]*np.array([[2, 0], [0, 0]]) + v[1]*np.array([[2, 0], [0, 0]])
```

使用对象定义。

```python
# 定义约束函数
def constraint_function(x):
    return np.array([
        x[0]**2 + x[1] - 1,  # 第一个约束
        x[0]**2 - x[1] - 1   # 第二个约束
    ])

# 定义雅可比矩阵函数
def jac_constraint_function(x):
    return np.array([
        [2*x[0], 1],   # 第一个约束的雅可比矩阵
        [2*x[0], -1]   # 第二个约束的雅可比矩阵
    ])
# hess矩阵函数
def hess_constraint_function(x, v):
    return v[0]*np.array([[2, 0], [0, 0]]) + v[1]*np.array([[2, 0], [0, 0]])
    
nonlinear_constraint = NonlinearConstraint(constraint_function, ('less', 0), jac=jac_constraint_function, hess=hess_constraint_function)

```

当 Hessian 的评估难以实现或计算不可行时，可以使用计算 Hessian 矩阵的方法。. 目前可用的策略是 2-point,cs` 和 `3-point。关键字选择一个数值估计的有限差分方案。方案 '3-point' 更精确，但是与 '2-point'（默认）相比需要两倍的操作。方案 'cs' 使用复步进，虽然可能最准确，但仅当 `fun` 正确处理复数输入并且可以解析地延拓到复平面时才适用。

```python
nonlinear_constraint nonlinear_constraint = NonlinearConstraint(constraint_function, ('less', 0), jac=jac_constraint_function, hess='3-point')
```

## 求解优化问题

优化问题通过以下方法求解：

```python
x0 = [0,1]

result = minimize_constrained(fun, x0, grad, constraints=(nonlinear_constraint, box, linear_constraint))

print(result.x)
[0.41494423 0.1701113 ]

```

以上示例完整代码在test文件内的test_constr。

## 参考                                         

  Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999. An interior point algorithm for large-scale nonlinear programming. SIAM Journal on Optimization 9.4: 877-900.
  
  Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998. On the implementation of an algorithm for large-scale equality constrained optimization. SIAM Journal on Optimization 8.3: 682-706.

## 

## API文档

### ``minimize_constrained``

```
minimize_constrained(fun, x0, grad, hess='2-point', constraints=(),
                         method=None, xtol=1e-8, gtol=1e-8, sparse_jacobian=None,
                         options={}, callback=None, max_iter=1000, verbose=0):
    """
    最小化受约束的标量函数。

    参数
    ----------
    fun : 可调用对象
        要最小化的目标函数。

            fun(x) -> float

        其中 x 是形状为 (n,) 的数组。
    x0 : ndarray, 形状为 (n,)
        初始猜测。大小为 (n,) 的实元素数组，
        其中 ``n`` 是独立变量的数量。
    grad : 可调用对象
        目标函数的梯度：

            grad(x) -> array_like, 形状为 (n,)

        其中 x 是形状为 (n,) 的数组。
    hess : {callable, '2-point', '3-point', 'cs', None}, 可选
        计算 Hessian 矩阵的方法。
        选择用于数值估计的有限差分方案。
        方案 '3-point' 更准确，但需要
        比 '2-point' (默认) 多一倍的操作。该
        方案 'cs' 使用复步长，而且可能是最
        准确的，只有在 `fun` 正确处理时才能使用
        复输入并能被解析地延拓到复
        平面。如果它是可调用对象，则应返回
        `dot(fun, v)` 的 Hessian 矩阵：

            hess(x, v) -> {LinearOperator, sparse matrix, ndarray}, 形状为 (n, n)

        其中 x 是形状为 (n,) 的 ndarray，v 是形状为 (m,) 的 ndarray。当 ``hess``
        为 None 时，它将考虑 Hessian 为一个填满了零的矩阵。
    constraints : 约束或约束列表，可选
        指定优化问题约束的单个对象或对象列表。
        可用的约束有：

            - `BoxConstraint`
            - `LinearConstraint`
            - `NonlinearConstraint`

    method : {str, None}, 可选
        求解器的类型。应为以下之一：

            - 'equality-constrained-sqp'
            - 'tr-interior-point'

        当为 None 时，选择更合适的方法。
        'equality-constrained-sqp' 用于仅具有等式约束的问题，
        而 'tr-interior-point' 用于一般优化问题。
    xtol : float, 可选
        独立变量变化的终止容差。
        当 ``delta < xtol`` 时，算法将终止，其中 ``delta``
        是算法信任区域半径。默认值为 1e-8。
    gtol : float, 可选
        拉格朗日梯度范数的终止容差。
        当拉格朗日梯度的无穷范数（即最大
        绝对值）和约束违反都小于 ``gtol`` 时，
        算法将终止。默认值为 1e-8。
    sparse_jacobian : {bool, None}
        如果为 True，则算法使用 Jacobian 的稀疏表示，
        如果为 False，则使用密集表示。当 sparse_jacobian 为 None 时，
        算法使用更方便的选项，如果至少有一个约束 Jacobian 是稀疏的，
        则使用稀疏表示，否则使用密集表示。
    options : 字典，可选
        求解器选项的字典。可用选项包括：

            initial_trust_radius: float
                初始信任区域半径。默认使用 1.0，如
                [1]_ 建议的，p.19，在算法 III 之后。
            initial_penalty : float
                功能价值初始惩罚。默认使用 1.0，如
                [1]_ 建议的，p.19，在算法 III 之后。
            initial_barrier_parameter: float
                初始障碍参数。专属于 'tr_interior_point'
                方法。默认使用 0.1，如 [1]_ 建议的，
                在算法 III 之后，p. 19。
            initial_tolerance: float
                初始子问题容差。专属于
                'tr_interior_point' 方法。默认使用 0.1，
                如 [1]_ 建议的，在算法 III 之后，p. 19。
            return_all : bool, 可选
                当为 True 时返回所有向量
                经过迭代。
            factorization_method : string, 可选
                用于因子分解 Jacobian 矩阵的方法。
                应为以下之一：

                - 'NormalEquation': 运算符
                   将使用所谓的
                   正规方程方法进行计算
                   在 [1]_ 中解释。为了
                   这样做，计算 ``(A A.T)`` 的
                   Cholesky 因子分解。仅用于
                   稀疏矩阵。需要
                   安装 scikit-sparse。
                - 'AugmentedSystem': 运算符
                   将使用所谓的增广系统方法
                   在 [1]_ 中解释。它执行
                   增广的 LU 因子分解
                   系统。仅用于稀疏矩阵。
                - 'QRFactorization': 使用 QR 因子分解
                   计算投影。仅用于
                   密集矩阵。
                - 'SVDFactorization': 使用 SVD 因子分解
                   计算投影。仅用于
                   密集矩阵。

                方法 'NormalEquation' 和
                'AugmentedSystem' 应仅在
                ``sparse_jacobian=True`` 时使用。它们通常提供
                类似的结果。方法 'QRFactorization'
                和 'SVDFactorization' 应在
                ``sparse_jacobian=False`` 时使用。默认使用
                'QRFactorization' 用于密集矩阵。
                'SVDFactorization' 方法可以处理
                具有不完整行秩的雅可比矩阵，并且将在其他
                因子分解方法失败时使用（可能
                意味着转换为密集格式）。

    callback : 可调用对象，可选
        每次迭代后调用：

            callback(OptimizeResult state) -> bool

        如果回调返回 True，则算法执行将终止。
        ``state`` 是一个 `OptimizeResult` 对象，具有与返回值相同的字段。
    max_iter : int, 可选
        算法迭代的最大次数。默认为 ``max_iter=1000``
    verbose : {0, 1, 2}, 可选
        算法详细程度：

            * 0（默认）：静默工作。
            * 1：显示终止报告。
            * 2：在迭代过程中显示进度。

    返回
    -------
    `OptimizeResult`，其中定义了以下字段：
    x : ndarray, 形状为 (n,)
        找到的解决方案。
    s : ndarray, 形状为 (n_ineq,)
        解决方案的松弛变量。``n_ineq`` 是总数
        的不等式约束。
    v : ndarray, 形状为 (n_ineq + n_eq,)
        估计的拉格朗日乘子在解决方案处。``n_ineq + n_eq``
        是等式和不等式约束的总数。
    niter : int
        总迭代次数。
    nfev : int
        总目标函数评估次数。
    ngev : int
        总目标函数梯度评估次数。
    nhev : int
        拉格朗日 Hessian 评估的总次数。每次
        评估拉格朗日 Hessian 时，目标函数
        Hessian 和约束 Hessian 也会被评估
        一次。
    ncev : int
        约束评估的总次数。相同的计数器
        用于等式和不等式约束，因为它们总是
        被评估相同次数。
    njev : int
        约束雅可比矩阵评估的总次数。
        相同的计数器用于等式和不等式
        约束雅可比矩阵，因为它们总是
        被评估相同次数。
    cg_niter : int
        CG 迭代的总次数。
    cg_info : 字典
        包含有关最新 CG 迭代的信息的字典：

            - 'niter'：迭代次数。
            - 'stop_cond'：CG 子问题终止的原因：

                1. 达到迭代限制;
                2. 达到信任区域边界;
                3. 检测到负曲率;
                4. 满足了容差。

            - 'hits_boundary'：如果建议的步骤在信任区域的边界上，
              则为 True。

    execution_time : float
        总执行时间。
    trust_radius : float
        最后迭代时的信任半径。
    penalty : float
        最后一次迭代的惩罚函数。
    tolerance : float
        最后一次迭代时的障碍子问题容差。
        专属于 'tr_interior_point'。
    barrier_parameter : float
        最后一次迭代的障碍参数。专属于
        'tr_interior_point'。
    status : {0, 1, 2, 3}
        终止状态：

            * 0：超出最大函数评估次数。
            * 1：满足了 `gtol` 终止条件。
            * 2：满足了 `xtol` 终止条件。
            * 3：'callback' 函数请求终止。

    message : str
        终止消息。
    method : {'equality_constrained_sqp', 'tr_interior_point'}
        使用的优化方法。
    constr_violation : float
        最后一次迭代的约束违反。
    optimality : float
        最后一次迭代的拉格朗日梯度范数。
    fun : float
        对于 'equality_constrained_sqp' 方法，这是目标
        函数在解决方案处的值，对于 'tr_interior_point'
        方法，这是在解决方案处的障碍函数的值。
    grad : ndarray, 形状为 (n,)
        对于 'equality_constrained_sqp' 方法，这是目标函数在
        解决方案处的梯度，对于 'tr_interior_point'
        方法，这是在解决方案处的障碍函数的梯度。
    constr : ndarray, 形状为 (n_ineq + n_eq,)
        对于 'equality_constrained_sqp' 方法，这是在解决方案处
        的等式约束，对于 'tr_interior_point' 方法，
        这是在给定点处评估的等式和不等式约束
        （其中不等式约束增加了松弛变量的值）。
    jac : {ndarray, sparse matrix}, 形状为 (n_ineq + n_eq, n)
        对于 'equality_constrained_sqp' 方法，这是在解决方案处
        的等式约束的雅可比矩阵，对于 'tr_interior_point'
        方法，这是缩放的增广雅可比矩阵，
        定义为方程 (19.36) 中的 ``\hat(A)``，参考 [2]_,
        p. 581。

    注意
    -----
    方法 'equality_constrained_sqp' 是 Byrd-Omojokun
    信任区域 SQP 方法的实现，描述在 [3]_ 中
    和在 [2]_ 中，p. 549。它通过解决每个子步骤
    一个信任区域 QP 子问题来解决等式约束的优化问题。
    使用投影 CG 方法对这些 QP 问题的不精确解
    使得该方法适用于大规模问题。

    方法 'tr_interior_point' 是
    描述在 [1]_ 中的信任区域内点方法的实现。
    它通过引入松弛变量来解决一般的非线性问题
    并解决一系列逐渐减小障碍参数的等式约束问题
    的。使用前述的等式约束 SQP 方法来解决子问题
    随着迭代接近解决方案，准确性逐渐增加。
    对于大规模问题，这也是一种合适的方法。

    参考资料
    ----------
    .. [1] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal.
           "An interior point algorithm for large-scale nonlinear
           programming." SIAM Journal on Optimization 9.4 (1999): 877-900.
    .. [2] Nocedal, Jorge, and Stephen J. Wright. "Numerical optimization"
           Second Edition (2006).
    .. [3] Lalee, Marucha, Jorge Nocedal, and Todd Plantenga. "On the
           implementation of an algorithm for large-scale equality
           constrained optimization." SIAM Journal on
           Optimization 8.3 (1998): 682-706.
    """

```

### ``NonlinearConstraint``

```
NonlinearConstraint(fun, kind, jac, hess='2-point', enforce_feasibility=False)

   非线性约束

    参数
    ----------
    fun : callable
        定义约束的函数。

            fun(x) -> array_like, shape (m,)

        其中 x 是一个 (n,) 的 ndarray，``m``
        是约束的数量。
    kind : {str, tuple}
        指定约束的类型。此参数的选项为：

            - ('interval', lb, ub) 表示约束类型为：
                lb <= fun(x) <= ub
            - ('greater', lb) 表示约束类型为：
                fun(x) >= lb
            - ('less', ub) 表示约束类型为：
                fun(x) <= ub
            - ('equals', c) 表示约束类型为：
                fun(x) == c
            - ('greater',) 表示约束类型为：
                fun(x) >= 0
            - ('less',) 表示约束类型为：
                fun(x) <= 0
            - ('equals',) 表示约束类型为：
                fun(x) == 0

        其中 ``lb``,  ``ub`` 和 ``c`` 是 (m,) 的 ndarrays 或标量值。
        在后一种情况下，相同的值将对所有约束重复。
    jac : callable
        雅可比矩阵：

            jac(x) -> {ndarray, sparse matrix}, shape (m, n)

        其中 x 是一个 (n,) 的 ndarray。
    hess : {callable, '2-point', '3-point', 'cs', None}
        计算 Hessian 矩阵的方法。关键字选择一个数值估计的有限差分方案。
        方案 '3-point' 更精确，但是与 '2-point'（默认）相比需要两倍的操作。
        方案 'cs' 使用复步进，虽然可能最准确，但仅当 `fun` 正确处理复数输入
        并且可以解析地延拓到复平面时才适用。如果它是一个 callable，
        它应该返回 `dot(fun, v)` 的 Hessian 矩阵：

            hess(x, v) -> {LinearOperator, sparse matrix, ndarray}, shape (n, n)

        其中 x 是一个 (n,) 的 ndarray，v 是一个 (m,) 的 ndarray。
        当 ``hess`` 为 None 时，它认为 Hessian 矩阵是一个填满零的矩阵。
    enforce_feasibility : {list of boolean, boolean}, optional
        指定约束是否必须在迭代过程中可行。如果为 ``True``，
        则优化算法生成的所有迭代点都需要满足约束。如果为 ``False``，
        则不需要。可以传递一个列表来指定每个约束在迭代过程中需要保持可行性或不需要。
        或者，可以使用单个布尔值来指定所有约束所需的可行性。默认为 False。

```

### ``LinearConstraint``

```
LinearConstraint(A, kind, enforce_feasibility=False)

    线性约束

    参数
    ----------
    A : {ndarray, sparse matrix}, shape (m, n)
        用于线性约束的矩阵。
    kind : {str, tuple}
        指定约束的类型。此参数的选项为：

            - ('interval', lb, ub) 表示约束类型为：
                lb <= A x <= ub
            - ('greater', lb) 表示约束类型为：
                A x >= lb
            - ('less', ub) 表示约束类型为：
                A x <= ub
            - ('equals', c) 表示约束类型为：
                A x == c
            - ('greater',) 表示约束类型为：
                A x >= 0
            - ('less',) 表示约束类型为：
                A x <= 0
            - ('equals',) 表示约束类型为：
                A x == 0

        其中 ``lb``,  ``ub`` 和 ``c`` 是 (m,) 的 ndarrays 或标量值。
        在后一种情况下，相同的值将对所有约束重复。
    enforce_feasibility : {list of boolean, boolean}, optional
        指定约束是否必须在迭代过程中可行。如果为 ``True``，
        则优化算法生成的所有迭代点都需要满足约束。如果为 ``False``，
        则不需要。可以传递一个列表来指定每个约束在迭代过程中需要保持可行性或不需要。
        或者，可以使用单个布尔值来指定所有约束所需的可行性。默认为 False。

```

###  ``BoxConstraint``

```
class BoxConstraint:
    """
    区间约束

    参数
    ----------
    kind : tuple
        指定约束类型。此参数的选项为：

            - ('interval', lb, ub) 表示类型约束：
                lb <= x <= ub
            - ('greater', lb) 表示类型约束：
                x >= lb
            - ('less', ub) 表示类型约束：
                x <= ub
            - ('equals', c) 表示类型约束：
                x == c
            - ('greater',) 表示类型约束：
                x >= 0
            - ('less',) 表示类型约束：
                x <= 0
            - ('equals',) 表示类型约束：
                x == 0

        其中 ``lb``、``ub`` 和 ``c`` 是 (m,) ndarray 或标量值。
        在后一种情况下，相同的值将为所有约束重复。
    enforce_feasibility : {list of boolean, boolean}, 可选
        指定约束是否必须在迭代过程中保持可行性。
        如果 ``True``，则优化算法生成的所有迭代点都需要
        对某个约束而言是可行的。如果 ``False``，
        则不需要。可以传递列表以逐元素指定
        每个约束在迭代过程中需要保持可行性和
        每个约束不需要。另外，可以使用单个布尔值来指定
        所有约束的要求可行性。默认为 False。
    """
    def __init__(self, kind, enforce_feasibility=False):
        pass

```