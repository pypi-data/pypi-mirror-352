"use strict";(self.webpackChunk_jupyterlite_terminal=self.webpackChunk_jupyterlite_terminal||[]).push([[266,885],{1266:(e,t,n)=>{n.r(t),n.d(t,{IServiceWorkerManager:()=>a,SERVICE_WORKER_BROADCAST_CHANNEL_ID:()=>d,ServiceWorkerManager:()=>u,WORKER_NAME:()=>o});var s=n(7262),i=n(5626),r=n.n(i);const a=new s.Token("@jupyterlite/server:IServiceWorkerManager"),o=`${r()}`.split("/").slice(-1)[0];var c=n(1689),l=n(253),g=n(4602);const d="/sw-api.v1",h=c.PageConfig.getOption("appVersion");class u{constructor(e){var t;this._onBroadcastMessage=async e=>{const{data:t,browsingContextId:n,pathname:s}=e.data;n===this._browsingContextId&&(s.includes("/api/stdin/")?this._onStdinMessage(s,t):this._onDriveMessage(t))},this._onDriveMessage=async e=>{const t=await this._driveContentsProcessor.processDriveRequest(e);this._broadcastChannel.postMessage({response:t,browsingContextId:this._browsingContextId})},this._onStdinMessage=async(e,t)=>{const n=e.slice(e.lastIndexOf("/")+1),s=this._stdinHandlers.get(n);if(void 0!==s){const e=await s(t);this._broadcastChannel.postMessage({response:e,browsingContextId:this._browsingContextId})}else console.warn(`No stdin handler registered for '${e}'`)},this._registration=null,this._registrationChanged=new g.Signal(this),this._ready=new s.PromiseDelegate,this._stdinHandlers=new Map;const n=null!==(t=e.workerUrl)&&void 0!==t?t:c.URLExt.join(c.PageConfig.getBaseUrl(),o),i=new URL(n,window.location.href),r=c.PageConfig.getOption("enableServiceWorkerCache")||"false";i.searchParams.set("enableCache",r),this._browsingContextId=s.UUID.uuid4(),this._contents=e.contents,this._broadcastChannel=new BroadcastChannel(d),this._broadcastChannel.addEventListener("message",this._onBroadcastMessage),this._driveContentsProcessor=new l.DriveContentsProcessor({contentsManager:this._contents}),this._initialize(i.href).catch(console.warn)}get registrationChanged(){return this._registrationChanged}get enabled(){return null!==this._registration}get browsingContextId(){return this._browsingContextId}get ready(){return this._ready.promise}registerStdinHandler(e,t){this._stdinHandlers.set(e,t)}async _initialize(e){const{serviceWorker:t}=navigator;let n=null;if(t){if(t.controller){const e=t.controller.scriptURL;await this._unregisterOldServiceWorkers(e),n=await t.getRegistration(e)||null,console.info("JupyterLite ServiceWorker was already registered")}if(!n&&t)try{console.info("Registering new JupyterLite ServiceWorker",e),n=await t.register(e),console.info("JupyterLite ServiceWorker was sucessfully registered")}catch(e){console.warn(e),console.warn(`JupyterLite ServiceWorker registration unexpectedly failed: ${e}`)}this._setRegistration(n),n?(this._ready.resolve(void 0),setTimeout(this._pingServiceWorker,2e4)):this._ready.reject(void 0)}else console.warn("ServiceWorkers not supported in this browser")}async _unregisterOldServiceWorkers(e){const t=`${e}-version`,n=localStorage.getItem(t);if(n&&n!==h||!n){console.info("New version, unregistering existing service workers.");const e=await navigator.serviceWorker.getRegistrations();await Promise.all(e.map((e=>e.unregister()))),console.info("All existing service workers have been unregistered.")}localStorage.setItem(t,h)}async _pingServiceWorker(){const e=await fetch("/api/service-worker-heartbeat");"ok"===await e.text()&&setTimeout(this._pingServiceWorker,2e4)}_setRegistration(e){this._registration=e,this._registrationChanged.emit(this._registration)}}},5626:()=>{const e=new BroadcastChannel("/sw-api.v1");let t=!1;async function n(){return await caches.open("precache")}async function s(e,t){return(await n()).put(e,t)}self.addEventListener("install",(function(e){self.skipWaiting(),e.waitUntil(async function(){const e=await n();return await e.addAll([])}())})),self.addEventListener("activate",(function(e){const n=new URL(location.href).searchParams;t="true"===n.get("enableCache"),e.waitUntil(self.clients.claim())})),self.addEventListener("fetch",(async function(i){const{request:r}=i,a=new URL(i.request.url);if("/api/service-worker-heartbeat"===a.pathname)return void i.respondWith(new Response("ok"));let o=null;!function(e){return e.origin===location.origin&&(e.pathname.includes("/api/drive")||e.pathname.includes("/api/stdin/"))}(a)?function(e,t){return"GET"!==e.method||null===t.origin.match(/^http/)||t.pathname.includes("/api/")}(r,a)||(o=async function(e){const{request:i}=e;if(!t)return await fetch(i);let r=await async function(e){const t=await n(),s=await t.match(e);return s&&404!==s.status?s:null}(i);return r?e.waitUntil(async function(e){const t=await fetch(e);return await s(e,t),t}(i)):(r=await fetch(i),e.waitUntil(s(i,r.clone()))),r}(i)):o=async function(t,n){const s=await t.json(),i=new Promise((t=>{const n=i=>{const r=i.data;if(r.browsingContextId!==s.browsingContextId)return;const a=r.response;t(new Response(JSON.stringify(a))),e.removeEventListener("message",n)};e.addEventListener("message",n)}));return s.pathname=n.pathname,e.postMessage(s),await i}(r,a),o&&i.respondWith(o)}))}}]);