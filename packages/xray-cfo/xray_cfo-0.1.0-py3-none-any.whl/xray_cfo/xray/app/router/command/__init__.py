# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: app/router/command/command.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AddRuleRequest",
    "AddRuleResponse",
    "BalancerMsg",
    "Config",
    "GetBalancerInfoRequest",
    "GetBalancerInfoResponse",
    "OverrideBalancerTargetRequest",
    "OverrideBalancerTargetResponse",
    "OverrideInfo",
    "PrincipleTargetInfo",
    "RemoveRuleRequest",
    "RemoveRuleResponse",
    "RoutingContext",
    "SubscribeRoutingStatsRequest",
    "TestRouteRequest",
    "RoutingServiceStub",
    "RoutingServiceBase",
)

from collections.abc import AsyncIterator
from dataclasses import dataclass
from typing import TYPE_CHECKING

import betterproto2
import grpclib
from betterproto2.grpc.grpclib_server import ServiceBase

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

betterproto2.check_compiler_version("0.5.1")


@dataclass(eq=False, repr=False)
class AddRuleRequest(betterproto2.Message):
    config: "___common__serial__.TypedMessage | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    should_append: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "xray.app.router.command", "AddRuleRequest", AddRuleRequest
)


@dataclass(eq=False, repr=False)
class AddRuleResponse(betterproto2.Message):
    pass


default_message_pool.register_message(
    "xray.app.router.command", "AddRuleResponse", AddRuleResponse
)


@dataclass(eq=False, repr=False)
class BalancerMsg(betterproto2.Message):
    override: "OverrideInfo | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )

    principle_target: "PrincipleTargetInfo | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "xray.app.router.command", "BalancerMsg", BalancerMsg
)


@dataclass(eq=False, repr=False)
class Config(betterproto2.Message):
    pass


default_message_pool.register_message("xray.app.router.command", "Config", Config)


@dataclass(eq=False, repr=False)
class GetBalancerInfoRequest(betterproto2.Message):
    tag: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "xray.app.router.command", "GetBalancerInfoRequest", GetBalancerInfoRequest
)


@dataclass(eq=False, repr=False)
class GetBalancerInfoResponse(betterproto2.Message):
    balancer: "BalancerMsg | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "xray.app.router.command", "GetBalancerInfoResponse", GetBalancerInfoResponse
)


@dataclass(eq=False, repr=False)
class OverrideBalancerTargetRequest(betterproto2.Message):
    balancer_tag: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    target: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "xray.app.router.command",
    "OverrideBalancerTargetRequest",
    OverrideBalancerTargetRequest,
)


@dataclass(eq=False, repr=False)
class OverrideBalancerTargetResponse(betterproto2.Message):
    pass


default_message_pool.register_message(
    "xray.app.router.command",
    "OverrideBalancerTargetResponse",
    OverrideBalancerTargetResponse,
)


@dataclass(eq=False, repr=False)
class OverrideInfo(betterproto2.Message):
    target: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "xray.app.router.command", "OverrideInfo", OverrideInfo
)


@dataclass(eq=False, repr=False)
class PrincipleTargetInfo(betterproto2.Message):
    tag: "list[str]" = betterproto2.field(1, betterproto2.TYPE_STRING, repeated=True)


default_message_pool.register_message(
    "xray.app.router.command", "PrincipleTargetInfo", PrincipleTargetInfo
)


@dataclass(eq=False, repr=False)
class RemoveRuleRequest(betterproto2.Message):
    rule_tag: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "xray.app.router.command", "RemoveRuleRequest", RemoveRuleRequest
)


@dataclass(eq=False, repr=False)
class RemoveRuleResponse(betterproto2.Message):
    pass


default_message_pool.register_message(
    "xray.app.router.command", "RemoveRuleResponse", RemoveRuleResponse
)


@dataclass(eq=False, repr=False)
class RoutingContext(betterproto2.Message):
    """
    RoutingContext is the context with information relative to routing process.
    It conforms to the structure of xray.features.routing.Context and
    xray.features.routing.Route.
    """

    inbound_tag: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    network: "___common__net__.Network" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: ___common__net__.Network(0)
    )

    source_i_ps: "list[bytes]" = betterproto2.field(
        3, betterproto2.TYPE_BYTES, repeated=True
    )

    target_i_ps: "list[bytes]" = betterproto2.field(
        4, betterproto2.TYPE_BYTES, repeated=True
    )

    source_port: "int" = betterproto2.field(5, betterproto2.TYPE_UINT32)

    target_port: "int" = betterproto2.field(6, betterproto2.TYPE_UINT32)

    target_domain: "str" = betterproto2.field(7, betterproto2.TYPE_STRING)

    protocol: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)

    user: "str" = betterproto2.field(9, betterproto2.TYPE_STRING)

    attributes: "dict[str, str]" = betterproto2.field(
        10,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_STRING
        ),
    )

    outbound_group_tags: "list[str]" = betterproto2.field(
        11, betterproto2.TYPE_STRING, repeated=True
    )

    outbound_tag: "str" = betterproto2.field(12, betterproto2.TYPE_STRING)


default_message_pool.register_message(
    "xray.app.router.command", "RoutingContext", RoutingContext
)


@dataclass(eq=False, repr=False)
class SubscribeRoutingStatsRequest(betterproto2.Message):
    """
    SubscribeRoutingStatsRequest subscribes to routing statistics channel if
    opened by xray-core.
    * FieldSelectors selects a subset of fields in routing statistics to return.
    Valid selectors:
     - inbound: Selects connection's inbound tag.
     - network: Selects connection's network.
     - ip: Equivalent as "ip_source" and "ip_target", selects both source and
     target IP.
     - port: Equivalent as "port_source" and "port_target", selects both source
     and target port.
     - domain: Selects target domain.
     - protocol: Select connection's protocol.
     - user: Select connection's inbound user email.
     - attributes: Select connection's additional attributes.
     - outbound: Equivalent as "outbound" and "outbound_group", select both
     outbound tag and outbound group tags.
    * If FieldSelectors is left empty, all fields will be returned.
    """

    field_selectors: "list[str]" = betterproto2.field(
        1, betterproto2.TYPE_STRING, repeated=True
    )


default_message_pool.register_message(
    "xray.app.router.command",
    "SubscribeRoutingStatsRequest",
    SubscribeRoutingStatsRequest,
)


@dataclass(eq=False, repr=False)
class TestRouteRequest(betterproto2.Message):
    """
    TestRouteRequest manually tests a routing result according to the routing
    context message.
    * RoutingContext is the routing message without outbound information.
    * FieldSelectors selects the fields to return in the routing result. All
    fields are returned if left empty.
    * PublishResult broadcasts the routing result to routing statistics channel
    if set true.
    """

    routing_context: "RoutingContext | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    field_selectors: "list[str]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )

    publish_result: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "xray.app.router.command", "TestRouteRequest", TestRouteRequest
)


class RoutingServiceStub(betterproto2.ServiceStub):
    async def subscribe_routing_stats(
        self,
        message: "SubscribeRoutingStatsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[RoutingContext]":
        async for response in self._unary_stream(
            "/xray.app.router.command.RoutingService/SubscribeRoutingStats",
            message,
            RoutingContext,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def test_route(
        self,
        message: "TestRouteRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "RoutingContext":
        return await self._unary_unary(
            "/xray.app.router.command.RoutingService/TestRoute",
            message,
            RoutingContext,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_balancer_info(
        self,
        message: "GetBalancerInfoRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetBalancerInfoResponse":
        return await self._unary_unary(
            "/xray.app.router.command.RoutingService/GetBalancerInfo",
            message,
            GetBalancerInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def override_balancer_target(
        self,
        message: "OverrideBalancerTargetRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "OverrideBalancerTargetResponse":
        return await self._unary_unary(
            "/xray.app.router.command.RoutingService/OverrideBalancerTarget",
            message,
            OverrideBalancerTargetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def add_rule(
        self,
        message: "AddRuleRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AddRuleResponse":
        return await self._unary_unary(
            "/xray.app.router.command.RoutingService/AddRule",
            message,
            AddRuleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def remove_rule(
        self,
        message: "RemoveRuleRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "RemoveRuleResponse":
        return await self._unary_unary(
            "/xray.app.router.command.RoutingService/RemoveRule",
            message,
            RemoveRuleResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from ....common import net as ___common__net__
from ....common import serial as ___common__serial__


class RoutingServiceBase(ServiceBase):
    async def subscribe_routing_stats(
        self, message: "SubscribeRoutingStatsRequest"
    ) -> "AsyncIterator[RoutingContext]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def test_route(self, message: "TestRouteRequest") -> "RoutingContext":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_balancer_info(
        self, message: "GetBalancerInfoRequest"
    ) -> "GetBalancerInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def override_balancer_target(
        self, message: "OverrideBalancerTargetRequest"
    ) -> "OverrideBalancerTargetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_rule(self, message: "AddRuleRequest") -> "AddRuleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def remove_rule(self, message: "RemoveRuleRequest") -> "RemoveRuleResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_subscribe_routing_stats(
        self,
        stream: "grpclib.server.Stream[SubscribeRoutingStatsRequest, RoutingContext]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_routing_stats,
            stream,
            request,
        )

    async def __rpc_test_route(
        self, stream: "grpclib.server.Stream[TestRouteRequest, RoutingContext]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.test_route(request)
        await stream.send_message(response)

    async def __rpc_get_balancer_info(
        self,
        stream: "grpclib.server.Stream[GetBalancerInfoRequest, GetBalancerInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_balancer_info(request)
        await stream.send_message(response)

    async def __rpc_override_balancer_target(
        self,
        stream: "grpclib.server.Stream[OverrideBalancerTargetRequest, OverrideBalancerTargetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.override_balancer_target(request)
        await stream.send_message(response)

    async def __rpc_add_rule(
        self, stream: "grpclib.server.Stream[AddRuleRequest, AddRuleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_rule(request)
        await stream.send_message(response)

    async def __rpc_remove_rule(
        self, stream: "grpclib.server.Stream[RemoveRuleRequest, RemoveRuleResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.remove_rule(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/xray.app.router.command.RoutingService/SubscribeRoutingStats": grpclib.const.Handler(
                self.__rpc_subscribe_routing_stats,
                grpclib.const.Cardinality.UNARY_STREAM,
                SubscribeRoutingStatsRequest,
                RoutingContext,
            ),
            "/xray.app.router.command.RoutingService/TestRoute": grpclib.const.Handler(
                self.__rpc_test_route,
                grpclib.const.Cardinality.UNARY_UNARY,
                TestRouteRequest,
                RoutingContext,
            ),
            "/xray.app.router.command.RoutingService/GetBalancerInfo": grpclib.const.Handler(
                self.__rpc_get_balancer_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetBalancerInfoRequest,
                GetBalancerInfoResponse,
            ),
            "/xray.app.router.command.RoutingService/OverrideBalancerTarget": grpclib.const.Handler(
                self.__rpc_override_balancer_target,
                grpclib.const.Cardinality.UNARY_UNARY,
                OverrideBalancerTargetRequest,
                OverrideBalancerTargetResponse,
            ),
            "/xray.app.router.command.RoutingService/AddRule": grpclib.const.Handler(
                self.__rpc_add_rule,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddRuleRequest,
                AddRuleResponse,
            ),
            "/xray.app.router.command.RoutingService/RemoveRule": grpclib.const.Handler(
                self.__rpc_remove_rule,
                grpclib.const.Cardinality.UNARY_UNARY,
                RemoveRuleRequest,
                RemoveRuleResponse,
            ),
        }
