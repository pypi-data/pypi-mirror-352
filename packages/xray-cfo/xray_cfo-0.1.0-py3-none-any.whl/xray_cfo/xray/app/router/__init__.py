# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: app/router/config.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "ConfigDomainStrategy",
    "DomainType",
    "BalancingRule",
    "Cidr",
    "Config",
    "Domain",
    "DomainAttribute",
    "GeoIp",
    "GeoIpList",
    "GeoSite",
    "GeoSiteList",
    "RoutingRule",
    "StrategyLeastLoadConfig",
    "StrategyWeight",
)

from dataclasses import dataclass

import betterproto2

from ....message_pool import default_message_pool

betterproto2.check_compiler_version("0.5.1")


class ConfigDomainStrategy(betterproto2.Enum):
    AsIs = 0
    """
    Use domain as is.
    """

    UseIp = 1
    """
    Always resolve IP for domains.
    """

    IpIfNonMatch = 2
    """
    Resolve to IP if the domain doesn't match any rules.
    """

    IpOnDemand = 3
    """
    Resolve to IP if any rule requires IP matching.
    """


class DomainType(betterproto2.Enum):
    """
    Type of domain value.
    """

    Plain = 0
    """
    The value is used as is.
    """

    Regex = 1
    """
    The value is used as a regular expression.
    """

    Domain = 2
    """
    The value is a root domain.
    """

    Full = 3
    """
    The value is a domain.
    """


@dataclass(eq=False, repr=False)
class BalancingRule(betterproto2.Message):
    tag: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    outbound_selector: "list[str]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )

    strategy: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)

    strategy_settings: "__common__serial__.TypedMessage | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    fallback_tag: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)


default_message_pool.register_message("xray.app.router", "BalancingRule", BalancingRule)


@dataclass(eq=False, repr=False)
class Cidr(betterproto2.Message):
    """
    IP for routing decision, in CIDR form.
    """

    ip: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    IP address, should be either 4 or 16 bytes.
    """

    prefix: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)
    """
    Number of leading ones in the network mask.
    """


default_message_pool.register_message("xray.app.router", "CIDR", Cidr)


@dataclass(eq=False, repr=False)
class Config(betterproto2.Message):
    domain_strategy: "ConfigDomainStrategy" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ConfigDomainStrategy(0)
    )

    rule: "list[RoutingRule]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )

    balancing_rule: "list[BalancingRule]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("xray.app.router", "Config", Config)


@dataclass(eq=False, repr=False)
class Domain(betterproto2.Message):
    """
    Domain for routing decision.
    """

    type: "DomainType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: DomainType(0)
    )
    """
    Domain matching type.
    """

    value: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Domain value.
    """

    attribute: "list[DomainAttribute]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Attributes of this domain. May be used for filtering.
    """


default_message_pool.register_message("xray.app.router", "Domain", Domain)


@dataclass(eq=False, repr=False)
class DomainAttribute(betterproto2.Message):
    """


    Oneofs:
        - typed_value:
    """

    key: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    bool_value: "bool | None" = betterproto2.field(
        2, betterproto2.TYPE_BOOL, optional=True, group="typed_value"
    )

    int_value: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_INT64, optional=True, group="typed_value"
    )


default_message_pool.register_message(
    "xray.app.router", "Domain.Attribute", DomainAttribute
)


@dataclass(eq=False, repr=False)
class GeoIp(betterproto2.Message):
    country_code: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    cidr: "list[Cidr]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    reverse_match: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)


default_message_pool.register_message("xray.app.router", "GeoIP", GeoIp)


@dataclass(eq=False, repr=False)
class GeoIpList(betterproto2.Message):
    entry: "list[GeoIp]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("xray.app.router", "GeoIPList", GeoIpList)


@dataclass(eq=False, repr=False)
class GeoSite(betterproto2.Message):
    country_code: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    domain: "list[Domain]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("xray.app.router", "GeoSite", GeoSite)


@dataclass(eq=False, repr=False)
class GeoSiteList(betterproto2.Message):
    entry: "list[GeoSite]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("xray.app.router", "GeoSiteList", GeoSiteList)


@dataclass(eq=False, repr=False)
class RoutingRule(betterproto2.Message):
    """


    Oneofs:
        - target_tag:
    """

    tag: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="target_tag"
    )
    """
    Tag of outbound that this rule is pointing to.
    """

    balancing_tag: "str | None" = betterproto2.field(
        12, betterproto2.TYPE_STRING, optional=True, group="target_tag"
    )
    """
    Tag of routing balancer.
    """

    rule_tag: "str" = betterproto2.field(18, betterproto2.TYPE_STRING)

    domain: "list[Domain]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of domains for target domain matching.
    """

    geoip: "list[GeoIp]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of GeoIPs for target IP address matching. If this entry exists, the
    cidr above will have no effect. GeoIP fields with the same country code are
    supposed to contain exactly same content. They will be merged during
    runtime. For customized GeoIPs, please leave country code empty.
    """

    port_list: "__common__net__.PortList | None" = betterproto2.field(
        14, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    List of ports.
    """

    networks: "list[__common__net__.Network]" = betterproto2.field(
        13, betterproto2.TYPE_ENUM, repeated=True
    )
    """
    List of networks for matching.
    """

    source_geoip: "list[GeoIp]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of GeoIPs for source IP address matching. If this entry exists, the
    source_cidr above will have no effect.
    """

    source_port_list: "__common__net__.PortList | None" = betterproto2.field(
        16, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    List of ports for source port matching.
    """

    user_email: "list[str]" = betterproto2.field(
        7, betterproto2.TYPE_STRING, repeated=True
    )

    inbound_tag: "list[str]" = betterproto2.field(
        8, betterproto2.TYPE_STRING, repeated=True
    )

    protocol: "list[str]" = betterproto2.field(
        9, betterproto2.TYPE_STRING, repeated=True
    )

    attributes: "dict[str, str]" = betterproto2.field(
        15,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_STRING
        ),
    )

    domain_matcher: "str" = betterproto2.field(17, betterproto2.TYPE_STRING)


default_message_pool.register_message("xray.app.router", "RoutingRule", RoutingRule)


@dataclass(eq=False, repr=False)
class StrategyLeastLoadConfig(betterproto2.Message):
    costs: "list[StrategyWeight]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    weight settings
    """

    baselines: "list[int]" = betterproto2.field(
        3, betterproto2.TYPE_INT64, repeated=True
    )
    """
    RTT baselines for selecting, int64 values of time.Duration
    """

    expected: "int" = betterproto2.field(4, betterproto2.TYPE_INT32)
    """
    expected nodes count to select
    """

    max_rtt: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)
    """
    max acceptable rtt, filter away high delay nodes. default 0
    """

    tolerance: "float" = betterproto2.field(6, betterproto2.TYPE_FLOAT)
    """
    acceptable failure rate
    """


default_message_pool.register_message(
    "xray.app.router", "StrategyLeastLoadConfig", StrategyLeastLoadConfig
)


@dataclass(eq=False, repr=False)
class StrategyWeight(betterproto2.Message):
    regexp: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)

    match: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    value: "float" = betterproto2.field(3, betterproto2.TYPE_FLOAT)


default_message_pool.register_message(
    "xray.app.router", "StrategyWeight", StrategyWeight
)


from ...common import net as __common__net__
from ...common import serial as __common__serial__
