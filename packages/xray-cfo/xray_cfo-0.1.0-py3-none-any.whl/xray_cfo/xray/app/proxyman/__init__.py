# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: app/proxyman/config.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AllocationStrategyType",
    "AllocationStrategy",
    "AllocationStrategyAllocationStrategyConcurrency",
    "AllocationStrategyAllocationStrategyRefresh",
    "InboundConfig",
    "InboundHandlerConfig",
    "MultiplexingConfig",
    "OutboundConfig",
    "ReceiverConfig",
    "SenderConfig",
    "SniffingConfig",
)

from dataclasses import dataclass

import betterproto2

from ....message_pool import default_message_pool

betterproto2.check_compiler_version("0.5.1")


class AllocationStrategyType(betterproto2.Enum):
    Always = 0
    """
    Always allocate all connection handlers.
    """

    Random = 1
    """
    Randomly allocate specific range of handlers.
    """

    External = 2
    """
    External. Not supported yet.
    """


@dataclass(eq=False, repr=False)
class AllocationStrategy(betterproto2.Message):
    type: "AllocationStrategyType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: AllocationStrategyType(0)
    )

    concurrency: "AllocationStrategyAllocationStrategyConcurrency | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )
    """
    Number of handlers (ports) running in parallel.
    Default value is 3 if unset.
    """

    refresh: "AllocationStrategyAllocationStrategyRefresh | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Number of minutes before a handler is regenerated.
    Default value is 5 if unset.
    """


default_message_pool.register_message(
    "xray.app.proxyman", "AllocationStrategy", AllocationStrategy
)


@dataclass(eq=False, repr=False)
class AllocationStrategyAllocationStrategyConcurrency(betterproto2.Message):
    value: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)


default_message_pool.register_message(
    "xray.app.proxyman",
    "AllocationStrategy.AllocationStrategyConcurrency",
    AllocationStrategyAllocationStrategyConcurrency,
)


@dataclass(eq=False, repr=False)
class AllocationStrategyAllocationStrategyRefresh(betterproto2.Message):
    value: "int" = betterproto2.field(1, betterproto2.TYPE_UINT32)


default_message_pool.register_message(
    "xray.app.proxyman",
    "AllocationStrategy.AllocationStrategyRefresh",
    AllocationStrategyAllocationStrategyRefresh,
)


@dataclass(eq=False, repr=False)
class InboundConfig(betterproto2.Message):
    pass


default_message_pool.register_message(
    "xray.app.proxyman", "InboundConfig", InboundConfig
)


@dataclass(eq=False, repr=False)
class InboundHandlerConfig(betterproto2.Message):
    tag: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    receiver_settings: "__common__serial__.TypedMessage | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    proxy_settings: "__common__serial__.TypedMessage | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "xray.app.proxyman", "InboundHandlerConfig", InboundHandlerConfig
)


@dataclass(eq=False, repr=False)
class MultiplexingConfig(betterproto2.Message):
    enabled: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    Whether or not Mux is enabled.
    """

    concurrency: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)
    """
    Max number of concurrent connections that one Mux connection can handle.
    """

    xudp_concurrency: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)
    """
    Transport XUDP in another Mux.
    """

    xudp_proxy_udp_443: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)
    """
    "reject" (default), "allow" or "skip".
    """


default_message_pool.register_message(
    "xray.app.proxyman", "MultiplexingConfig", MultiplexingConfig
)


@dataclass(eq=False, repr=False)
class OutboundConfig(betterproto2.Message):
    pass


default_message_pool.register_message(
    "xray.app.proxyman", "OutboundConfig", OutboundConfig
)


@dataclass(eq=False, repr=False)
class ReceiverConfig(betterproto2.Message):
    port_list: "__common__net__.PortList | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    PortList specifies the ports which the Receiver should listen on.
    """

    listen: "__common__net__.IpOrDomain | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Listen specifies the IP address that the Receiver should listen on.
    """

    allocation_strategy: "AllocationStrategy | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    stream_settings: "__transport__internet__.StreamConfig | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    receive_original_destination: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)

    sniffing_settings: "SniffingConfig | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "xray.app.proxyman", "ReceiverConfig", ReceiverConfig
)


@dataclass(eq=False, repr=False)
class SenderConfig(betterproto2.Message):
    via: "__common__net__.IpOrDomain | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Send traffic through the given IP. Only IP is allowed.
    """

    stream_settings: "__transport__internet__.StreamConfig | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    proxy_settings: "__transport__internet__.ProxyConfig | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    multiplex_settings: "MultiplexingConfig | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    via_cidr: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)


default_message_pool.register_message("xray.app.proxyman", "SenderConfig", SenderConfig)


@dataclass(eq=False, repr=False)
class SniffingConfig(betterproto2.Message):
    enabled: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    Whether or not to enable content sniffing on an inbound connection.
    """

    destination_override: "list[str]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Override target destination if sniff'ed protocol is in the given list.
    Supported values are "http", "tls", "fakedns".
    """

    domains_excluded: "list[str]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )

    metadata_only: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)
    """
    Whether should only try to sniff metadata without waiting for client input.
    Can be used to support SMTP like protocol where server send the first
    message.
    """

    route_only: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "xray.app.proxyman", "SniffingConfig", SniffingConfig
)


from ...common import net as __common__net__
from ...common import serial as __common__serial__
from ...transport import internet as __transport__internet__
