# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: transport/internet/tls/config.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "CertificateUsage",
    "Certificate",
    "Config",
)

from dataclasses import dataclass

import betterproto2

from .....message_pool import default_message_pool

betterproto2.check_compiler_version("0.5.1")


class CertificateUsage(betterproto2.Enum):
    ENCIPHERMENT = 0

    AUTHORITY_VERIFY = 1

    AUTHORITY_ISSUE = 2


@dataclass(eq=False, repr=False)
class Certificate(betterproto2.Message):
    certificate: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    TLS certificate in x509 format.
    """

    key: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    TLS key in x509 format.
    """

    usage: "CertificateUsage" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: CertificateUsage(0)
    )

    ocsp_stapling: "int" = betterproto2.field(4, betterproto2.TYPE_UINT64)

    certificate_path: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    TLS certificate path
    """

    key_path: "str" = betterproto2.field(6, betterproto2.TYPE_STRING)
    """
    TLS Key path
    """

    One_time_loading: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)
    """
    If true, one-Time Loading
    """

    build_chain: "bool" = betterproto2.field(8, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "xray.transport.internet.tls", "Certificate", Certificate
)


@dataclass(eq=False, repr=False)
class Config(betterproto2.Message):
    allow_insecure: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    Whether or not to allow self-signed certificates.
    """

    certificate: "list[Certificate]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of certificates to be served on server.
    """

    server_name: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)
    """
    Override server name.
    """

    next_protocol: "list[str]" = betterproto2.field(
        4, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Lists of string as ALPN values.
    """

    enable_session_resumption: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    Whether or not to enable session (ticket) resumption.
    """

    disable_system_root: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)
    """
    If true, root certificates on the system will not be loaded for
    verification.
    """

    min_version: "str" = betterproto2.field(7, betterproto2.TYPE_STRING)
    """
    The minimum TLS version.
    """

    max_version: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)
    """
    The maximum TLS version.
    """

    cipher_suites: "str" = betterproto2.field(9, betterproto2.TYPE_STRING)
    """
    Specify cipher suites, except for TLS 1.3.
    """

    fingerprint: "str" = betterproto2.field(11, betterproto2.TYPE_STRING)
    """
    TLS Client Hello fingerprint (uTLS).
    """

    reject_unknown_sni: "bool" = betterproto2.field(12, betterproto2.TYPE_BOOL)

    pinned_peer_certificate_chain_sha256: "list[bytes]" = betterproto2.field(
        13, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    @Document Some certificate chain sha256 hashes.
    @Document After normal validation or allow_insecure, if the server's cert chain hash does not match any of these values, the connection will be aborted.
    @Critical
    """

    pinned_peer_certificate_public_key_sha256: "list[bytes]" = betterproto2.field(
        14, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    @Document Some certificate public key sha256 hashes.
    @Document After normal validation (required), if one of certs in verified chain matches one of these values, the connection will be eventually accepted.
    @Critical
    """

    master_key_log: "str" = betterproto2.field(15, betterproto2.TYPE_STRING)

    curve_preferences: "list[str]" = betterproto2.field(
        16, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Lists of string as CurvePreferences values.
    """

    verify_peer_cert_in_names: "list[str]" = betterproto2.field(
        17, betterproto2.TYPE_STRING, repeated=True
    )
    """
    @Document Replaces server_name to verify the peer cert.
    @Document After allow_insecure (automatically), if the server's cert can't be verified by any of these names, pinned_peer_certificate_chain_sha256 will be tried.
    @Critical
    """


default_message_pool.register_message("xray.transport.internet.tls", "Config", Config)
