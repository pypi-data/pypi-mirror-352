/*
   This file is part of PADL Lib with bn254 curv
    Copyright 2024 by GTAR-JPMorganChase
*/
use pyo3::prelude::*;
use curv::arithmetic::traits::*;
use curv::arithmetic::Converter;
use curv::cryptographic_primitives::hashing::{Digest, DigestExt};
use curv::elliptic::curves::{bn254::Bn254, Point, Scalar};
use curv::BigInt;
use sha2::Sha512;
use sha2::Sha256;
use curv::cryptographic_primitives::proofs::sigma_dlog_explicit::{DLogProofExplicit};
use curv::cryptographic_primitives::proofs::sigma_eq_dlog::{DLogEqProof};
use curv::cryptographic_primitives::proofs::sigma_dlog::{DLogProof};
use curv::cryptographic_primitives::proofs::sigma_eq_dlog_ped::{DLogEqProofPed};
use curv::cryptographic_primitives::proofs::sigma_consistency::{ConsistencyProof};
use curv::elliptic::curves::bn254::hash_to_curve::generate_random_point;
use bulletproof::proofs::range_proof::RangeProof;
//use bulletproof::curv::elliptic::curves::secp256_k1::rng;
use rand_legacy::SeedableRng;
use serde_json;
use serde_json::Value;
use json_value_merge::Merge;

// This function is used to create proof of knowledge of $sk$ in $h^{r \cdot sk}$ with $h^r$ as the generator,
// with Sha512 which produces a 512-bit (64-byte) hash value and offers a higher security level with 256-bit security against collision attacks
#[pyfunction]
fn sigma_dlog_proof_explicit(sum_tokens:&Token, pbsk: &PbSk,  h_sumR:&Commit)-> PyResult<String>{
    let witness = &pbsk.sk;
    let dlog_ex_proof = DLogProofExplicit::<Bn254, Sha512>::prove(&witness, &h_sumR.out);
    let ser_proof = serde_json::to_string_pretty(&dlog_ex_proof).unwrap();
    Ok(ser_proof)
}

// This function is used to create proof of knowledge of $sk$ in $h^{r \cdot sk}$ with $h^r$ as the generator,
// with Sha256 which produces a 256-bit (32-byte) hash value and generally considered secure with a 128-bit security level against collision attacks.
#[pyfunction]
fn sigma_dlog_proof_explicit_sha256(sum_tokens:&Token, pbsk: &PbSk,  h_sumR:&Commit)-> PyResult<String>{
    let witness = &pbsk.sk;
    let dlog_ex_proof = DLogProofExplicit::<Bn254, Sha256>::prove(&witness, &h_sumR.out);
    let ser_proof = serde_json::to_string_pretty(&dlog_ex_proof).unwrap();
    Ok(ser_proof)
}

// This function is used to create proof of knowledge of $sk$ in $h^{r \cdot sk}$ with $h^r$ as the generator,
// Similar to the function without witness, but additionally provide witness to all point multiplication results.
#[pyfunction]
fn sigma_dlog_proof_explicit_sha256_with_witness(sum_tokens:&Token, pbsk: &PbSk,  h_sumR:&Commit)-> PyResult<String>{
    let witness = &pbsk.sk;
    let dlog_ex_proof = DLogProofExplicit::<Bn254, Sha256>::prove(&witness, &h_sumR.out);
    // let ser_proof = serde_json::to_string_pretty(&dlog_ex_proof).unwrap();
    let mul_witness = DLogProofExplicit::<Bn254,Sha256>::generate_mul_witness(&dlog_ex_proof,  &h_sumR.out);
    let mut ser_proof_json = serde_json::to_value(&dlog_ex_proof).unwrap();
    let ser_mul_witness_json = serde_json::to_value(&mul_witness).unwrap();
    ser_proof_json.merge(&ser_mul_witness_json);
    let ser_proof = serde_json::to_string_pretty(&ser_proof_json).unwrap();
    Ok(ser_proof)
}

// This function is used to verify proof which is generated by function 'sigma_dlog_proof_explicit' with Sha512
#[pyfunction]
fn sigma_dlog_proof_explicit_verify(ser_proof: String, h_sumR:&Commit, sum_tokens:&Token)-> PyResult<bool>{
    let deserialized_proof: DLogProofExplicit::<Bn254, Sha512> = serde_json::from_str(&ser_proof).unwrap();
    let mut results = DLogProofExplicit::verify(&deserialized_proof, &h_sumR.out, &sum_tokens.out).is_ok();
    Ok(results)
}

// This function is used to verify proof which is generated by function 'sigma_dlog_proof_explicit_sha256' with Sha256
#[pyfunction]
fn sigma_dlog_proof_explicit_verify_sha256(ser_proof: String, h_sumR:&Commit, sum_tokens:&Token)-> PyResult<bool>{
    let deserialized_proof: DLogProofExplicit::<Bn254, Sha256> = serde_json::from_str(&ser_proof).unwrap();
    let mut results = DLogProofExplicit::verify(&deserialized_proof, &h_sumR.out, &sum_tokens.out).is_ok();
    Ok(results)
}

// This function computes the discrete logarithm equality proof for the variables $gh^{pbsk}$ and $h\_sumR^{pbsk}$, with Sha512
#[pyfunction]
fn sigma_eq_dlog_proof(sum_tokens: &Token, pbsk : &PbSk,gh : &GH, h_sumR: &Commit)-> PyResult<String>{
    let witness = &pbsk.sk;
    let pk_l = &gh.H * witness;
    let pk_r = &h_sumR.out * witness;
    let dlog_eq_proof = DLogEqProof::<Bn254,Sha512>::prove(&witness, &h_sumR.out, &gh.H);
    let mut results = DLogEqProof::verify(&dlog_eq_proof, &h_sumR.out, &gh.H).is_ok();
    if (dlog_eq_proof.pk_l!=sum_tokens.out)
    {
        assert!(false);
    }
    let ser_proof = serde_json::to_string_pretty(&dlog_eq_proof).unwrap();
    Ok(ser_proof)
}

// This function computes the discrete logarithm equality proof for the variables $gh^{pbsk.sk}$ and $h\_sumR^{pbsk.sk}$, with Sha256
#[pyfunction]
fn sigma_eq_dlog_proof_sha256(sum_tokens: &Token, pbsk : &PbSk,gh : &GH, h_sumR: &Commit)-> PyResult<String>{
    let witness = &pbsk.sk;
    let pk_l = &gh.H * witness;
    let pk_r = &h_sumR.out * witness;
    let dlog_eq_proof = DLogEqProof::<Bn254,Sha256>::prove(&witness, &h_sumR.out, &gh.H);
    let mut results = DLogEqProof::verify(&dlog_eq_proof, &h_sumR.out, &gh.H).is_ok();
    if (dlog_eq_proof.pk_l!=sum_tokens.out)
    {
        assert!(false);
    }
    let ser_proof = serde_json::to_string_pretty(&dlog_eq_proof).unwrap();
    Ok(ser_proof)
}

// This function computes the discrete logarithm equality proof for the variables $gh1^{v}$ and $gh2\_sumR^{v}$, with Sha256
#[pyfunction]
fn sigma_eq_dlog_same_secret(v: i32 , gh1: &GH, gh2: &GH)->PyResult<String>{
    let val = Scalar::<Bn254>::from(v);
    let dlog_eq_proof = DLogEqProof::<Bn254, Sha256>::prove(&val, &gh1.G, &gh2.G);
    let ser_proof = serde_json::to_string_pretty(&dlog_eq_proof).unwrap();
    Ok(ser_proof)
}

// This function computes the range proof positive commitment that demonstrates knowledge of v such that the commitments are consistent with v without revealing x itself, with Sha256
#[pyfunction]
fn sigma_eq_dlog_ped_proof(v: i32 , gh1: &GH, gh2: &GH, pk: String)->PyResult<String>{
    let val = Scalar::<Bn254>::from(v);
    let point_pk: Point<Bn254> = parse_string_to_scep256k1point(&pk);
    let dlog_eq_proof_ped = DLogEqProofPed::<Bn254, Sha256>::prove(&val, &gh1.G, &gh1.H, &point_pk);
    let ser_proof = serde_json::to_string_pretty(&dlog_eq_proof_ped).unwrap();
    Ok(ser_proof)
}

// This function computes the range proof positive commitment that demonstrates knowledge of v such that the commitments are consistent with v without revealing x itself, with Sha256
// Similar to the function without witness, but additionally provide witness to all point multiplication results.
#[pyfunction]
fn sigma_eq_dlog_ped_proof_with_witness(v: i32 , gh1: &GH, gh2: &GH, pk: String)->PyResult<String>{
    let val = Scalar::<Bn254>::from(v);
    let point_pk: Point<Bn254> = parse_string_to_scep256k1point(&pk);
    let dlog_eq_proof_ped = DLogEqProofPed::<Bn254, Sha256>::prove(&val, &gh1.G, &gh1.H, &point_pk);
    // let ser_proof = serde_json::to_string_pretty(&dlog_eq_proof_ped).unwrap();
    let mul_witness = DLogEqProofPed::<Bn254,Sha256>::generate_mul_witness(&dlog_eq_proof_ped,&gh1.G, &gh1.H);
    let mut ser_proof_json = serde_json::to_value(&dlog_eq_proof_ped).unwrap();
    let ser_mul_witness_json = serde_json::to_value(&mul_witness).unwrap();
    ser_proof_json.merge(&ser_mul_witness_json);
    let ser_proof = serde_json::to_string_pretty(&ser_proof_json).unwrap();
    Ok(ser_proof)
}

// This function verifies the proof generated by function 'sigma_eq_dlog_proof_sha256', whether gh1^(r-c*sk)*gh1^sk^c =? gl^r and gh2^(r-c*sk)*gh2^sk^c =? gh2^r based on the ser_dlog_eq_proof, with Sha256
#[pyfunction]
fn sigma_eq_dlog_verify_same_secret(ser_dlog_eq_proof: String, gh1: &GH, gh2: &GH)-> PyResult<bool>{
    let deserialized_proof: DLogEqProof::<Bn254,Sha256> = serde_json::from_str(&ser_dlog_eq_proof).unwrap();
    let mut results = DLogEqProof::verify(&deserialized_proof, &gh1.G, &gh2.G).is_ok();
    Ok(results)
}

// This function verifies the range proof positive commitment generated by function 'sigma_eq_dlog_ped_proof' based on the ser_dlog_eq_proof proof, such as challenge_response, challenges and cms, with Sha256
#[pyfunction]
fn sigma_eq_dlog_ped_verify(ser_dlog_eq_proof: String, gh1: &GH, gh2: &GH)-> PyResult<bool>{
    let deserialized_proof: DLogEqProofPed::<Bn254,Sha256> = serde_json::from_str(&ser_dlog_eq_proof).unwrap();
    let mut results = DLogEqProofPed::verify(&deserialized_proof, &gh1.G, &gh1.H).is_ok();
    Ok(results)
}

// This function verifies the generated proof based on the ser_dlog_eq_proof, to verify  gh^(r-c*sk) * gh^sk^c =? gh^r and h_sumRr^(r-c*sk) * h_sumR^sk^c =? h_sumR^r, with Sha512
#[pyfunction]
fn sigma_eq_dlog_verify(ser_dlog_eq_proof: String, gh : &GH, h_sumR: &Commit, sum_tokens: &Token)-> PyResult<bool>{
    let deserialized_proof: DLogEqProof::<Bn254,Sha512> = serde_json::from_str(&ser_dlog_eq_proof).unwrap();
    let mut results = DLogEqProof::verify(&deserialized_proof, &h_sumR.out, &gh.H).is_ok();
    if (deserialized_proof.pk_l!=sum_tokens.out)
    {
        assert!(false);
    }
    Ok(results)
}

// This function verifies the generated proof based on the ser_dlog_eq_proof, to verify  gh^(r-c*sk) * gh^sk^c =? gh^r and h_sumRr^(r-c*sk) * h_sumR^sk^c =? h_sumR^r, with Sha256
#[pyfunction]
fn sigma_eq_dlog_verify_sha256(ser_dlog_eq_proof: String, gh : &GH, h_sumR: &Commit, sum_tokens: &Token)-> PyResult<bool>{
    let deserialized_proof: DLogEqProof::<Bn254,Sha256> = serde_json::from_str(&ser_dlog_eq_proof).unwrap();
    let mut results = DLogEqProof::verify(&deserialized_proof, &h_sumR.out, &gh.H).is_ok();
    if (deserialized_proof.pk_l!=sum_tokens.out)
    {
        assert!(false);
    }
    Ok(results)
}


// // This function creates the range proof (prove the value is under a certain range) and verify the proof
#[pyfunction]
fn range_proof_test(n_bit: usize, val: i32)-> PyResult<String> {
    let n = n_bit;
    // batch size
    let m = 1;
    let nm = n * m;
    // some seed for generating g and h vectors
    let KZen: &[u8] = &[75, 90, 101, 110];
    let kzen_label = BigInt::from_bytes(KZen);

    // G,H - points for pederson commitment: com  = vG + rH
    let G = Point::<Bn254>::generator();
    let label = BigInt::from(1);
    let hash = Sha512::new().chain_bigint(&label).result_bigint();
    let H = generate_random_point(&Converter::to_bytes(&hash));

    let g_vec = (0..nm)
        .map(|i| {
            let kzen_label_i = BigInt::from(i as u32) + &kzen_label;
            let hash_i = Sha512::new().chain_bigint(&kzen_label_i).result_bigint();
            generate_random_point(&Converter::to_bytes(&hash_i))
        })
        .collect::<Vec<Point<Bn254>>>();

    // can run in parallel to g_vec:
    let h_vec = (0..nm)
        .map(|i| {
            let kzen_label_j = BigInt::from(n as u32) + BigInt::from(i as u32) + &kzen_label;
            let hash_j = Sha512::new().chain_bigint(&kzen_label_j).result_bigint();
            generate_random_point(&Converter::to_bytes(&hash_j))
        })
        .collect::<Vec<Point<Bn254>>>();

    let range = BigInt::from(2).pow(n as u32);
    //println!("{}",range);
    let v_vec = (0..m)
        .map(|_| Scalar::<Bn254>::from(val))
        .collect::<Vec<Scalar<Bn254>>>();
    //println!("{:#?}",v_vec);
    let r_vec = (0..m)
        .map(|_| Scalar::<Bn254>::random())
        .collect::<Vec<Scalar<Bn254>>>();

    let ped_com_vec =   (0..m)
        .map(|i| &*G * &v_vec[i] + &H * &r_vec[i])
        .collect::<Vec<Point<Bn254>>>();

    println!("{:#?}",ped_com_vec);

    let range_proof = RangeProof::prove(&g_vec, &h_vec, &G, &H, v_vec, &r_vec, n);
    let result = RangeProof::verify(&range_proof, &g_vec, &h_vec, &G, &H, &ped_com_vec, n);
    println!("results");
    println!("{}",result.is_ok());
    assert!(result.is_ok());
    Ok((n_bit).to_string())
}

#[pyfunction]
fn ghvec(n_bit: usize)-> PyResult<String> {
    let n = n_bit;
    // batch size
    let m = 1;
    let nm = n * m;
    // some seed for generating g and h vectors
    let KZen: &[u8] = &[75, 90, 101, 110];
    let kzen_label = BigInt::from_bytes(KZen);
    // G,H - points for pederson commitment: com  = vG + rH
    let g_vec = (0..nm)
        .map(|i| {
            let kzen_label_i = BigInt::from(i as u32) + &kzen_label;
            let hash_i = Sha512::new().chain_bigint(&kzen_label_i).result_bigint();
            generate_random_point(&Converter::to_bytes(&hash_i))
        })
        .collect::<Vec<Point<Bn254>>>();
    // can run in parallel to g_vec:
    let h_vec = (0..nm)
        .map(|i| {
            let kzen_label_j = BigInt::from(n as u32) + BigInt::from(i as u32) + &kzen_label;
            let hash_j = Sha512::new().chain_bigint(&kzen_label_j).result_bigint();
            generate_random_point(&Converter::to_bytes(&hash_j))
        })
        .collect::<Vec<Point<Bn254>>>();

    Ok("[".to_owned() +  &(serde_json::to_string_pretty(&g_vec).unwrap())  +  "," + &(serde_json::to_string_pretty(&h_vec).unwrap())  + "]")
}

// This function creates the range proof (prove the value is under a certain range)
#[pyfunction]
fn range_proof_single(n_bit: usize, val: i32, gh : &GH, r: &rand_r)-> PyResult<String> {
    let n = n_bit;
    // batch size
    let m = 1;
    let nm = n * m;
    // some seed for generating g and h vectors
    let KZen: &[u8] = &[75, 90, 101, 110];
    let kzen_label = BigInt::from_bytes(KZen);
    // G,H - points for pederson commitment: com  = vG + rH
    let g_vec = (0..nm)
        .map(|i| {
            let kzen_label_i = BigInt::from(i as u32) + &kzen_label;
            let hash_i = Sha512::new().chain_bigint(&kzen_label_i).result_bigint();
            generate_random_point(&Converter::to_bytes(&hash_i))
        })
        .collect::<Vec<Point<Bn254>>>();
    // can run in parallel to g_vec:
    let h_vec = (0..nm)
        .map(|i| {
            let kzen_label_j = BigInt::from(n as u32) + BigInt::from(i as u32) + &kzen_label;
            let hash_j = Sha512::new().chain_bigint(&kzen_label_j).result_bigint();
            generate_random_point(&Converter::to_bytes(&hash_j))
        })
        .collect::<Vec<Point<Bn254>>>();

    let range = BigInt::from(2).pow(n as u32);
    //println!("{}",range);
    let v_vec = (0..m)
        .map(|_| Scalar::<Bn254>::from(val))
        .collect::<Vec<Scalar<Bn254>>>();
    //println!("{:#?}",v_vec);
    let r_vec = (0..m)
        .map(|_| &r.out+&Scalar::<Bn254>::from(0))
        .collect::<Vec<Scalar<Bn254>>>();

    let ped_com_vec =   (0..m)
        .map(|i| &gh.G * &v_vec[i] + &gh.H * &r_vec[i])
        .collect::<Vec<Point<Bn254>>>();
    //println!("{:#?}",ped_com_vec);
    let range_proof = RangeProof::prove(&g_vec, &h_vec, &gh.G, &gh.H, v_vec, &r_vec, n);
    let ser_proof = serde_json::to_string_pretty(&range_proof).unwrap();
    //let result = RangeProof::verify(&range_proof, &g_vec, &h_vec, &gh.G, &gh.H, &ped_com_vec, n);
    Ok(ser_proof)
}

// This function verifies the range proof (prove the value is under a certain range), to be specific, verifies the proof $:g^v h^r  0 < v < 2^n$.
#[pyfunction]
fn  range_proof_single_verify(range_proof: String, n_bit: usize, gh : &GH, ped_cm: &Commit)-> bool{
    let n = n_bit;
    // batch size
    let m = 1; // in single we will use one
    let nm = n * m;
    // some seed for generating g and h vectors
    let KZen: &[u8] = &[75, 90, 101, 110];
    let kzen_label = BigInt::from_bytes(KZen);
    let g_vec = (0..nm)
        .map(|i| {
            let kzen_label_i = BigInt::from(i as u32) + &kzen_label;
            let hash_i = Sha512::new().chain_bigint(&kzen_label_i).result_bigint();
            generate_random_point(&Converter::to_bytes(&hash_i))
        })
        .collect::<Vec<Point<Bn254>>>();
    // can run in parallel to g_vec:
    let h_vec = (0..nm)
        .map(|i| {
            let kzen_label_j = BigInt::from(n as u32) + BigInt::from(i as u32) + &kzen_label;
            let hash_j = Sha512::new().chain_bigint(&kzen_label_j).result_bigint();
            generate_random_point(&Converter::to_bytes(&hash_j))
        })
        .collect::<Vec<Point<Bn254>>>();
    let cm = &ped_cm.out;
    let ped_com_vec =   (0..m)
        .map(|i| cm+cm*Scalar::<Bn254>::from(0))
        .collect::<Vec<Point<Bn254>>>();

    let deserialized_proof: RangeProof = serde_json::from_str(&range_proof).unwrap();
    let mut results = RangeProof::verify(&deserialized_proof, &g_vec, &h_vec, &gh.G, &gh.H, &ped_com_vec, n);
    results.is_ok()
}


//  This function computes the Proof of consistency which asserts that for a given commitment and token, it is of the form of $ com = g^vh^r, tk = pk^r$, it has the same r committed in cm and token in tk.
#[pyfunction]
fn  consistency_proof(val: i32, r:&rand_r, gh : &GH, ped_cm: &Commit, token: &Token, pubkey: String)-> PyResult<String>{
    let v = Scalar::<Bn254>::from(val);
    let pubkey_point: Point<Bn254> = parse_string_to_scep256k1point(&pubkey);
    let proof = ConsistencyProof::<Bn254,Sha256>::prove(&v, &r.out, &gh.G, &gh.H, &ped_cm.out, &pubkey_point, &token.out);
    let mut results = ConsistencyProof::verify(&proof, &gh.G, &gh.H, &ped_cm.out, &pubkey_point, &token.out).is_ok();
    let ser_proof = serde_json::to_string_pretty(&proof).unwrap();
    Ok(ser_proof)
}

//  This function computes the Proof of consistency which asserts that for a given commitment and token, it is of the form of $ com = g^vh^r, tk = pk^r$, it has the same r committed in cm and token in tk.
//  Similar to the function without witness, but additionally provide witness to all point multiplication results.
#[pyfunction]
fn  consistency_proof_with_witness(val: i32, r:&rand_r, gh : &GH, ped_cm: &Commit, token: &Token, pubkey: String)-> PyResult<String>{
    let v = Scalar::<Bn254>::from(val);
    let pubkey_point: Point<Bn254> = parse_string_to_scep256k1point(&pubkey);
    let proof = ConsistencyProof::<Bn254,Sha256>::prove(&v, &r.out, &gh.G, &gh.H, &ped_cm.out, &pubkey_point, &token.out);
    let mul_witness = ConsistencyProof::<Bn254,Sha256>::generate_mul_witness(&proof,&v, &r.out, &gh.G, &gh.H, &pubkey_point, &token.out);
    let mut results = ConsistencyProof::verify(&proof, &gh.G, &gh.H, &ped_cm.out, &pubkey_point, &token.out).is_ok();
    let mut ser_proof_json = serde_json::to_value(&proof).unwrap();
    let ser_mul_witness_json = serde_json::to_value(&mul_witness).unwrap();
    ser_proof_json.merge(&ser_mul_witness_json);
    let ser_proof = serde_json::to_string_pretty(&ser_proof_json).unwrap();
    Ok(ser_proof)
}

//  This function verifies the Proof of consistency generated by the function consistency_proof
#[pyfunction]
fn  consistency_proof_verify(proof: String, gh : &GH, ped_cm: &Commit, token: &Token, pubkey: String)-> PyResult<bool>{
    let deserialized_proof: ConsistencyProof::<Bn254,Sha256> = serde_json::from_str(&proof).unwrap();
    let pubkey_point: Point<Bn254> = parse_string_to_scep256k1point(&pubkey);
    let mut results = ConsistencyProof::verify(&deserialized_proof, &gh.G, &gh.H, &ped_cm.out, &pubkey_point, &token.out).is_ok();
    Ok(results)
}

// This function parses a string representation of a point on the Bn254 curve 'str_point' into a Point<Bn254> object using the serde_json library
fn parse_string_to_scep256k1point(str_point: &String)->Point<Bn254>{
    let mut s = "{\"curve\":\"bn254\",\"point\":\"".to_owned() + str_point + "\"}";
    let point_a: Point<Bn254> = serde_json::from_str(&s).unwrap();
    return point_a;
}

// This function parses a string representation of a point on the Bn254 curve 'str_point' into a Scalar<Bn254> object using the serde_json library
fn parse_string_to_scep256k1scalar(str_point: &String)->Scalar<Bn254>{
    let mut s = "{\"curve\":\"bn254\",\"scalar\":\"".to_owned() + str_point + "\"}";
    let scalar_a: Scalar<Bn254> = serde_json::from_str(&s).unwrap();
    return scalar_a;
}

// This function converts a Point<Bn254> object 'point_a' into a string representation of the point
fn parse_scep256k1point_to_string(point_a: &Point<Bn254>)->String {
    let point_json = serde_json::to_string_pretty(point_a).unwrap();
    let v = serde_json::from_str::<serde_json::Value>(&point_json).unwrap();
    //println!("{:?}", v["point"].as_str().unwrap());
    return v["point"].as_str().unwrap().to_owned();
}

// This function converts a Scalar<Bn254> object 'point_a' into a string representation of the point
fn parse_scep256k1scalar_to_string(point_a: &Scalar<Bn254>)->String {
    let point_json = serde_json::to_string_pretty(point_a).unwrap();
    let v = serde_json::from_str::<serde_json::Value>(&point_json).unwrap();
    return v["scalar"].as_str().unwrap().to_owned();
}

#[pyclass]
struct Commit {
    out: Point<Bn254>,
}
#[pymethods]
impl Commit {

    // This function converts the point 'self.out' to a string using the function parse_scep256k1point_to_string.
    #[getter]
    fn get(&self) -> PyResult<String> {
        let point_json = parse_scep256k1point_to_string(&self.out);
        Ok(point_json)
    }
    // This function converts the point 'self.out' to a string using the function parse_scep256k1point_to_string.
    #[getter]
    fn to_str(&self) -> PyResult<String> {
        let point_json = parse_scep256k1point_to_string(&self.out);
        Ok(point_json)
    }
    // This function checks the self.out point is zero and returns a boolean
    fn is_zero(&self) -> PyResult<bool> {
        Ok(self.out.is_zero())
    }
    // Adds the out field of two Commit instances and returns a new Commit instance with the result.
    fn sum(&self, c: &Commit) -> PyResult<Py<PyAny>> {
        let gil = Python::acquire_gil();
        let py = gil.python();
        let s = &self.out + &c.out;
        let pyref = PyCell::new(py, Commit { out: s})?;
        Ok(pyref.to_object(py))
    }
    // Subtracts the out field of two Commit instances and returns a new Commit instance with the result.
    fn sub(&self,  c: &Commit) -> PyResult<Py<PyAny>> {
        let gil = Python::acquire_gil();
        let py = gil.python();
        let s = &self.out - &c.out;
        //println!("{:#?}",s);
        let pyref = PyCell::new(py, Commit { out: s})?;
        Ok(pyref.to_object(py))
    }
    // This function checks the self.out point is zero and returns a boolean
    #[getter]
    fn x(&self) -> PyResult<String> {
        Ok(self.out.x_coord().unwrap().to_string())
    }
     #[getter]
    fn y(&self) -> PyResult<String> {
        Ok(self.out.y_coord().unwrap().to_string())
    }
    fn to_bytes(&self) -> PyResult<[u8;64]> {
        Ok(self.out.to_bytes(false)[..].try_into().unwrap())
    }
    fn from_bytes(&self, a : [u8;32]) -> PyResult<String> {
        Ok(format!("{:?}",Scalar::<Bn254>::from_bytes(&a).unwrap().to_bigint()))
    }
}


#[pyclass]
struct rand_r {
    out: Scalar<Bn254>,
}

#[pymethods]
impl rand_r {
    // This function adds the out field of two rand_r instances and returns a new rand_r instance with the result.
    fn sum(&self, r: &rand_r) -> PyResult<Py<PyAny>> {
        Python::with_gil(|py| -> PyResult<Py<PyAny>> {
            let s = &self.out + &r.out;
            let pyref = PyCell::new(py, rand_r { out: s})?;
            Ok(pyref.to_object(py))})
    }
    // This function subtracts  the out field of two rand_r instances and returns a new rand_r instance with the result.
    fn sub(&self, r: &rand_r) -> PyResult<Py<PyAny>> {
        Python::with_gil(|py| -> PyResult<Py<PyAny>> {
            let s = &self.out - &r.out;
            let pyref = PyCell::new(py, rand_r { out: s})?;
            Ok(pyref.to_object(py))})
    }
    // This function negates the out field and returns a new rand_r instance with the result.
    fn neg(&self) -> PyResult<Py<PyAny>> {
        Python::with_gil(|py| -> PyResult<Py<PyAny>> {
            let s = Scalar::<Bn254>::from(0) - &self.out;
            //println!("{:#?}",s);
            let pyref = PyCell::new(py, rand_r { out: s})?;
            Ok(pyref.to_object(py))})
    }
    // This function converts the scalar 'self.out' to a string based on function parse_scep256k1scalar_to_string
    #[getter]
    fn get(&self) -> PyResult<String> {
        let point_json = parse_scep256k1scalar_to_string(&self.out);
        Ok(point_json)
    }
    // This function checks if the out scalar is zero and returns a boolean.
    fn is_zero(&self) -> PyResult<bool> {
        Ok(self.out.is_zero())
    }

    #[getter]
    fn to_string(&self) -> PyResult<String> {
        let point_json = parse_scep256k1scalar_to_string(&self.out);
        Ok(point_json)
    }

}

#[pyfunction]
fn curve_name() -> PyResult<String>
{
    Ok(("Bn254").to_string())
}


// This function generates a random scalar r of type Scalar<Bn254> and returns a new rand_r instance wrapped in a Python object.
#[pyfunction]
fn gen_r() -> PyResult<Py<PyAny>> {
    let r = Scalar::<Bn254>::random();
    let gil = Python::acquire_gil();
    let py = gil.python();
    let pyref = PyCell::new(py, rand_r { out: r})?;
    Ok(pyref.to_object(py))
}

//This function creates a commitment using a value val, a random scalar r, and a struct GH containing generators G and H and returns a new Commit instance wrapped in a Python object.
#[pyfunction]
fn commit(val : i32, r: &rand_r, gh : &GH ) -> PyResult<Py<PyAny>> {
    let gil = Python::acquire_gil();
    let v = Scalar::<Bn254>::from(val);
    let py = gil.python();
    let comm = &gh.G * &v + &gh.H * &r.out;
    let pyref = PyCell::new(py, Commit { out: comm})?;
    Ok(pyref.to_object(py))
}

//This function converts a string representation of a point into a Commit object and returns a new Commit instance wrapped in a Python object.
#[pyfunction]
fn from_str(str_point: String) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py| -> PyResult<Py<PyAny>> {
        //if  only hex point
        let point_a = parse_string_to_scep256k1point(&str_point);
        let pyref = PyCell::new(py, Commit { out: point_a})?;
        Ok(pyref.to_object(py))})
}

#[pyfunction]
fn from_coords(x_: String, y_: String) -> PyResult<Py<PyAny>>{
    Python::with_gil(|py| -> PyResult<Py<PyAny>> {
            let x = parse_string_to_scep256k1scalar(&x_);
            let y = parse_string_to_scep256k1scalar(&y_);
            let point = Point::<Bn254>::from_coords(&x.to_bigint(),&y.to_bigint()).unwrap();
            let pyref = PyCell::new(py, Commit { out: point})?;
            Ok(pyref.to_object(py))})
}


//This function converts a string representation of a scalar into a rand_r object and returns a new rand_r instance wrapped in a Python object.
#[pyfunction]
fn to_scalar_from_str(str_scalar: String) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py| -> PyResult<Py<PyAny>> {
        let point_a: Scalar<Bn254> = parse_string_to_scep256k1scalar(&str_scalar);
        let pyref = PyCell::new(py, rand_r { out: point_a})?;
        Ok(pyref.to_object(py))})
}

//This function converts a string representation of a point into a Token object and returns a new Token instance wrapped in a Python object.
#[pyfunction]
fn to_token_from_str(str_point: String) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py| -> PyResult<Py<PyAny>> {
        let point_a: Point<Bn254> = parse_string_to_scep256k1point(&str_point);
        let pyref = PyCell::new(py, Token { out: point_a})?;
        Ok(pyref.to_object(py))})
}

// This function adds the out fields of two Commit objects and returns a new Commit object with the result.
#[pyfunction]
fn add(com_l: &Commit, com_r: &Commit) -> PyResult<Py<PyAny>> {
    let com_sum = &com_l.out + &com_r.out;
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let pyref = PyCell::new(py, Commit { out: com_sum})?;
        Ok(pyref.to_object(py))
    })
}

//#[pyfunction]
//fn scalar_mul_eq_proof(w1: &Commit, w2: &Commit, val: i32) -> PyResult<String> {
//    let v1 = Scalar::<Bn254>::from(ps1);
//    let v2 = Scalar::<Bn254>::from(ps2);
//    let res_mul = &v1 * &v2;
//    let res_mul_str = parse_scep256k1scalar_to_string(&res_mul);
//    Ok(res_mul_str)
//}

// This function substracts the out fields of two Commit objects and returns a new Commit object with the result.
#[pyfunction]
fn sub(com_l: &Commit, com_r: &Commit) -> PyResult<Py<PyAny>> {
    let com_sum = &com_l.out - &com_r.out;
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let pyref = PyCell::new(py, Commit { out: com_sum})?;
        Ok(pyref.to_object(py))
    })
}

// This function adds two commitments represented as strings and returns the result as a string PyResult<String>.
#[pyfunction]
fn add_value_commits(com_l: String, com_r: String) -> PyResult<String> {
    let point_a: Point<Bn254> = parse_string_to_scep256k1point(&com_l);
    let point_b: Point<Bn254> = parse_string_to_scep256k1point(&com_r);
    let com_sum = &point_a + &point_b;
    let point_json = parse_scep256k1point_to_string(&com_sum);
    Ok(point_json)
}

// This function substracts two commitments represented as strings and returns the result as a string PyResult<String>.
#[pyfunction]
fn sub_value_commits(com_l: String, com_r: String) -> PyResult<String> {
    let point_a: Point<Bn254> = parse_string_to_scep256k1point(&com_l);
    let point_b: Point<Bn254> = parse_string_to_scep256k1point(&com_r);
    let com_sub = &point_a - &point_b;
    let point_json = parse_scep256k1point_to_string(&com_sub);
    Ok(point_json)
}

// This function prints the out field of a Commit object to the console and returns a confirmation string.
#[pyfunction]
fn print_commit(com: &Commit) -> PyResult<String> {
    println!("{:#?}",com.out);
    Ok("ok".to_string())
}

#[pyclass]
struct GH {
    H: Point<Bn254>,
    G: Point<Bn254>,
}

#[pymethods]
impl GH {
    // This function provides getter methods to retrieve the string representations of the H point.
    #[getter]
    fn get_h(&self) -> PyResult<String> {
        let point_json = parse_scep256k1point_to_string(&self.H);
        Ok(point_json)
    }
    // This function provides getter methods to retrieve the string representations of the g point.
    #[getter]
    fn get_g(&self) -> PyResult<String> {
        let point_json = parse_scep256k1point_to_string(&self.G);
        Ok(point_json)
    }
}

// This function generates a new GH object with random points G and H and returns a new GH instance wrapped in a Python object.
#[pyfunction]
fn gen_GH() -> PyResult<Py<PyAny>> {
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let h = Point::<Bn254>::generator().into();
        let label = BigInt::from(1);
        let hash = Sha512::new().chain_bigint(&label).result_bigint();
        let g = generate_random_point(&Converter::to_bytes(&hash));
        let pyref = PyCell::new(py, GH{G:g,H:h})?;
        Ok(pyref.to_object(py))
    })
}

// This function creates a new GH object using existing Commit objects for G and H and returns a new GH instance wrapped in a Python object.
#[pyfunction]
fn gen_new_GH(g: &Commit,h: &Commit)  -> PyResult<Py<PyAny>> {
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let mut h2 = h.out.clone();
        let mut g2 = g.out.clone();
        let pyref = PyCell::new(py, GH{G:g2,H:h2})?;
        Ok(pyref.to_object(py))
    })
}

#[pyclass]
struct Token {
    out: Point<Bn254>,
}
#[pymethods]
impl Token {
    // This function provides converts the out field (of type Point) into a JSON string using the parse_scep256k1point_to_string function and returns it wrapped in a Python object.
    #[getter]
    fn get(&self) -> PyResult<String> {
        let point_json = parse_scep256k1point_to_string(&self.out);
        Ok(point_json)
    }

    #[getter]
    fn to_str(&self) -> PyResult<String> {
        let point_json = parse_scep256k1point_to_string(&self.out);
        Ok(point_json)
    }

}



#[pyclass]
struct PbSk {
    sk: Scalar<Bn254>,
    pk: Point<Bn254>,
}
#[pymethods]
impl PbSk {
    // This function multiplies the public key pk with a scalar from a rand_r object to create a Token and returns a new Token instance wrapped in a Python object.
    fn to_token(&self, r: &rand_r) -> PyResult<Py<PyAny>> {
        Python::with_gil(|py|-> PyResult<Py<PyAny>> {
            let token = &self.pk*&r.out;
            let pyref = PyCell::new(py, Token { out: token})?;
            Ok(pyref.to_object(py))
        })
    }
    // This function returns a JSON string representation of the secret key sk based on function parse_scep256k1scalar_to_string.
    fn get_sk(&self) -> PyResult<String> {
        let point_json = parse_scep256k1scalar_to_string(&self.sk);
        Ok(point_json)
    }

    // This function converts the public key (pk) to a JSON string format and returns PyResult<String> containing the string representation of the public key
    fn get_pk(&self) -> PyResult<String> {
        let point_json = parse_scep256k1point_to_string(&self.pk);
        Ok(point_json)
    }
}

// This function generates a new PbSk instance wrapped in a Python object, with a random secret key 'sk' and a corresponding public key 'pk'.
#[pyfunction]
fn gen_pb_sk(gh : &GH) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let sk = Scalar::<Bn254>::random();
        let pk = &gh.H*&sk;
        let pyref = PyCell::new(py, PbSk{sk:sk,pk:pk})?;
        Ok(pyref.to_object(py))
    })
}

// This function generates a new PbSk instance wrapped in a Python object, with a given secret key 'sk' and a generator point 'gh'.
#[pyfunction]
fn regen_pb_sk(gh : &GH, sk : &rand_r) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let sk_res = sk.out.clone();
        let pk = &gh.H* &sk.out;
        let pyref = PyCell::new(py, PbSk{sk:sk_res,pk:pk})?;
        Ok(pyref.to_object(py))
    })
}

// This function generates a new Token instance wrapped in a Python object, with a public key (in string format) 'pk_json_point' and a scalar from rand_r
#[pyfunction]
fn to_token_from_pk(pk_json_point: String, r: &rand_r) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let deser_pk: Point<Bn254> = parse_string_to_scep256k1point(&pk_json_point);
        let token = &deser_pk*&r.out;
        let pyref = PyCell::new(py, Token { out: token})?;
        Ok(pyref.to_object(py))
    })
}

// This function adds the out fields of two Token objects 'token_l' and 'token_r' and generates a new Token instance wrapped in a Python object
#[pyfunction]
fn add_token(token_l: &Token, token_r: &Token) -> PyResult<Py<PyAny>> {
    let token_sum = &token_l.out + &token_r.out;
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let pyref = PyCell::new(py, Token { out: token_sum})?;
        Ok(pyref.to_object(py))
    })
}

// This function substracts the out fields of two Token objects 'token_l' and 'token_r' and generates a new Token instance wrapped in a Python object
#[pyfunction]
fn sub_token(token_l: &Token, token_r: &Token) -> PyResult<Py<PyAny>> {
    let token_sum = &token_l.out - &token_r.out;
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let pyref = PyCell::new(py, Token { out: token_sum})?;
        Ok(pyref.to_object(py))
    })
}

// This function subtracts the out field of a Token from the out field of a Commit and generates a new Token instance wrapped in a Python object
#[pyfunction]
fn sub_commit_token(commit_l: &Commit, token_r: &Token) -> PyResult<Py<PyAny>> {
    let res = &commit_l.out - &token_r.out;
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let pyref = PyCell::new(py, Commit { out: res})?;
        Ok(pyref.to_object(py))
    })
}

// This function adds the out field of a Token from the out field of a Commit and generates a new Token instance wrapped in a Python object
#[pyfunction]
fn add_commit_token(commit_l: &Commit, token_r: &Token) -> PyResult<Py<PyAny>> {
    let res = &commit_l.out + &token_r.out;
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let pyref = PyCell::new(py, Commit { out: res})?;
        Ok(pyref.to_object(py))
    })
}

// This function finds an integer v such that the equation g_sk * v == res holds, using brute force within a specified range (0, range), with Commit, Token, gh.
#[pyfunction]
fn get_brut_v(c: &Commit, t: &Token, gh : &GH, pbsk: &PbSk, range: i32 ) -> PyResult<i32> {
    let res = &c.out*&pbsk.sk - &t.out;
    let g_sk = &gh.G*&pbsk.sk;
    let mut v = -1;
    for v_guess in 0..range {
        let val = Scalar::<Bn254>::from(v_guess);
        if &g_sk * &val == res
        {
            v = v_guess;
            break;
        }
        else if &g_sk * (-&val) == res
        {
            v = -v_guess;
            break;
        }
    };
    Ok(v)
}

#[pyclass]
struct hx {
    out: Point<Bn254>,
}



// This function hashes the out field of a Commit object 'a1' using SHA-256 and returns the hash as a string.
#[pyfunction]
fn hash_test1(a1 : &Commit) -> PyResult<String> {
    println!("a1uncompressed{:#?}",&a1.out.to_bytes(false)[..]);
    Python::with_gil(|py|-> PyResult<String> {
        let res = Sha256::new().chain_point(&a1.out)
            .result_scalar();
        let point_json = parse_scep256k1scalar_to_string(&res);
        Ok(point_json)
    })
}


//  This function hashes the out fields of two Commit objects 'a1' and 'a2' using SHA-256 and returns the hash as a string.
#[pyfunction]
fn hash_test2(a1 : &Commit, a2 : &Commit) -> PyResult<String> {
    println!("a1uncompressed{:#?}",(&a1.out.to_bytes(false)[..]));
    println!("a2uncompressed{:#?}",(&a2.out.to_bytes(false)[..]));
    Python::with_gil(|py|-> PyResult<String> {
        let res = Sha256::new().chain_point(&a1.out)
            .chain_point(&a2.out)
            .result_scalar();
        let point_json = parse_scep256k1scalar_to_string(&res);
        Ok(point_json)
    })
}




//  This function hashes the out fields of three Commit objects 'a1', 'a1' and 'a3' using SHA-256 and returns the hash as a string.
#[pyfunction]
fn hash_test3(a1 : &Commit, a2 : &Commit, a3 : &Commit) -> PyResult<String> {
    println!("a1uncompressed{:#?}",&a1.out.to_bytes(false)[..]);
    println!("a2uncompressed{:#?}",&a2.out.to_bytes(false)[..]);
    println!("a2uncompressed{:#?}",&a3.out.to_bytes(false)[..]);
    Python::with_gil(|py|-> PyResult<String> {
        let res = Sha256::new().chain_point(&a1.out)
            .chain_point(&a2.out)
            .chain_point(&a3.out)
            .result_scalar();
        let point_json = parse_scep256k1scalar_to_string(&res);
        Ok(point_json)
    })
}

// This function extracts the y-coordinate of the out field from a Commit object 'a1' and returns it as a hexadecimal string.
#[pyfunction]
fn get_y_coord(a1 : &Commit) -> PyResult<String> {
    Ok(a1.out.y_coord().expect("None").to_hex())
}


// This function multiplies the out field of a Commit by a scalar from rand_r object and returns the result as a new Commit object.
#[pyfunction]
fn p_to_x(p : &Commit, x: &rand_r) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let p_x = &p.out*&x.out;
        let pyref = PyCell::new(py, Commit{out:p_x})?;
        Ok(pyref.to_object(py))
    })
}

//  This function multiplies the generator point H from a GH object by a scalar from a rand_r object and returns the result as an hx object.
#[pyfunction]
fn h_to_x(gh : &GH, x: &rand_r) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let h_x = &gh.H*&x.out;
        let pyref = PyCell::new(py, hx{out:h_x})?;
        Ok(pyref.to_object(py))
    })
}

//  This function multiplies the generator point G from a GH object by a scalar from a rand_r object and returns the result as a Commit object.
#[pyfunction]
fn g_to_r(gh : &GH, r: &rand_r) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let g_r = &gh.G*&r.out;
        let pyref = PyCell::new(py, Commit{out:g_r})?;
        Ok(pyref.to_object(py))
    })
}


//  This function multiplies the generator point G from a GH object t by an integer value 'val' and returns the result as a Commit object.
#[pyfunction]
fn g_to_x(gh : &GH, val : i32) -> PyResult<Py<PyAny>> {
    Python::with_gil(|py|-> PyResult<Py<PyAny>> {
        let v = Scalar::<Bn254>::from(val);
        let g_x = &gh.G*v;
        let pyref = PyCell::new(py, Commit{out:g_x})?;
        Ok(pyref.to_object(py))
    })
}

//  This function prints the out field of a Token object to the console.
#[pyfunction]
fn print_token(token: &Token) -> PyResult<String> {
    println!("{:#?}",token.out);
    Ok("ok".to_string())
}


#[pymodule]
fn zkbp(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(range_proof_test, m)?)?;
    m.add_function(wrap_pyfunction!(commit, m)?)?;
    m.add_function(wrap_pyfunction!(print_commit, m)?)?;
    m.add_function(wrap_pyfunction!(add, m)?)?;
    m.add_function(wrap_pyfunction!(sub, m)?)?;
    m.add_function(wrap_pyfunction!(add_value_commits, m)?)?;
    m.add_function(wrap_pyfunction!(sub_value_commits, m)?)?;
    m.add_function(wrap_pyfunction!(from_str, m)?)?;
    m.add_function(wrap_pyfunction!(to_token_from_str, m)?)?;
    m.add_function(wrap_pyfunction!(gen_GH, m)?)?;
    m.add_function(wrap_pyfunction!(gen_r, m)?)?;
    m.add_function(wrap_pyfunction!(range_proof_single, m)?)?;
    m.add_function(wrap_pyfunction!(gen_pb_sk, m)?)?;
    m.add_function(wrap_pyfunction!(regen_pb_sk, m)?)?;
    m.add_function(wrap_pyfunction!(to_scalar_from_str, m)?)?;
    m.add_function(wrap_pyfunction!(print_token, m)?)?;
    m.add_function(wrap_pyfunction!(add_token, m)?)?;
    m.add_function(wrap_pyfunction!(sub_token, m)?)?;
    m.add_function(wrap_pyfunction!(sub_commit_token, m)?)?;
    m.add_function(wrap_pyfunction!(add_commit_token, m)?)?;
    m.add_function(wrap_pyfunction!(h_to_x, m)?)?;
    m.add_function(wrap_pyfunction!(g_to_x, m)?)?;
    m.add_function(wrap_pyfunction!(g_to_r, m)?)?;
    m.add_function(wrap_pyfunction!(p_to_x, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_eq_dlog_proof, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_eq_dlog_proof_sha256, m)?)?;
    m.add_function(wrap_pyfunction!(to_token_from_pk, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_eq_dlog_verify, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_eq_dlog_verify_sha256, m)?)?;
    m.add_function(wrap_pyfunction!(range_proof_single_verify, m)?)?;
    m.add_function(wrap_pyfunction!(consistency_proof, m)?)?;
    m.add_function(wrap_pyfunction!(consistency_proof_verify, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_dlog_proof_explicit, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_dlog_proof_explicit_verify, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_dlog_proof_explicit_sha256, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_dlog_proof_explicit_verify_sha256, m)?)?;
    m.add_function(wrap_pyfunction!(get_brut_v, m)?)?;
    m.add_function(wrap_pyfunction!(hash_test1, m)?)?;
    m.add_function(wrap_pyfunction!(hash_test2, m)?)?;
    m.add_function(wrap_pyfunction!(hash_test3, m)?)?;
    m.add_function(wrap_pyfunction!(curve_name, m)?)?;
    m.add_function(wrap_pyfunction!(ghvec, m)?)?;
    m.add_function(wrap_pyfunction!(gen_new_GH, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_eq_dlog_same_secret,m)?)?;
    m.add_function(wrap_pyfunction!(sigma_eq_dlog_verify_same_secret,m)?)?;
    m.add_function(wrap_pyfunction!(sigma_eq_dlog_ped_proof,m)?)?;
    m.add_function(wrap_pyfunction!(sigma_eq_dlog_ped_verify,m)?)?;

    //Proof with witness
    m.add_function(wrap_pyfunction!(consistency_proof_with_witness, m)?)?;
    m.add_function(wrap_pyfunction!(sigma_eq_dlog_ped_proof_with_witness,m)?)?;
    m.add_function(wrap_pyfunction!(sigma_dlog_proof_explicit_sha256_with_witness,m)?)?;
    m.add_function(wrap_pyfunction!(from_coords,m)?)?;

    m.add_function(wrap_pyfunction!(get_y_coord, m)?)?;


    m.add_class::<Commit>()?;
    m.add_class::<rand_r>()?;
    m.add_class::<GH>()?;
    m.add_class::<PbSk>()?;
    m.add_class::<hx>()?;
    m.add_class::<Token>()?;

    Ok(())
}




