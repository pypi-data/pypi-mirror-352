# Generated from pot_http.es5.cjs
SCRIPT = '// Example input:\n// var embeddedInputData = {\n//     "port": 12345,\n//     "content_bindings": ["dQw4w9WgXcQ"]\n// };\n// embeddedInputData.ytAtR = JSON.parse(\'\\x7b\\x7d\');\n\n// yt-dlp\'s PhantomJSwrapper relies on\n// `\'phantom.exit();\' in jscode`\n// phantom.exit();\n\nvar globalObj = (typeof globalThis !== \'undefined\') ? globalThis :\n    (typeof global !== \'undefined\') ? global :\n        (typeof window !== \'undefined\') ? window :\n            (typeof self !== \'undefined\') ? self :\n                this;\n\nvar writeError, writeDebug, writeLog, nop = function () { }, exit;\nif (typeof phantomInnerAPI !== \'undefined\') {\n    exit = phantomInnerAPI.exit;\n    writeError = phantomInnerAPI.writeError;\n    writeLog = phantomInnerAPI.writeLog;\n    if (embeddedInputData.NDEBUG) {\n        writeDebug = nop;\n        phantomInnerAPI.disableConsoleMsg();\n    } else {\n        writeDebug = phantomInnerAPI.writeDebug;\n    }\n} else {\n    writeError = function () { return console.trace.apply(console, arguments); };\n    writeDebug = embeddedInputData.NDEBUG ? nop : function () { return console.debug.apply(console, arguments); };\n    writeLog = function () { return console.log.apply(console, arguments); };\n    if (typeof phantom !== \'undefined\')\n        exit = function () { return phantom.exit.apply(phantom, arguments); };\n    else if (typeof process !== \'undefined\') {\n        exit = function () { return process.exit.apply(process, arguments); };\n        var JSDOM = require(\'jsdom\').JSDOM;\n        var dom = new JSDOM(\'<!DOCTYPE html><html lang="en"><head><title></title></head><body></body></html>\', {\n            url: \'https://www.youtube.com/\',\n            referrer: \'https://www.youtube.com/\',\n            userAgent: \'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36(KHTML, like Gecko)\'\n        });\n\n        Object.assign(globalObj, {\n            window: dom.window,\n            document: dom.window.document,\n            location: dom.window.location,\n            origin: dom.window.origin\n        });\n\n        if (!Reflect.has(globalObj, \'navigator\'))\n            Object.defineProperty(globalObj, \'navigator\', { value: dom.window.navigator });\n        // for debugging\n        embeddedInputData.port = process.args && process.args[2] || 3200;\n    }\n    else\n        exit = nop;\n}\n\n// Currently, we only support fetch for a custom UA\n// TODO: do requests natively\nvar doRequestsNatively = typeof fetch === \'function\';\n\nfunction compatFetch(resolve, reject, url, req) {\n    req = req || {};\n    req.method = req.method ? req.method.toUpperCase() : (req.body ? \'POST\' : \'GET\');\n    req.headers = req.headers || {};\n    req.body = req.body || null;\n    if (typeof fetch === \'function\') {\n        writeDebug(\'FETCH\', url);\n        fetch(url, req).then(function (response) {\n            return {\n                ok: response.ok,\n                status: response.status,\n                url: response.url,\n                text: function (resolveInner, rejectInner) {\n                    response.text().then(resolveInner).catch(rejectInner);\n                },\n                json: function (resolveInner, rejectInner) {\n                    response.json().then(resolveInner).catch(rejectInner);\n                },\n                headers: {\n                    get: response.headers.get,\n                    _raw: response.headers\n                }\n            };\n        }).then(resolve).catch(reject);\n    } else if (typeof XMLHttpRequest !== \'undefined\') {\n        writeDebug(\'XHR\', url);\n        xhr = new XMLHttpRequest();\n        xhr.open(req.method, url, true);\n        for (var hdr in req.headers) {\n            if (hdr.toLowerCase() === \'user-agent\') return reject(\'UA not supported\');\n            xhr.setRequestHeader(hdr, req.headers[hdr]);\n        }\n        var doneCallbacks = [];\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 2) {\n                resolve({\n                    ok: (xhr.status >= 200 && xhr.status < 300),\n                    status: xhr.status,\n                    url: xhr.responseUrl,\n                    text: function (resolveInner, rejectInner) {\n                        doneCallbacks.push(resolveInner);\n                    },\n                    json: function (resolveInner, rejectInner) {\n                        doneCallbacks.push(function (responseText) {\n                            var parsed;\n                            try {\n                                parsed = JSON.parse(responseText);\n                            } catch (err) {\n                                return rejectInner(err);\n                            }\n                            resolveInner(parsed);\n                        });\n                    },\n                    headers: {\n                        get: function (name) {\n                            return xhr.getResponseHeader(name);\n                        },\n                        _raw: xhr.getAllResponseHeaders()\n                    }\n                });\n            } else if (xhr.readyState === 4) {\n                doneCallbacks = doneCallbacks.filter(function (x) {\n                    if (typeof x === \'function\')\n                        x(xhr.responseText);\n                    return false;\n                });\n            }\n        };\n        xhr.onerror = function () {\n            reject(new Error(\'XHR failed\'));\n        };\n\n        if (req && typeof req.timeout === \'number\') {\n            xhr.timeout = req.timeout;\n        }\n\n        xhr.ontimeout = function () {\n            reject(new Error(\'XHR timed out\'));\n        };\n\n        try {\n            xhr.send(req.body);\n        } catch (err) {\n            reject(err);\n        }\n    } else {\n        reject(new Error(\'Could not find available networking API.\'));\n    }\n}\n\nvar base64urlToBase64Map = {\n    \'-\': \'+\',\n    _: \'/\',\n    \'.\': \'=\'\n};\n\nvar base64urlCharRegex = /[-_.]/g;\n\nfunction b64ToUTF8Arr(b64) {\n    var b64Mod;\n\n    if (base64urlCharRegex.test(b64)) {\n        b64Mod = base64.replace(base64urlCharRegex, function (match) {\n            return base64urlToBase64Map[match];\n        });\n    } else {\n        b64Mod = b64;\n    }\n    var b64Mod = atob(b64Mod);\n    var ret = [];\n    b64Mod.split(\'\').forEach(function (chr) {\n        ret.push(chr.charCodeAt(0));\n    });\n    return ret;\n}\n\nfunction UTF8ArrToB64(u8, b64Url) {\n    b64Url = (typeof b64Url === \'undefined\') ? false : b64Url;\n    var str = \'\';\n    Array.prototype.forEach.call(u8, function (chrCode) {\n        str += String.fromCharCode(chrCode);\n    });\n    var result = btoa(str);\n    if (b64Url) {\n        return result\n            .replace(/\\+/g, \'-\')\n            .replace(/\\//g, \'_\');\n    }\n    return result;\n}\n\nfunction encodeASCII(str) {\n    var ret = [];\n    str.split(\'\').forEach(function (chr) {\n        ret.push(chr.charCodeAt(0));\n    });\n    return ret;\n}\n\nfunction buildPOTServerURL(path) {\n    return \'http://127.0.0.1:\'.concat(embeddedInputData.port, path);\n}\n\nfunction fetchChallenge(resolve, reject) {\n    if (embeddedInputData.ytAtR !== null) {\n        var interpUrl = embeddedInputData.ytAtR.bgChallenge.interpreterUrl.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue;\n        compatFetch(function (respRaw) {\n            if (!respRaw.ok)\n                return reject(new Error(\'Could not get challenge\'));\n            respRaw.text(function (respText) {\n                var bgChallenge = embeddedInputData.ytAtR.bgChallenge;\n                resolve({\n                    ijs: respText,\n                    uie: bgChallenge.userInteractionElement,\n                    vmn: bgChallenge.globalName,\n                    prg: bgChallenge.program\n                });\n            }, reject);\n        }, reject, \'https:\'.concat(interpUrl));\n    } else {\n        compatFetch(function (respRaw) {\n            if (!respRaw.ok)\n                return reject(new Error(\'Could not get challenge\'));;\n            respRaw.json(function (respJson) {\n                if (!respJson || respJson.error)\n                    return reject(new Error(\'Could not get challenge\' + (respJson && respJson.error && \': \'.concat(respJson.error)) || \'\'));\n                resolve({\n                    ijs: respJson.interpreterJavascript.privateDoNotAccessOrElseSafeScriptWrappedValue,\n                    uie: respJson.userInteractionElement,\n                    vmn: respJson.globalName,\n                    prg: respJson.program\n                });\n            }, reject);\n        }, reject, buildPOTServerURL(\'/descrambled\'));\n    }\n}\n\nfunction load(resolve, reject, vm, program, userInteractionElement) {\n    if (!vm)\n        reject(new Error(\'VM not found\'));\n    if (!vm.a)\n        reject(new Error(\'VM init function not found\'));\n    var vmFns;\n    var asyncResolved = false;\n    var syncResolved = false;\n    var syncSnapshotFunction;\n    function maybeDone() {\n        if (asyncResolved && syncResolved) {\n            resolve({\n                syncSnapshotFunction: syncSnapshotFunction,\n                vmFns: vmFns,\n            });\n        }\n    }\n    function vmFunctionsCallback(asyncSnapshotFunction, shutdownFunction, passEventFunction, checkCameraFunction) {\n        vmFns = {\n            asyncSnapshotFunction: asyncSnapshotFunction,\n            shutdownFunction: shutdownFunction,\n            passEventFunction: passEventFunction,\n            checkCameraFunction: checkCameraFunction\n        };\n        asyncResolved = true;\n        maybeDone();\n    }\n    syncSnapshotFunction = vm.a(program, vmFunctionsCallback, true, userInteractionElement, nop, [[], []])[0];\n    syncResolved = true;\n    maybeDone();\n}\n\nfunction snapshot(resolve, reject, vmFns, args, timeout) {\n    timeout = (typeof timeout === \'undefined\') ? 3000 : timeout;\n    if (!vmFns.asyncSnapshotFunction)\n        return reject(new Error(\'Asynchronous snapshot function not found\'));\n    var timeoutId;\n    var resolved = false;\n    function resolveWrapped(x) {\n        if (resolved) return writeDebug(\'SSHOT_MULTICB RESOLVE\');\n        resolved = true;\n        clearTimeout(timeoutId);\n        writeDebug(\'TYPEOF_WPSO\', typeof args.webPoSignalOutput[0]);\n        resolve(x);\n    }\n    function rejectWrapped(x) {\n        if (resolved) return writeDebug(\'SSHOT_MULTICB REJECT\');\n        resolved = true;\n        clearTimeout(timeoutId);\n        reject(x);\n    }\n    timeoutId = setTimeout(function () {\n        rejectWrapped(new Error(\'VM operation timed out\'));\n    }, timeout);\n    vmFns.asyncSnapshotFunction(resolveWrapped, [\n        args.contentBinding,\n        args.signedTimestamp,\n        args.webPoSignalOutput,\n        args.skipPrivacyBuffer\n    ]);\n}\n\nfunction getWebSafeMinter(resolve, reject, integrityTokenData, webPoSignalOutput) {\n    var getMinter = webPoSignalOutput[0];\n    if (!getMinter)\n        reject(new Error(\'PMD:Undefined\'));\n    if (!integrityTokenData.integrityToken)\n        reject(new Error(\'No integrity token provided\'));\n    var mintCallback = getMinter(b64ToUTF8Arr(integrityTokenData.integrityToken));\n    if (typeof mintCallback !== \'function\')\n        reject(new Error(\'APF:Failed\'));\n    resolve(function (resolveInner, rejectInner, identifier) {\n        var result = mintCallback(encodeASCII(identifier));\n        if (!result)\n            rejectInner(new Error(\'YNJ:Undefined\'));\n        if (!(result instanceof Uint8Array))\n            rejectInner(new Error(\'ODM:Invalid\'));\n        resolveInner(UTF8ArrToB64(result, true));\n    });\n}\n\n(function () {\n    writeDebug(\'FUNC\');\n    var identifiers = embeddedInputData.content_bindings;\n    if (!identifiers.length) {\n        writeLog(\'[]\');\n        exit(0);\n    }\n    fetchChallenge(function (chl) {\n        writeDebug(\'CHL\');\n        if (chl.ijs) {\n            new Function(chl.ijs)();\n        } else {\n            writeError(\'Could not load VM\');\n            exit(1);\n        }\n        writeDebug(\'VM_LOADED\', JSON.stringify(globalObj[chl.vmn]));\n        writeDebug(\'VM_INIT_FN\', globalObj[chl.vmn] && typeof globalObj[chl.vmn].a);\n        load(function (bg) {\n            writeDebug(\'LD\');\n            var webPoSignalOutput = [];\n            snapshot(function (botguardResponse) {\n                writeDebug(\'SSHOT\', botguardResponse);\n                compatFetch(function (integrityTokenResponse) {\n                    writeDebug(\'IT\');\n                    integrityTokenResponse.json(function (integrityTokenJson) {\n                        writeDebug(\'ITJ\', JSON.stringify(integrityTokenJson));\n                        if (!integrityTokenResponse.ok || !integrityTokenJson) {\n                            writeError(\'Failed to get integrity token response:\', (integrityTokenResponse && integrityTokenResponse.error) || \'\')\n                            exit(1);\n                        }\n                        if (typeof integrityTokenJson.integrityToken !== \'string\') {\n                            writeError(\'Could not get integrity token\');\n                            exit(1);\n                        }\n                        getWebSafeMinter(function (webSafeMinter) {\n                            var pots = [];\n                            function exitIfCompleted() {\n                                if (Object.keys(pots).length == identifiers.length) {\n                                    writeLog(JSON.stringify(pots));\n                                    exit(+(pots.indexOf(null) !== -1));\n                                }\n                            }\n                            identifiers.forEach(function (identifier, idx) {\n                                webSafeMinter(function (pot) {\n                                    pots[idx] = pot;\n                                    exitIfCompleted();\n                                }, function (err) {\n                                    writeError(\n                                        \'Failed to mint web-safe POT for identifier \'.concat(identifier, \':\'), err);\n                                    pots[idx] = null;\n                                    exitIfCompleted();\n                                }, identifier);\n                            });\n                        }, function (err) {\n                            writeError(\'Failed to get web-safe minter:\', err);\n                            exit(1);\n                        }, integrityTokenJson, webPoSignalOutput);\n                    }, function (err) {\n                        writeError(\'Failed to parse JSON:\', err);\n                        exit(1);\n                    });\n                }, function (err) {\n                    writeError(\'Failed to fetch integrity token response:\', err);\n                    exit(1);\n                }, buildPOTServerURL(\'/genit\'), {\n                    method: \'POST\',\n                    body: JSON.stringify(botguardResponse)\n                });\n            }, function (err) {\n                writeError(\'Snapshot failed:\', err);\n                exit(1);\n            }, bg.vmFns, { webPoSignalOutput: webPoSignalOutput });\n        }, function (err) {\n            writeError(\'Error loading VM\', err);\n            exit(1);\n        }, globalObj[chl.vmn], chl.prg, chl.uie);\n    }, function (err) {\n        writeError(\'Failed to parse challenge:\', err);\n        exit(1);\n    });\n})();\n'
# Generated from wrapper.cjs
SCRIPT_WRAPPER = '(function () {\n    if (typeof phantom === \'undefined\')\n        throw new Error("This script must be run in phantomjs");\n    var page = require(\'webpage\').create();\n\n    // {\n    //   type: "method name",\n    //   args: variadic: Array or single element,\n    // }\n    page.onCallback = function (data) {\n        var ret = {};\n        if (typeof data !== \'object\' && !Array.isArray(data)) {\n            ret.result = \'error\';\n            ret.error = \'data is not an object\';\n            console.log("onCallback error:", ret.error);\n            return ret;\n        }\n        if (typeof data.type !== \'string\') {\n            ret.result = \'error\';\n            ret.error = \'data.type is not a string\';\n            console.log("onCallback error:", ret.error);\n            return ret;\n        }\n        var fnMap = {\n            exit: function (code) { return phantom.exit(code); },\n            writeError: function () { return console.trace.apply(console, arguments); },\n            writeDebug: function () { return console.debug.apply(console, arguments); },\n            writeLog: function () { return console.log.apply(console, arguments); },\n            disableConsoleMsg: function () { page.onConsoleMessage = undefined; },\n            index: function () { return Object.keys(this); }\n        };\n        var obj = fnMap[data.type];\n        if (typeof obj === \'function\') {\n            ret.result = \'success\';\n            ret.objType = \'function\';\n            ret.value = obj.apply(fnMap, Array.isArray(data.args) ? data.args : [data.args]);\n            return ret;\n        } else if (typeof obj === \'undefined\') {\n            ret.result = \'error\';\n            ret.error = \'object is undefined\';\n            console.log("onCallback error:", ret.error);\n            return ret;\n        } else {\n            ret.result = \'error\';\n            ret.error = \'unknown object type: \'.concat(typeof obj);\n            console.log("onCallback error:", ret.error);\n            return ret;\n        }\n    };\n\n    page.onConsoleMessage = function (msg) {\n        console.log(\'CONSOLE: \' + msg);\n    };\n\n    page.open(\'about:blank\', function (status) {\n        if (status !== \'success\') {\n            console.error(\'Failed to load the page\');\n            phantom.exit();\n            return;\n        }\n        page.setContent(\'<!DOCTYPE html><html lang="en"><head><title></title></head><body></body></html>\', \'https://www.youtube.com/\');\n        page.settings.userAgent = \'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36\';\n\n        page.evaluate(function () {\n            function callHost(method) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                var res = callHost.callPhantom({\n                    \'type\': method,\n                    \'args\': args\n                });\n                if (res.result === \'error\')\n                    throw new Error("callPhantom failure:".concat(res.error));\n                else if (res.result === \'success\')\n                    return res.value;\n                else\n                    throw new Error("callPhanton unknown result: ".concat(res.result));\n            }\n            if (typeof window.callPhantom !== \'function\')\n                throw new Error("could not find window.callPhantom");\n            callHost.callPhantom = window.callPhantom;\n            delete window.callPhantom;\n            var phantomInnerAPI = {};\n            callHost(\'index\').forEach(\n                function (method) {\n                    phantomInnerAPI[method] = function () {\n                        return callHost.apply(null, [method].concat(Array.prototype.slice.call(arguments)));\n                    };\n                }\n            );\n            /*__PLACEHOLDER_REPLACE_WITH_SCRIPT_CONTENT__*/\n        });\n    });\n})();\n'
