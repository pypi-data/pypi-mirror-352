"""
Package management and requirements file utilities.
"""

import json
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List, Set

from ginx.utils import parse_requirements_file

from .version_utils import normalize_package_name, parse_package_line


def get_installed_packages() -> Dict[str, str]:
    """
    Get currently installed packages and their versions.

    Returns:
        Dictionary mapping normalized package names to versions
    """
    try:
        result = subprocess.run(
            [sys.executable, "-m", "pip", "list", "--format=json"],
            check=True,
            text=True,
            capture_output=True,
            encoding="utf-8",
            errors="replace",
        )

        packages = json.loads(result.stdout)
        return {normalize_package_name(pkg["name"]): pkg["version"] for pkg in packages}
    except (subprocess.CalledProcessError, json.JSONDecodeError):
        return {}


def get_packages_from_requirements(requirements_file: str) -> Dict[str, str]:
    """
    Extract packages and versions from a requirements file.

    Args:
        requirements_file: Path to requirements file

    Returns:
        Dictionary mapping normalized package names to versions
    """
    if not Path(requirements_file).exists():
        return {}

    packages: Dict[Any, Any] = {}
    req_packages = parse_requirements_file(requirements_file)

    for pkg_line in req_packages:
        name, _, ver = parse_package_line(pkg_line)
        if name and ver:
            packages[normalize_package_name(name)] = ver

    return packages


def compare_package_sets(packages1: Dict[str, str], packages2: Dict[str, str]) -> Dict[str, Dict[str, str]]:
    """
    Compare two sets of packages and their versions.

    Args:
        packages1: First package set
        packages2: Second package set

    Returns:
        Dictionary with comparison results
    """
    all_packages: Set[str] = set(packages1.keys()) | set(packages2.keys())

    results: Dict[str, Any] = {
        "same": {},
        "different": {},
        "only_in_first": {},
        "only_in_second": {},
    }

    for package in all_packages:
        ver1 = packages1.get(package)
        ver2 = packages2.get(package)

        if ver1 and ver2:
            if ver1 == ver2:
                results["same"][package] = ver1
            else:
                results["different"][package] = {"first": ver1, "second": ver2}
        elif ver1:
            results["only_in_first"][package] = ver1
        elif ver2:
            results["only_in_second"][package] = ver2

    return results


def filter_system_packages(packages: Dict[str, str], exclude_system: bool = True) -> Dict[str, str]:
    """
    Filter out system/built-in packages if requested.

    Args:
        packages: Package dictionary to filter
        exclude_system: Whether to exclude system packages

    Returns:
        Filtered package dictionary
    """
    if not exclude_system:
        return packages

    # Common system packages to exclude
    system_packages = {
        "pip",
        "setuptools",
        "wheel",
        "pip-tools",
        "distlib",
        "packaging",
        "pyparsing",
        "six",
        "certifi",
        "charset-normalizer",
        "idna",
        "requests",
        "urllib3",
        "python-dateutil",
        "pytz",
    }

    return {name: version for name, version in packages.items() if name not in system_packages}


def create_pinned_requirements(packages: Dict[str, str], header_comment: str = "") -> List[str]:
    """
    Create pinned requirements file content from package dictionary.

    Args:
        packages: Dictionary of packages and versions
        header_comment: Optional header comment

    Returns:
        List of requirement lines
    """
    lines: List[str] = []

    if header_comment:
        lines.extend(
            [
                f"# {header_comment}",
                "# Generated by Ginx version-sync plugin",
                "",
            ]
        )

    # Sort packages for consistent output
    for package, version in sorted(packages.items()):
        lines.append(f"{package}=={version}")

    return lines


def get_editable_packages() -> Dict[str, str]:
    """
    Get editable (development) packages from pip list.

    Returns:
        Dictionary mapping package names to their paths
    """
    try:
        result = subprocess.run(
            [sys.executable, "-m", "pip", "list", "--format=json", "--editable"],
            check=True,
            text=True,
            capture_output=True,
            encoding="utf-8",
            errors="replace",
        )

        packages = json.loads(result.stdout)
        return {normalize_package_name(pkg["name"]): pkg.get("location", "unknown") for pkg in packages}
    except (subprocess.CalledProcessError, json.JSONDecodeError):
        return {}


def exclude_editable_packages(packages: Dict[str, str]) -> Dict[str, str]:
    """
    Remove editable packages from package dictionary.

    Args:
        packages: Package dictionary

    Returns:
        Package dictionary without editable packages
    """
    editable = set(get_editable_packages().keys())
    return {name: version for name, version in packages.items() if name not in editable}


def validate_requirements_file(requirements_file: str) -> List[str]:
    """
    Validate a requirements file and return any issues found.

    Args:
        requirements_file: Path to requirements file

    Returns:
        List of validation issues (empty if valid)
    """
    issues: List[str] = []

    if not Path(requirements_file).exists():
        issues.append(f"File does not exist: {requirements_file}")
        return issues

    try:
        req_packages = parse_requirements_file(requirements_file)
        line_num = 0

        for pkg_line in req_packages:
            line_num += 1

            if not pkg_line.strip() or pkg_line.strip().startswith("#"):
                continue

            name, _, ver = parse_package_line(pkg_line)

            if not name:
                issues.append(f"Line {line_num}: Could not parse package name from '{pkg_line}'")
            elif not ver and not pkg_line.startswith("-"):
                issues.append(f"Line {line_num}: Package '{name}' has no version specified")

    except Exception as e:
        issues.append(f"Error reading file: {e}")

    return issues
