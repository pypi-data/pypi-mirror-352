import amsdal_glue as glue
from _typeshed import Incomplete
from amsdal_data.connections.async_sqlite_historical import AsyncSqliteHistoricalConnection as AsyncSqliteHistoricalConnection
from amsdal_data.connections.constants import METADATA_KEY as METADATA_KEY, METADATA_TABLE as METADATA_TABLE, REFERENCE_TABLE as REFERENCE_TABLE, SCHEMA_NAME_FIELD as SCHEMA_NAME_FIELD, SCHEMA_VERSION_FIELD as SCHEMA_VERSION_FIELD, SECONDARY_PARTITION_KEY as SECONDARY_PARTITION_KEY, TRANSACTION_TABLE as TRANSACTION_TABLE
from amsdal_data.connections.historical.command_builder import format_historical_table_name as format_historical_table_name
from amsdal_data.connections.historical.data_query_transform import META_PRIMARY_KEY_FIELDS as META_PRIMARY_KEY_FIELDS
from amsdal_data.connections.historical.schema_version_manager import AsyncHistoricalSchemaVersionManager as AsyncHistoricalSchemaVersionManager, HistoricalSchemaVersionManager as HistoricalSchemaVersionManager
from amsdal_data.connections.postgresql_historical import AsyncPostgresHistoricalConnection as AsyncPostgresHistoricalConnection, PostgresHistoricalConnection as PostgresHistoricalConnection
from amsdal_data.connections.sqlite_historical import SqliteHistoricalConnection as SqliteHistoricalConnection
from amsdal_glue_core.common.data_models.constraints import BaseConstraint as BaseConstraint
from amsdal_utils.models.enums import Versions as Versions
from typing import TypeVar

SchemaT = TypeVar('SchemaT', bound=glue.RegisterSchema | glue.DeleteSchema)

class _BaseSchemaCommandExecutor:
    @staticmethod
    def _check_single_mutation(mutations: list[glue.SchemaMutation]) -> None: ...
    @staticmethod
    def _adjust_to_historical_properties(mutation: glue.RegisterSchema) -> glue.RegisterSchema: ...
    def _set_schema_version(self, mutation: SchemaT, *, force_new_version: bool = False) -> SchemaT: ...
    @staticmethod
    def _exclude_unique_constraints(mutation: glue.RegisterSchema) -> glue.RegisterSchema: ...
    @classmethod
    def _adjust_pk_constraints(cls, mutation: glue.RegisterSchema) -> glue.RegisterSchema: ...
    @classmethod
    def _adjust_fk_constraints(cls, mutation: glue.RegisterSchema) -> glue.RegisterSchema: ...
    @staticmethod
    def _adjust_pk_constraint(constraint: BaseConstraint) -> None: ...

class SchemaCommandExecutor(_BaseSchemaCommandExecutor):
    connection: Incomplete
    schema_command: Incomplete
    schema_version_manager: Incomplete
    def __init__(self, connection: SqliteHistoricalConnection | PostgresHistoricalConnection, schema_command: glue.SchemaCommand) -> None: ...
    def execute(self) -> list[glue.Schema | None]: ...
    def _transform_mutations(self) -> list[glue.RegisterSchema | glue.DeleteSchema]: ...
    def _execute_mutation(self, mutation: glue.RegisterSchema | glue.DeleteSchema) -> list[glue.Schema | None]: ...
    def _transform_change_mutations_to_register(self, mutations: list[glue.ChangeSchema]) -> glue.RegisterSchema: ...
    def _get_existing_schema(self, schema_name: str, schema_version: glue.Version | Versions | str = ...) -> glue.Schema: ...

class AsyncSchemaCommandExecutor(_BaseSchemaCommandExecutor):
    connection: Incomplete
    schema_command: Incomplete
    schema_version_manager: Incomplete
    def __init__(self, connection: AsyncSqliteHistoricalConnection | AsyncPostgresHistoricalConnection, schema_command: glue.SchemaCommand) -> None: ...
    async def execute(self) -> list[glue.Schema | None]: ...
    async def _transform_mutations(self) -> list[glue.RegisterSchema | glue.DeleteSchema]: ...
    async def _execute_mutation(self, mutation: glue.RegisterSchema | glue.DeleteSchema) -> list[glue.Schema | None]: ...
    async def _transform_change_mutations_to_register(self, mutations: list[glue.ChangeSchema]) -> glue.RegisterSchema: ...
    async def _get_existing_schema(self, schema_name: str, schema_version: glue.Version | Versions | str = ...) -> glue.Schema: ...
