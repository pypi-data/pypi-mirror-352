"""
This auxiliary module provides helper functions to build and load simplified
country polygons for the whole world, based on down-sampled `level0_100m`
rasters from WorldPop.
"""

import logging
import warnings
from functools import lru_cache

import geopandas as gpd
import numpy as np
import pandas as pd
import rioxarray  # noqa
import xarray as xr
from pqdm.threads import pqdm
from shapely.geometry import shape

from worldpoppy.config import *
from worldpoppy.config import get_cache_dir, get_max_concurrency
from worldpoppy.manifest import get_all_isos

_border_res_arc_secs = 15
_border_raw_fpath = ASSET_DIR / 'level0_500m_2000_2020_simplified_world.feather'
_border_buffered_fpath = get_cache_dir() / 'level0_500m_2000_2020_simplified_world_buffered.feather'

try:
    from osgeo import gdal  # noqa

    GDAL_AVAILABLE = True
except ModuleNotFoundError:
    GDAL_AVAILABLE = False

logger = logging.getLogger(__name__)


@lru_cache
def load_country_borders():
    """
    Return a GeoDataFrame with simplified, buffered country polygons extracted from
    WorldPop `level0_100m` rasters.

    If the cached border file does not exist, this function will trigger the build
    process.

    Returns
    -------
    geopandas.GeoDataFrame
        A GeoDataFrame with simplified, buffered polygons for all countries and an
        'iso3' column.
    """
    if not _border_buffered_fpath.is_file():
        logger.warning('Buffered country borders not found in cache. Rebuilding...')

        # fetch un-buffered simplified country polygons
        build_country_borders()  # only triggers if cached is not available
        gdf = gpd.read_feather(_border_raw_fpath)

        # Apply a small buffer to country borders equivalent to approx. 1 km
        # at the equator. Doing so will help to avoid empty downstream user
        # queries due to small inaccuracies in the border data. Note that we
        # do not ship buffered country polygons as part of the initial `worldpoppy`
        # installation since they take up much more space than the unbuffered ones.
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            gdf['geometry'] = gdf.buffer(0.01)

        if not np.all(gdf.is_valid):
            raise ValueError('Adding buffer yielded invalid geometries.')
            # workaround: reduce buffer size

        # save the buffered data for re-use
        gdf.to_feather(_border_buffered_fpath)
        logger.warning('Done.')

    return gpd.read_feather(_border_buffered_fpath)


def build_country_borders(overwrite=False):
    """
    Build a GeoDataFrame with country borders for the whole world by converting
    WorldPop `level0_100m` rasters into simplified vector polygons. The output
    is saved to disk as a Feather file for future use.

    Notes
    -----
        - The border data generated by this function is *not* intended for display
          or any geo-data analysis. Its sole purpose is to power raster-data queries
          in `worldpoppy.WorldPopDownloader`.
        - This function requires an installation of `osgeo.gdal`.

    Parameters
    ----------
    overwrite : bool, optional
        If True, force regeneration of the border polygons even if they already
        exist on disk. Default is False.

    Raises
    ------
    ModuleNotFoundError
        If an installation of the optional `ogeo.gdal` library is not available.
    """
    from worldpoppy.download import WorldPopDownloader  # avoid circularity

    if _border_raw_fpath.is_file() and not overwrite:
        return None

    if not GDAL_AVAILABLE:
        raise ModuleNotFoundError(
            "An installation of 'ogeo.gdal' is required to build country borders "
            "from scratch. Please install `gdal` using pip, conda, or mamba."
        )

    all_isos = get_all_isos()

    # download high-resolution country rasters from WorldPop
    _ = WorldPopDownloader().download(
        'level0_100m_2000_2020', iso3_codes=get_all_isos()
    )

    # asynchronously downsample the raster data and convert
    # it into simplified country polygons
    res = pqdm(
        all_isos,
        _extract_simplified_borders,
        n_jobs=get_max_concurrency(),
        desc='Extracting simplified country borders...',
        leave=False
    )

    # concatenate results in a GeoDataFrame
    gdf = gpd.GeoDataFrame(pd.concat(res), crs=WGS84_CRS)

    # simplify country geometries further to save even more disk space
    gdf['geometry'] = gdf.simplify(tolerance=0.005)  # approx. 500 metres tolerance
    if not np.all(gdf.is_valid):
        raise ValueError('Border simplification yielded invalid geometries.')
        # workaround: reduce `tolerance`

    gdf.to_feather(_border_raw_fpath, compression='zstd')


def _extract_simplified_borders(iso3):
    """
    Convert a high-resolution country raster from WorldPop into simplified
    vector polygons by down-sampling and applying `rasterio.features.shapes`.

    Parameters
    ----------
    iso3 : str
        The three-letter ISO code of the country for which to extract
        simplified borders.

    Returns
    -------
    geopandas.GeoDataFrame
        A GeoDataFrame of polygons representing country borders for the given
        ISO code. Includes an 'iso3' column for country identification.
    """
    from osgeo import gdal  # noqa; avoid global dependency
    from rasterio.features import shapes  # noqa; ''

    # convert target resolution to decimal degrees
    tgt_res = 1 / (3600 / _border_res_arc_secs)

    # set raster paths
    in_path = get_cache_dir() / f'level0_100m_2000_2020_{iso3}.tif'
    tmp_path = get_cache_dir() / f'tmp_1km_{iso3}.tif'

    with warnings.catch_warnings():
        warnings.simplefilter('ignore')

        # prepare arguments for gdal.Warp
        opts = gdal.WarpOptions(
            multithread=False,
            format='GTiff',
            options=(
                f'-s_srs {WGS84_CRS} '
                f'-t_srs {WGS84_CRS} '
                f'-r near -tr {tgt_res} {tgt_res}'  # nearest neighbour resampling to target resolution
                '-overwrite '
                '-co BIGTIFF=YES '
            )
        )

        # downsample the country raster
        gdal.Warp(tmp_path, [in_path], options=opts)

        # load the result
        da = xr.open_dataarray(tmp_path, mask_and_scale=True)
        da.rio.write_crs(WGS84_CRS, inplace=True)  # ensure CRS is set

        # extract country polygons
        country_polys = []
        for geom, value in shapes(da.data, transform=da.rio.transform(recalc=True)):
            if np.isfinite(value):
                country_polys.append(shape(geom))

    # convert into a GeoDataFrame
    gdf = gpd.GeoDataFrame(geometry=country_polys, crs=WGS84_CRS)
    gdf['iso3'] = iso3

    # remove the down-sampled country raster
    tmp_path.unlink()

    if not np.all(gdf.is_valid):
        raise ValueError(f'Border extraction for {iso3} yielded invalid geometries.')
        # workaround: reduce `_border_res_arc_secs`

    return gdf
