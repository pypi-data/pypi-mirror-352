# -*- coding: utf-8 -*-
import re
from .odoo_log_parser import OdooLogParser

def mkstrictex(oregex):
    return r'^' + oregex + r'$'

### Bases for other regexes - Should not be compiled:
REGEX_PACKAGE_ODOOMOD_TESTS = r'odoo\.addons\.[^.]+\.tests\..+'
### No-Regexes - To compile:
REGEX_IDENTITY = re.compile( mkstrictex(r'.*') )
### Regexes for filtering log levels - To compile:
REGEX_LOGLVL_INFO = re.compile( mkstrictex(r'INFO') )
REGEX_LOGLVL_ERROR = re.compile( mkstrictex(r'ERROR') )
REGEX_LOGLVLs_INFO_AND_ERROR = re.compile( mkstrictex(r'INFO|ERROR') )
### Regexes for filtering python package names - To compile:
# Hack: Until Odoo17 it's unittest.suite, from Odoo18 on it's odoo.tests.suite.
# TODO:Make the lib truly encode different configurations for different Odoo releases.
REGEX_LOGGER_UNITTEST_SUITE = re.compile( mkstrictex(r'unittest\.suite|odoo\.tests\.suite') )
REGEX_LOGGER_ODOOMOD_TESTS = re.compile( mkstrictex(REGEX_PACKAGE_ODOOMOD_TESTS) )
### Regexes for searching inside entry contents - To compile:
REGEX_BODY_SETUP_ERRORS = re.compile( r'^ERROR: (setUpClass) \(('+REGEX_PACKAGE_ODOOMOD_TESTS+r')\)' )
REGEX_BODY_SETUP_SUCCEEDED = re.compile( mkstrictex(r'Starting +(?P<subpackage>[^ ]+) *\.\.\. *') )
REGEX_BODY_TEST_ERRORS = re.compile( r'^ERROR: ' )
REGEX_BODY_TEST_FAILURES = re.compile( r'^FAIL: ' )

class OdooTestDigest(OdooLogParser):
    def get_full_test_digest(self):
        """
        Generates a test digest for the log file.
        Returns a dictionary in the form:
            {   'db_name': {
                    'tests_succeeded' : [
                        {   'test_path': "odoo.addons.module_name.tests.test_testcase1_file_name.TestCase1ClassName.test_method_1_name",
                            'test_log': "The log of the test. May be take multiple lines.",
                            },
                        {   'test_path': "odoo.addons.module_name.tests.test_testcase1_file_name.TestCase1ClassName.test_method_2_name",
                            'test_log': "The log of the test. May be take multiple lines.",
                            },
                        {   'test_path': "odoo.addons.module_name.tests.test_testcase2_file_name.TestCase2ClassName.test_method_1_name",
                            'test_log': "The log of the test. May be take multiple lines.",
                            },
                        ],
                    'tests_failing' : [
                        {   'test_path': "odoo.addons.module_name.tests.test_testcase1_file_name.TestCase1ClassName.test_method_1_name",
                            'test_log': "The log of the test. May be take multiple lines.",
                            },
                        ],
                    'tests_errors' : [
                        {   'test_path': "odoo.addons.module_name.tests.test_testcase1_file_name.TestCase1ClassName.test_method_1_name",
                            'test_log': "The log of the test. May be take multiple lines.",
                            },
                        ],
                    },
                }
        """
        # Get every database bound log entry:
        test_log = self.parseEntriesByRegexSet([('db_name', REGEX_IDENTITY)])
        # Get a deduplified list of databases:
        db_names = test_log.project('db_name', distinct=True)
        # Parse test lines for each database:
        acc = dict()
        for db_name in db_names:
            db_report = dict()
            ### Get the sublog for this DB and ignore unnecessary log levels:
            db_log = self.parseEntriesByRegexSet([
                ('db_name', re.compile(mkstrictex(db_name))),
                ('log_level', REGEX_LOGLVLs_INFO_AND_ERROR),
                ])
            ### Dump respective testing results:
            # Dump setup errors:
            # TODO: Dump other log entries that are generated by unittest.suite.
            db_log_setuperrors = db_log.parseEntriesByRegexSet([
                ('log_level', REGEX_LOGLVL_ERROR),
                ('logger_name', REGEX_LOGGER_UNITTEST_SUITE),
                ('log_text', REGEX_BODY_SETUP_ERRORS),
                ])
            # Dump test errors:
            db_log_errors = db_log.parseEntriesByRegexSet([
                ('log_level', REGEX_LOGLVL_ERROR),
                ('logger_name', REGEX_LOGGER_ODOOMOD_TESTS ),
                ('log_text', REGEX_BODY_TEST_ERRORS),
                ])
            # Dump test failures:
            db_log_failures = db_log.parseEntriesByRegexSet([
                ('log_level', REGEX_LOGLVL_ERROR),
                ('logger_name', REGEX_LOGGER_ODOOMOD_TESTS ),
                ('log_text', REGEX_BODY_TEST_FAILURES),
                ])
            # Dump succeeded tests:
            db_log_succeeded = db_log.parseEntriesByRegexSet([
                ('log_level', REGEX_LOGLVL_INFO),
                ('logger_name', REGEX_LOGGER_ODOOMOD_TESTS ),
                ('log_text', REGEX_BODY_SETUP_SUCCEEDED),
                ])
            ### Build the testing report from here:
            # Setup errors:
            db_report['setup_errors'] = [
                {   'test_path': REGEX_BODY_SETUP_ERRORS.match(fl['log_text']).expand(r"\2.\1"),
                    'test_log': ( fl['log_text'] ),
                    }
                for fl in db_log_setuperrors.entry_list
                ]
            # Test errors:
            db_report['tests_errors'] = [
                {   'test_path': "%s.%s" % ( fl['logger_name'], fl['log_text'][7:fl['log_text'].index("\n")], ),
                    # TODO: Improve the expression above in order to avoid the magic [6:etc] slicing!
                    'test_log': ( fl['log_text'] ),
                    }
                for fl in db_log_errors.entry_list
                ]
            # Test failures:
            db_report['tests_failing'] = [
                {   'test_path': "%s.%s" % ( fl['logger_name'], fl['log_text'][6:fl['log_text'].index("\n")], ),
                    # TODO: Improve the expression above in order to avoid the magic [6:etc] slicing!
                    'test_log': ( fl['log_text'] ),
                    }
                for fl in db_log_failures.entry_list
                ]
            
            
            # Succeeded tests:
            db_report['tests_succeeded'] = [
                {   'test_path': "%s.%s" % ( fl['logger_name'], REGEX_BODY_SETUP_SUCCEEDED.match(fl['log_text'])['subpackage'], ),
                    # TODO: Improve the expression above in order to avoid the magic [6:etc] slicing!
                    'test_log': ( fl['log_text'] ),
                    }
                for fl in db_log_succeeded.entry_list
                ]
            # Remove repetitions:
            db_report['tests_succeeded'] = [
                ts
                for ts in db_report['tests_succeeded']
                if ts['test_path'] not in [ rec['test_path'] for rec in [
                    *db_report['tests_failing'],
                    *db_report['tests_errors'],
                    *db_report['setup_errors'],
                    ] ]
                ]
            ### Collect the infos:
            acc[db_name] = db_report
        return acc
