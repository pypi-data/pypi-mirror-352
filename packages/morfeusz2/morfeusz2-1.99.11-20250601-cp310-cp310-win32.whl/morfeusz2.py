# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_morfeusz2')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_morfeusz2')
    _morfeusz2 = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_morfeusz2', [dirname(__file__)])
        except ImportError:
            import _morfeusz2
            return _morfeusz2
        try:
            _mod = imp.load_module('_morfeusz2', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _morfeusz2 = swig_import_helper()
    del swig_import_helper
else:
    import _morfeusz2
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


import collections
import os.path

# skopiowane, bo kod sie wkleja na poczatku zamiast na koncu
CONTINUOUS_NUMBERING = _morfeusz2.CONTINUOUS_NUMBERING
CONDITIONALLY_CASE_SENSITIVE = _morfeusz2.CONDITIONALLY_CASE_SENSITIVE
SKIP_WHITESPACES = _morfeusz2.SKIP_WHITESPACES
ANALYSE_ONLY = _morfeusz2.ANALYSE_ONLY
GENERATE_ONLY = _morfeusz2.GENERATE_ONLY
BOTH_ANALYSE_AND_GENERATE = _morfeusz2.BOTH_ANALYSE_AND_GENERATE

__version__ = _morfeusz2._Morfeusz_getVersion()

__copyright__ = _morfeusz2._Morfeusz_getCopyright()

GENDERS = ['m1', 'm2', 'm3', 'f', 'n']


class Morfeusz(object):
    def __init__(self, dict_name=None, dict_path=None,
                 analyse=True, generate=True, expand_dag=False,
                 expand_tags=False, expand_dot=True, expand_underscore=True,
                 aggl=None, praet=None, separate_numbering=True,
                 case_handling=CONDITIONALLY_CASE_SENSITIVE,
                 whitespace=SKIP_WHITESPACES):
        """
        case_handling options:
            CONDITIONALLY_CASE_SENSITIVE, STRICTLY_CASE_SENSITIVE, IGNORE_CASE
        whitespace options:
            SKIP_WHITESPACES, KEEP_WHITESPACES, APPEND_WHITESPACES
        """
        if analyse and generate:
            usage = BOTH_ANALYSE_AND_GENERATE
        elif analyse:
            usage = ANALYSE_ONLY
        elif generate:
            usage = GENERATE_ONLY
        else:
            raise ValueError(
                'At least one of "analyse" and "generate" must be True')
        self.expand_dag = expand_dag
        self.expand_tags = expand_tags
        self.expand_dot = expand_dot
        self.expand_underscore = expand_underscore
        if dict_path:
            self.add_dictionary_path(dict_path)
        if dict_name:
            m = _Morfeusz.createInstance(dict_name, usage)
        else:
            m = _Morfeusz.createInstance(usage)
        self._morfeusz_obj = m
        if aggl:
            m.setAggl(aggl)
        if praet:
            m.setPraet(praet)
        if not separate_numbering:
            m.setTokenNumbering(CONTINUOUS_NUMBERING)
        m.setCaseHandling(case_handling)
        m.setWhitespaceHandling(whitespace)

    def add_dictionary_path(self, dict_path):
        dict_paths = _morfeusz2._Morfeusz_dictionarySearchPaths_get()
        if dict_path not in dict_paths:
            _morfeusz2._Morfeusz_dictionarySearchPaths_set(
                (dict_path,) + dict_paths)

    def _expand_tag(self, tag):
        chunks = [
            GENDERS if chunk == '_' and self.expand_underscore
            else chunk.split('.')
            for chunk in tag.split(':')
        ]

        if not self.expand_dot:
            yield ':'.join('.'.join(values) for values in chunks)
            return

        def expand_chunks(i):
            if i >= len(chunks):
                yield ()
            else:
                tail = tuple(expand_chunks(i + 1))
                for chunk_variant in chunks[i]:
                    for tail_variant in tail:
                        yield (chunk_variant,) + tail_variant

        for x in expand_chunks(0):
            yield ':'.join(x)

    def _expand_interp(self, interp):
        tags = self._expand_tag(interp[2])
        for tag in tags:
            yield (interp[0], interp[1], tag, interp[3], interp[4])

    @staticmethod
    def _dag_to_list(interps):
        dag = collections.defaultdict(list)
        for start, end, interp in interps:
            dag[start].append((interp, end))
        def expand_dag(start):
            nexts = dag[start]
            if not nexts:
                yield []
            else:
                for head, end in nexts:
                    for tail in expand_dag(end):
                        yield [head] + tail
        return list(expand_dag(0))

    def _interp2tuple(self, i):
        m = self._morfeusz_obj
        return i.orth, i.lemma, i.getTag(m), i.getName(m), i.getLabels(m)

    def analyse(self, text):
        m = self._morfeusz_obj
        interps = m.analyse(text)
        interp_tuples = [
            (i.startNode, i.endNode, self._interp2tuple(i)) for i in interps]

        def expand_interps():
            for start, end, interp in interp_tuples:
                for exp_interp in self._expand_interp(interp):
                    yield start, end, exp_interp

        if self.expand_tags:
            interp_tuples = list(expand_interps())
        if self.expand_dag:
            interp_tuples = self._dag_to_list(interp_tuples)
        return interp_tuples

    def generate(self, lemma, tag_id=None):
        m = self._morfeusz_obj
        interps = m.generate(lemma, tag_id)
        interp_tuples = [self._interp2tuple(i) for i in interps]

        def expand_interps():
            for interp in interp_tuples:
                for exp_interp in self._expand_interp(interp):
                    yield exp_interp

        if self.expand_tags:
            interp_tuples = list(expand_interps())
        return interp_tuples

    def dict_id(self):
        return self._morfeusz_obj.getDictID()

    def dict_copyright(self):
        return self._morfeusz_obj.getDictCopyright()

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _morfeusz2.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _morfeusz2.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _morfeusz2.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _morfeusz2.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _morfeusz2.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _morfeusz2.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _morfeusz2.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _morfeusz2.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _morfeusz2.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _morfeusz2.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _morfeusz2.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _morfeusz2.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _morfeusz2.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _morfeusz2.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _morfeusz2.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _morfeusz2.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _morfeusz2.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _morfeusz2.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class InterpsList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, InterpsList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, InterpsList, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _morfeusz2.InterpsList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _morfeusz2.InterpsList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _morfeusz2.InterpsList___bool__(self)

    def __len__(self) -> "std::vector< morfeusz::MorphInterpretation >::size_type":
        return _morfeusz2.InterpsList___len__(self)

    def __getslice__(self, i: 'std::vector< morfeusz::MorphInterpretation >::difference_type', j: 'std::vector< morfeusz::MorphInterpretation >::difference_type') -> "std::vector< morfeusz::MorphInterpretation,std::allocator< morfeusz::MorphInterpretation > > *":
        return _morfeusz2.InterpsList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _morfeusz2.InterpsList___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< morfeusz::MorphInterpretation >::difference_type', j: 'std::vector< morfeusz::MorphInterpretation >::difference_type') -> "void":
        return _morfeusz2.InterpsList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _morfeusz2.InterpsList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< morfeusz::MorphInterpretation >::value_type const &":
        return _morfeusz2.InterpsList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _morfeusz2.InterpsList___setitem__(self, *args)

    def pop(self) -> "std::vector< morfeusz::MorphInterpretation >::value_type":
        return _morfeusz2.InterpsList_pop(self)

    def append(self, x: 'MorphInterpretation') -> "void":
        return _morfeusz2.InterpsList_append(self, x)

    def empty(self) -> "bool":
        return _morfeusz2.InterpsList_empty(self)

    def size(self) -> "std::vector< morfeusz::MorphInterpretation >::size_type":
        return _morfeusz2.InterpsList_size(self)

    def swap(self, v: 'InterpsList') -> "void":
        return _morfeusz2.InterpsList_swap(self, v)

    def begin(self) -> "std::vector< morfeusz::MorphInterpretation >::iterator":
        return _morfeusz2.InterpsList_begin(self)

    def end(self) -> "std::vector< morfeusz::MorphInterpretation >::iterator":
        return _morfeusz2.InterpsList_end(self)

    def rbegin(self) -> "std::vector< morfeusz::MorphInterpretation >::reverse_iterator":
        return _morfeusz2.InterpsList_rbegin(self)

    def rend(self) -> "std::vector< morfeusz::MorphInterpretation >::reverse_iterator":
        return _morfeusz2.InterpsList_rend(self)

    def clear(self) -> "void":
        return _morfeusz2.InterpsList_clear(self)

    def get_allocator(self) -> "std::vector< morfeusz::MorphInterpretation >::allocator_type":
        return _morfeusz2.InterpsList_get_allocator(self)

    def pop_back(self) -> "void":
        return _morfeusz2.InterpsList_pop_back(self)

    def erase(self, *args) -> "std::vector< morfeusz::MorphInterpretation >::iterator":
        return _morfeusz2.InterpsList_erase(self, *args)

    def __init__(self, *args):
        this = _morfeusz2.new_InterpsList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'MorphInterpretation') -> "void":
        return _morfeusz2.InterpsList_push_back(self, x)

    def front(self) -> "std::vector< morfeusz::MorphInterpretation >::value_type const &":
        return _morfeusz2.InterpsList_front(self)

    def back(self) -> "std::vector< morfeusz::MorphInterpretation >::value_type const &":
        return _morfeusz2.InterpsList_back(self)

    def assign(self, n: 'std::vector< morfeusz::MorphInterpretation >::size_type', x: 'MorphInterpretation') -> "void":
        return _morfeusz2.InterpsList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _morfeusz2.InterpsList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _morfeusz2.InterpsList_insert(self, *args)

    def reserve(self, n: 'std::vector< morfeusz::MorphInterpretation >::size_type') -> "void":
        return _morfeusz2.InterpsList_reserve(self, n)

    def capacity(self) -> "std::vector< morfeusz::MorphInterpretation >::size_type":
        return _morfeusz2.InterpsList_capacity(self)
    __swig_destroy__ = _morfeusz2.delete_InterpsList
    __del__ = lambda self: None
InterpsList_swigregister = _morfeusz2.InterpsList_swigregister
InterpsList_swigregister(InterpsList)

class StringsList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringsList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringsList, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _morfeusz2.StringsList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _morfeusz2.StringsList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _morfeusz2.StringsList___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _morfeusz2.StringsList___len__(self)

    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        return _morfeusz2.StringsList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _morfeusz2.StringsList___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        return _morfeusz2.StringsList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _morfeusz2.StringsList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _morfeusz2.StringsList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _morfeusz2.StringsList___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _morfeusz2.StringsList_pop(self)

    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _morfeusz2.StringsList_append(self, x)

    def empty(self) -> "bool":
        return _morfeusz2.StringsList_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _morfeusz2.StringsList_size(self)

    def swap(self, v: 'StringsList') -> "void":
        return _morfeusz2.StringsList_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _morfeusz2.StringsList_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _morfeusz2.StringsList_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _morfeusz2.StringsList_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _morfeusz2.StringsList_rend(self)

    def clear(self) -> "void":
        return _morfeusz2.StringsList_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _morfeusz2.StringsList_get_allocator(self)

    def pop_back(self) -> "void":
        return _morfeusz2.StringsList_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _morfeusz2.StringsList_erase(self, *args)

    def __init__(self, *args):
        this = _morfeusz2.new_StringsList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _morfeusz2.StringsList_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _morfeusz2.StringsList_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _morfeusz2.StringsList_back(self)

    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        return _morfeusz2.StringsList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _morfeusz2.StringsList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _morfeusz2.StringsList_insert(self, *args)

    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        return _morfeusz2.StringsList_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _morfeusz2.StringsList_capacity(self)
    __swig_destroy__ = _morfeusz2.delete_StringsList
    __del__ = lambda self: None
StringsList_swigregister = _morfeusz2.StringsList_swigregister
StringsList_swigregister(StringsList)

class StringsLinkedList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringsLinkedList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringsLinkedList, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _morfeusz2.StringsLinkedList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _morfeusz2.StringsLinkedList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _morfeusz2.StringsLinkedList___bool__(self)

    def __len__(self) -> "std::list< std::string >::size_type":
        return _morfeusz2.StringsLinkedList___len__(self)

    def __getslice__(self, i: 'std::list< std::string >::difference_type', j: 'std::list< std::string >::difference_type') -> "std::list< std::string,std::allocator< std::string > > *":
        return _morfeusz2.StringsLinkedList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _morfeusz2.StringsLinkedList___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< std::string >::difference_type', j: 'std::list< std::string >::difference_type') -> "void":
        return _morfeusz2.StringsLinkedList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _morfeusz2.StringsLinkedList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< std::string >::value_type const &":
        return _morfeusz2.StringsLinkedList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _morfeusz2.StringsLinkedList___setitem__(self, *args)

    def pop(self) -> "std::list< std::string >::value_type":
        return _morfeusz2.StringsLinkedList_pop(self)

    def append(self, x: 'std::list< std::string >::value_type const &') -> "void":
        return _morfeusz2.StringsLinkedList_append(self, x)

    def empty(self) -> "bool":
        return _morfeusz2.StringsLinkedList_empty(self)

    def size(self) -> "std::list< std::string >::size_type":
        return _morfeusz2.StringsLinkedList_size(self)

    def swap(self, v: 'StringsLinkedList') -> "void":
        return _morfeusz2.StringsLinkedList_swap(self, v)

    def begin(self) -> "std::list< std::string >::iterator":
        return _morfeusz2.StringsLinkedList_begin(self)

    def end(self) -> "std::list< std::string >::iterator":
        return _morfeusz2.StringsLinkedList_end(self)

    def rbegin(self) -> "std::list< std::string >::reverse_iterator":
        return _morfeusz2.StringsLinkedList_rbegin(self)

    def rend(self) -> "std::list< std::string >::reverse_iterator":
        return _morfeusz2.StringsLinkedList_rend(self)

    def clear(self) -> "void":
        return _morfeusz2.StringsLinkedList_clear(self)

    def get_allocator(self) -> "std::list< std::string >::allocator_type":
        return _morfeusz2.StringsLinkedList_get_allocator(self)

    def pop_back(self) -> "void":
        return _morfeusz2.StringsLinkedList_pop_back(self)

    def erase(self, *args) -> "std::list< std::string >::iterator":
        return _morfeusz2.StringsLinkedList_erase(self, *args)

    def __init__(self, *args):
        this = _morfeusz2.new_StringsLinkedList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::list< std::string >::value_type const &') -> "void":
        return _morfeusz2.StringsLinkedList_push_back(self, x)

    def front(self) -> "std::list< std::string >::value_type const &":
        return _morfeusz2.StringsLinkedList_front(self)

    def back(self) -> "std::list< std::string >::value_type const &":
        return _morfeusz2.StringsLinkedList_back(self)

    def assign(self, n: 'std::list< std::string >::size_type', x: 'std::list< std::string >::value_type const &') -> "void":
        return _morfeusz2.StringsLinkedList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _morfeusz2.StringsLinkedList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _morfeusz2.StringsLinkedList_insert(self, *args)

    def pop_front(self) -> "void":
        return _morfeusz2.StringsLinkedList_pop_front(self)

    def push_front(self, x: 'std::list< std::string >::value_type const &') -> "void":
        return _morfeusz2.StringsLinkedList_push_front(self, x)

    def reverse(self) -> "void":
        return _morfeusz2.StringsLinkedList_reverse(self)
    __swig_destroy__ = _morfeusz2.delete_StringsLinkedList
    __del__ = lambda self: None
StringsLinkedList_swigregister = _morfeusz2.StringsLinkedList_swigregister
StringsLinkedList_swigregister(StringsLinkedList)

class StringsSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringsSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringsSet, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _morfeusz2.StringsSet_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _morfeusz2.StringsSet___nonzero__(self)

    def __bool__(self) -> "bool":
        return _morfeusz2.StringsSet___bool__(self)

    def __len__(self) -> "std::set< std::string >::size_type":
        return _morfeusz2.StringsSet___len__(self)

    def append(self, x: 'std::set< std::string >::value_type') -> "void":
        return _morfeusz2.StringsSet_append(self, x)

    def __contains__(self, x: 'std::set< std::string >::value_type') -> "bool":
        return _morfeusz2.StringsSet___contains__(self, x)

    def __getitem__(self, i: 'std::set< std::string >::difference_type') -> "std::set< std::string >::value_type":
        return _morfeusz2.StringsSet___getitem__(self, i)

    def add(self, x: 'std::set< std::string >::value_type') -> "void":
        return _morfeusz2.StringsSet_add(self, x)

    def discard(self, x: 'std::set< std::string >::value_type') -> "void":
        return _morfeusz2.StringsSet_discard(self, x)

    def __init__(self, *args):
        this = _morfeusz2.new_StringsSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _morfeusz2.StringsSet_empty(self)

    def size(self) -> "std::set< std::string >::size_type":
        return _morfeusz2.StringsSet_size(self)

    def clear(self) -> "void":
        return _morfeusz2.StringsSet_clear(self)

    def swap(self, v: 'StringsSet') -> "void":
        return _morfeusz2.StringsSet_swap(self, v)

    def count(self, x: 'std::set< std::string >::key_type const &') -> "std::set< std::string >::size_type":
        return _morfeusz2.StringsSet_count(self, x)

    def begin(self) -> "std::set< std::string >::iterator":
        return _morfeusz2.StringsSet_begin(self)

    def end(self) -> "std::set< std::string >::iterator":
        return _morfeusz2.StringsSet_end(self)

    def rbegin(self) -> "std::set< std::string >::reverse_iterator":
        return _morfeusz2.StringsSet_rbegin(self)

    def rend(self) -> "std::set< std::string >::reverse_iterator":
        return _morfeusz2.StringsSet_rend(self)

    def erase(self, *args) -> "void":
        return _morfeusz2.StringsSet_erase(self, *args)

    def find(self, x: 'std::set< std::string >::key_type const &') -> "std::set< std::string >::iterator":
        return _morfeusz2.StringsSet_find(self, x)

    def lower_bound(self, x: 'std::set< std::string >::key_type const &') -> "std::set< std::string >::iterator":
        return _morfeusz2.StringsSet_lower_bound(self, x)

    def upper_bound(self, x: 'std::set< std::string >::key_type const &') -> "std::set< std::string >::iterator":
        return _morfeusz2.StringsSet_upper_bound(self, x)

    def equal_range(self, x: 'std::set< std::string >::key_type const &') -> "std::pair< std::set< std::string >::iterator,std::set< std::string >::iterator >":
        return _morfeusz2.StringsSet_equal_range(self, x)

    def insert(self, __x: 'std::set< std::string >::value_type const &') -> "std::pair< std::set< std::string >::iterator,bool >":
        return _morfeusz2.StringsSet_insert(self, __x)
    __swig_destroy__ = _morfeusz2.delete_StringsSet
    __del__ = lambda self: None
StringsSet_swigregister = _morfeusz2.StringsSet_swigregister
StringsSet_swigregister(StringsSet)

SEPARATE_NUMBERING = _morfeusz2.SEPARATE_NUMBERING
CONTINUOUS_NUMBERING = _morfeusz2.CONTINUOUS_NUMBERING
CONDITIONALLY_CASE_SENSITIVE = _morfeusz2.CONDITIONALLY_CASE_SENSITIVE
STRICTLY_CASE_SENSITIVE = _morfeusz2.STRICTLY_CASE_SENSITIVE
IGNORE_CASE = _morfeusz2.IGNORE_CASE
SKIP_WHITESPACES = _morfeusz2.SKIP_WHITESPACES
APPEND_WHITESPACES = _morfeusz2.APPEND_WHITESPACES
KEEP_WHITESPACES = _morfeusz2.KEEP_WHITESPACES
ANALYSE_ONLY = _morfeusz2.ANALYSE_ONLY
GENERATE_ONLY = _morfeusz2.GENERATE_ONLY
BOTH_ANALYSE_AND_GENERATE = _morfeusz2.BOTH_ANALYSE_AND_GENERATE
class _Morfeusz(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Morfeusz, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Morfeusz, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    if _newclass:
        getVersion = staticmethod(_morfeusz2._Morfeusz_getVersion)
    else:
        getVersion = _morfeusz2._Morfeusz_getVersion
    if _newclass:
        getDefaultDictName = staticmethod(_morfeusz2._Morfeusz_getDefaultDictName)
    else:
        getDefaultDictName = _morfeusz2._Morfeusz_getDefaultDictName
    if _newclass:
        getCopyright = staticmethod(_morfeusz2._Morfeusz_getCopyright)
    else:
        getCopyright = _morfeusz2._Morfeusz_getCopyright
    if _newclass:
        createInstance = staticmethod(_morfeusz2._Morfeusz_createInstance)
    else:
        createInstance = _morfeusz2._Morfeusz_createInstance

    def getDictID(self) -> "std::string":
        return _morfeusz2._Morfeusz_getDictID(self)

    def getDictCopyright(self) -> "std::string":
        return _morfeusz2._Morfeusz_getDictCopyright(self)

    def clone(self) -> "morfeusz::Morfeusz *":
        return _morfeusz2._Morfeusz_clone(self)
    __swig_destroy__ = _morfeusz2.delete__Morfeusz
    __del__ = lambda self: None

    def analyse(self, text):
        """
        Analyse given text and return a list of MorphInterpretation objects.
        """
        res = InterpsList()
        _morfeusz2._Morfeusz_analyse(self, text, res)
        return res



    def generate(self, lemma, tagId=None):
        """
        Perform morphological synthesis on given text and return a list of MorphInterpretation objects.
        """
        if tagId is not None:
            return self._generateByTagId(lemma, tagId)
        else:
            res = InterpsList()
            _morfeusz2._Morfeusz_generate(self, lemma, res)
            return res



    def setAggl(self, optionString):
        """
        Select agglutination rules option
        """
        _morfeusz2._Morfeusz_setAggl(self, optionString)



    def getAggl(self) -> "std::string":
        return _morfeusz2._Morfeusz_getAggl(self)

    def setPraet(self, optionString):
        """
        Select past tense segmentation
        """
        _morfeusz2._Morfeusz_setPraet(self, optionString)



    def getPraet(self) -> "std::string":
        return _morfeusz2._Morfeusz_getPraet(self)

    def setCaseHandling(self, option):
        """
        Set case handling option (valid options are CONDITIONALLY_CASE_SENSITIVE, STRICTLY_CASE_SENSITIVE, IGNORE_CASE)
        """
        _morfeusz2._Morfeusz_setCaseHandling(self, option)



    def getCaseHandling(self) -> "morfeusz::CaseHandling":
        return _morfeusz2._Morfeusz_getCaseHandling(self)

    def setTokenNumbering(self, option):
        """
        Set token numbering option (valid options are SEPARATE_NUMBERING, CONTINUOUS_NUMBERING)
        """
        _morfeusz2._Morfeusz_setTokenNumbering(self, option)



    def getTokenNumbering(self) -> "morfeusz::TokenNumbering":
        return _morfeusz2._Morfeusz_getTokenNumbering(self)

    def setWhitespaceHandling(self, option):
        """
        Set whitespace handling handling option (valid options are SKIP_WHITESPACES, KEEP_WHITESPACES, APPEND_WHITESPACES)
        """
        _morfeusz2._Morfeusz_setWhitespaceHandling(self, option)



    def getWhitespaceHandling(self) -> "morfeusz::WhitespaceHandling":
        return _morfeusz2._Morfeusz_getWhitespaceHandling(self)

    def getIdResolver(self) -> "morfeusz::IdResolver const &":
        return _morfeusz2._Morfeusz_getIdResolver(self)

    def setDictionary(self, dictName):
        """
        Set dictionary to be used by this instance (by name)
        """
        _morfeusz2._Morfeusz_setDictionary(self, dictName)


    __swig_setmethods__["dictionarySearchPaths"] = _morfeusz2._Morfeusz_dictionarySearchPaths_set
    __swig_getmethods__["dictionarySearchPaths"] = _morfeusz2._Morfeusz_dictionarySearchPaths_get
    if _newclass:
        dictionarySearchPaths = _swig_property(_morfeusz2._Morfeusz_dictionarySearchPaths_get, _morfeusz2._Morfeusz_dictionarySearchPaths_set)

    def getAvailableAgglOptions(self) -> "std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &":
        return _morfeusz2._Morfeusz_getAvailableAgglOptions(self)

    def getAvailablePraetOptions(self) -> "std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &":
        return _morfeusz2._Morfeusz_getAvailablePraetOptions(self)

    def _generateByTagId(self, lemma: 'std::string const &', tagId: 'int') -> "std::vector< morfeusz::MorphInterpretation,std::allocator< morfeusz::MorphInterpretation > >":
        return _morfeusz2._Morfeusz__generateByTagId(self, lemma, tagId)


    def analyse_iter(self, text):
        """
        Analyse given text and return an iterator over MorphInterpretation objects as a result.
        """
        return _morfeusz2._Morfeusz__analyseAsIterator(self, text)


_Morfeusz_swigregister = _morfeusz2._Morfeusz_swigregister
_Morfeusz_swigregister(_Morfeusz)

def _Morfeusz_getVersion() -> "std::string":
    return _morfeusz2._Morfeusz_getVersion()
_Morfeusz_getVersion = _morfeusz2._Morfeusz_getVersion

def _Morfeusz_getDefaultDictName() -> "std::string":
    return _morfeusz2._Morfeusz_getDefaultDictName()
_Morfeusz_getDefaultDictName = _morfeusz2._Morfeusz_getDefaultDictName

def _Morfeusz_getCopyright() -> "std::string":
    return _morfeusz2._Morfeusz_getCopyright()
_Morfeusz_getCopyright = _morfeusz2._Morfeusz_getCopyright

def _Morfeusz_createInstance(*args) -> "morfeusz::Morfeusz *":
    return _morfeusz2._Morfeusz_createInstance(*args)
_Morfeusz_createInstance = _morfeusz2._Morfeusz_createInstance
cvar = _morfeusz2.cvar

class ResultsIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ResultsIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ResultsIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def hasNext(self) -> "bool":
        return _morfeusz2.ResultsIterator_hasNext(self)

    def peek(self) -> "morfeusz::MorphInterpretation const &":
        return _morfeusz2.ResultsIterator_peek(self)

    def next(self):
        if self.hasNext():
            return _morfeusz2.ResultsIterator_next(self)
        else:
            raise StopIteration


    __swig_destroy__ = _morfeusz2.delete_ResultsIterator
    __del__ = lambda self: None

    def __iter__(self) -> "morfeusz::ResultsIterator &":
        return _morfeusz2.ResultsIterator___iter__(self)
ResultsIterator_swigregister = _morfeusz2.ResultsIterator_swigregister
ResultsIterator_swigregister(ResultsIterator)

class IdResolver(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IdResolver, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IdResolver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getTagsetId(self) -> "std::string const":
        return _morfeusz2.IdResolver_getTagsetId(self)

    def getTag(self, tagId):
        return _morfeusz2.IdResolver_getTag(self, tagId)



    def getTagId(self, tag):
        return _morfeusz2.IdResolver_getTagId(self, tag)



    def getName(self, nameId):
        return _morfeusz2.IdResolver_getName(self, nameId)



    def getNameId(self, name):
        return _morfeusz2.IdResolver_getNameId(self, name)



    def getLabelsAsUnicode(self, labelsId):
        return _morfeusz2.IdResolver_getLabelsAsString(self, labelsId)



    def getLabels(self, labelsId):
        return [l for l in _morfeusz2.IdResolver_getLabels(self, labelsId)]



    def getLabelsId(self, labelsStr):
        return _morfeusz2.IdResolver_getLabelsId(self, labelsStr)



    def getTagsCount(self) -> "size_t":
        return _morfeusz2.IdResolver_getTagsCount(self)

    def getNamesCount(self) -> "size_t":
        return _morfeusz2.IdResolver_getNamesCount(self)

    def getLabelsCount(self) -> "size_t":
        return _morfeusz2.IdResolver_getLabelsCount(self)
    __swig_destroy__ = _morfeusz2.delete_IdResolver
    __del__ = lambda self: None
IdResolver_swigregister = _morfeusz2.IdResolver_swigregister
IdResolver_swigregister(IdResolver)

class MorphInterpretation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MorphInterpretation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MorphInterpretation, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _morfeusz2.new_MorphInterpretation()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        createIgn = staticmethod(_morfeusz2.MorphInterpretation_createIgn)
    else:
        createIgn = _morfeusz2.MorphInterpretation_createIgn
    if _newclass:
        createWhitespace = staticmethod(_morfeusz2.MorphInterpretation_createWhitespace)
    else:
        createWhitespace = _morfeusz2.MorphInterpretation_createWhitespace

    def isIgn(self) -> "bool":
        return _morfeusz2.MorphInterpretation_isIgn(self)

    def isWhitespace(self) -> "bool":
        return _morfeusz2.MorphInterpretation_isWhitespace(self)

    def getTag(self, morfeusz):
        """
        Returns tag as string.
        """
        return _morfeusz2.MorphInterpretation_getTag(self, morfeusz)



    def getName(self, morfeusz):
        """
        Returns this interpretation named entity as unicode
        """
        name = _morfeusz2.MorphInterpretation_getName(self, morfeusz)
        return name.split('|') if name else []



    def getLabelsAsUnicode(self, morfeusz):
        """
        Returns this interpretation labels as string
        """
        return _morfeusz2.MorphInterpretation_getLabelsAsString(self, morfeusz)



    def getLabels(self, morfeusz):
        """
        Returns this interpretation labels as a list of strings
        """
        return [l for l in _morfeusz2.MorphInterpretation_getLabels(self, morfeusz)]


    __swig_setmethods__["startNode"] = _morfeusz2.MorphInterpretation_startNode_set
    __swig_getmethods__["startNode"] = _morfeusz2.MorphInterpretation_startNode_get
    if _newclass:
        startNode = _swig_property(_morfeusz2.MorphInterpretation_startNode_get, _morfeusz2.MorphInterpretation_startNode_set)
    __swig_setmethods__["endNode"] = _morfeusz2.MorphInterpretation_endNode_set
    __swig_getmethods__["endNode"] = _morfeusz2.MorphInterpretation_endNode_get
    if _newclass:
        endNode = _swig_property(_morfeusz2.MorphInterpretation_endNode_get, _morfeusz2.MorphInterpretation_endNode_set)
    __swig_setmethods__["_orth"] = _morfeusz2.MorphInterpretation__orth_set
    __swig_getmethods__["_orth"] = _morfeusz2.MorphInterpretation__orth_get
    if _newclass:
        _orth = _swig_property(_morfeusz2.MorphInterpretation__orth_get, _morfeusz2.MorphInterpretation__orth_set)
    __swig_setmethods__["_lemma"] = _morfeusz2.MorphInterpretation__lemma_set
    __swig_getmethods__["_lemma"] = _morfeusz2.MorphInterpretation__lemma_get
    if _newclass:
        _lemma = _swig_property(_morfeusz2.MorphInterpretation__lemma_get, _morfeusz2.MorphInterpretation__lemma_set)
    __swig_setmethods__["tagId"] = _morfeusz2.MorphInterpretation_tagId_set
    __swig_getmethods__["tagId"] = _morfeusz2.MorphInterpretation_tagId_get
    if _newclass:
        tagId = _swig_property(_morfeusz2.MorphInterpretation_tagId_get, _morfeusz2.MorphInterpretation_tagId_set)
    __swig_setmethods__["nameId"] = _morfeusz2.MorphInterpretation_nameId_set
    __swig_getmethods__["nameId"] = _morfeusz2.MorphInterpretation_nameId_get
    if _newclass:
        nameId = _swig_property(_morfeusz2.MorphInterpretation_nameId_get, _morfeusz2.MorphInterpretation_nameId_set)
    __swig_setmethods__["labelsId"] = _morfeusz2.MorphInterpretation_labelsId_set
    __swig_getmethods__["labelsId"] = _morfeusz2.MorphInterpretation_labelsId_get
    if _newclass:
        labelsId = _swig_property(_morfeusz2.MorphInterpretation_labelsId_get, _morfeusz2.MorphInterpretation_labelsId_set)

    @property
    def orth(self):
        return self._orth

    @orth.setter
    def orth(self, val):
        self._orth = val


    @property
    def lemma(self):
        return self._lemma

    @lemma.setter
    def lemma(self, val):
        self._lemma = val

    __swig_destroy__ = _morfeusz2.delete_MorphInterpretation
    __del__ = lambda self: None
MorphInterpretation_swigregister = _morfeusz2.MorphInterpretation_swigregister
MorphInterpretation_swigregister(MorphInterpretation)

def MorphInterpretation_createIgn(startNode: 'int', endNode: 'int', orth: 'std::string const &', lemma: 'std::string const &') -> "morfeusz::MorphInterpretation":
    return _morfeusz2.MorphInterpretation_createIgn(startNode, endNode, orth, lemma)
MorphInterpretation_createIgn = _morfeusz2.MorphInterpretation_createIgn

def MorphInterpretation_createWhitespace(startNode: 'int', endNode: 'int', orth: 'std::string const &') -> "morfeusz::MorphInterpretation":
    return _morfeusz2.MorphInterpretation_createWhitespace(startNode, endNode, orth)
MorphInterpretation_createWhitespace = _morfeusz2.MorphInterpretation_createWhitespace

# This file is compatible with both classic and new-style classes.


