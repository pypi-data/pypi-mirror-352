use anyhow::{Context, Result};
use std::collections::{HashMap, HashSet};
use std::fs;

use crate::dependency_graph::ModuleNode;
use crate::resolver::{ImportType, ModuleResolver};
use crate::unused_imports_simple::UnusedImportAnalyzer;
use rustpython_parser::ast::{self, Mod, Stmt};
use rustpython_parser::{Mode, parse};
use unparser::Unparser;

/// Type alias for import sets to reduce complexity
type ImportSets = (HashSet<String>, HashSet<String>);

/// Pre-parsed module data with AST for efficient processing
struct ParsedModuleData {
    ast: ast::ModModule,
    unused_imports: HashSet<String>,
    first_party_imports: HashSet<String>,
}

/// Import strategy for how a module should be bundled
#[derive(Debug, Clone, PartialEq)]
enum ImportStrategy {
    /// Module imported via `import module` - needs namespace
    ModuleImport,
    /// Module imported via `from module import items` - needs direct inlining
    FromImport,
    /// Module not imported directly (dependency of other modules)
    Dependency,
}

pub struct CodeEmitter {
    resolver: ModuleResolver,
    _preserve_comments: bool,
    _preserve_type_hints: bool,
}

impl CodeEmitter {
    pub fn new(
        resolver: ModuleResolver,
        preserve_comments: bool,
        preserve_type_hints: bool,
    ) -> Self {
        Self {
            resolver,
            _preserve_comments: preserve_comments,
            _preserve_type_hints: preserve_type_hints,
        }
    }

    /// Helper method to classify and add import to appropriate set
    fn classify_and_add_import(
        &self,
        import: &str,
        third_party_imports: &mut HashSet<String>,
        stdlib_imports: &mut HashSet<String>,
    ) {
        match self.resolver.classify_import(import) {
            ImportType::ThirdParty => {
                third_party_imports.insert(import.to_string());
            }
            ImportType::StandardLibrary => {
                stdlib_imports.insert(import.to_string());
            }
            ImportType::FirstParty => {
                // Will be inlined, so skip
            }
        }
    }

    /// Collect imports and categorize them by type
    fn collect_import_sets(&self, modules: &[&ModuleNode]) -> ImportSets {
        let mut third_party_imports = HashSet::new();
        let mut stdlib_imports = HashSet::new();

        for module in modules {
            for import in &module.imports {
                self.classify_and_add_import(import, &mut third_party_imports, &mut stdlib_imports);
            }
        }

        (third_party_imports, stdlib_imports)
    }

    /// Create an import statement AST node from a module name
    fn create_import_statement(&self, module_name: &str) -> Stmt {
        // Check if the module name is already a formatted import statement
        if module_name.starts_with("import ") || module_name.starts_with("from ") {
            // For pre-formatted imports, create a comment with the statement
            self.create_comment_stmt(&format!("# {}", module_name))
        } else if self.is_valid_module_name(module_name) {
            // Create a proper import statement AST node
            Stmt::Import(ast::StmtImport {
                names: vec![ast::Alias {
                    name: module_name.into(),
                    asname: None,
                    range: Default::default(),
                }],
                range: Default::default(),
            })
        } else {
            // For unusual module names, add a warning comment
            self.create_comment_stmt(&format!(
                "# import {}  # Warning: unusual module name format",
                module_name
            ))
        }
    }

    /// Generate bundled Python code from sorted modules using AST-based approach
    pub fn emit_bundle(&mut self, modules: &[&ModuleNode], entry_module: &str) -> Result<String> {
        // Create a main bundle AST that will contain everything
        let mut bundle_ast = ast::ModModule {
            body: vec![
                // Add shebang and header comments
                self.create_comment_stmt("#!/usr/bin/env python3"),
                self.create_comment_stmt("# Generated by Serpen - Python Source Bundler"),
                self.create_comment_stmt("# https://github.com/tinovyatkin/serpen"),
                self.create_comment_stmt(""),
            ],
            type_ignores: Vec::new(),
            range: Default::default(),
        };

        // Parse all modules once and store AST + metadata
        let mut all_unused_imports = HashSet::new();
        let mut parsed_modules_data = HashMap::new();

        for module in modules {
            let source = fs::read_to_string(&module.path)
                .with_context(|| format!("Failed to read module file: {:?}", module.path))?;

            // Parse into AST
            let parsed = parse(&source, Mode::Module, "module")
                .with_context(|| format!("Failed to parse module: {:?}", module.path))?;
            let Mod::Module(ast) = parsed else {
                return Err(anyhow::anyhow!("Expected module, got other AST node type"));
            };

            // Analyze unused imports
            let mut unused_analyzer = UnusedImportAnalyzer::new();
            let unused_imports = unused_analyzer.analyze_file(&source).unwrap_or_else(|err| {
                log::warn!(
                    "Failed to analyze unused imports in {:?}: {}",
                    module.path,
                    err
                );
                Vec::new()
            });

            let module_unused_names: HashSet<String> = unused_imports
                .iter()
                .map(|import| import.name.clone())
                .collect();

            // Collect first-party imports from AST
            let first_party_imports = self.collect_first_party_imports_from_ast(&ast)?;

            // Store parsed data
            parsed_modules_data.insert(
                module.path.clone(),
                ParsedModuleData {
                    ast,
                    unused_imports: module_unused_names.clone(),
                    first_party_imports,
                },
            );

            // Add to global unused set
            for import in unused_imports {
                all_unused_imports.insert(import.name);
            }
        }

        // Analyze import strategies for each module based on how they're imported by the entry module
        let import_strategies =
            self.analyze_import_strategies(modules, entry_module, &parsed_modules_data)?;

        // Collect and filter preserved imports
        let (mut third_party_imports, mut stdlib_imports) = self.collect_import_sets(modules);
        third_party_imports.retain(|import| !all_unused_imports.contains(import));
        stdlib_imports.retain(|import| !all_unused_imports.contains(import));

        // Add preserved imports at the top
        if !stdlib_imports.is_empty() || !third_party_imports.is_empty() {
            // Add preserved imports header comment
            bundle_ast.body.push(self.create_preserved_imports_header());

            // Standard library imports first
            let mut sorted_stdlib: Vec<_> = stdlib_imports.into_iter().collect();
            sorted_stdlib.sort();
            for import in &sorted_stdlib {
                // Create an import statement for standard library imports
                let import_stmt = self.create_import_statement(import);
                bundle_ast.body.push(import_stmt);
            }

            // Add an empty line comment between stdlib and third-party imports if both are present
            if !sorted_stdlib.is_empty() && !third_party_imports.is_empty() {
                bundle_ast.body.push(self.create_comment_stmt(""));
            }

            // Third-party imports
            let mut sorted_third_party: Vec<_> = third_party_imports.into_iter().collect();
            sorted_third_party.sort();
            for import in sorted_third_party {
                // Create an import statement for third-party imports
                let import_stmt = self.create_import_statement(&import);
                bundle_ast.body.push(import_stmt);
            }

            // Add an empty line comment after imports
            bundle_ast.body.push(self.create_comment_stmt(""));
        }

        // Process each module in dependency order using AST transformations
        for module in modules {
            if module.name == entry_module {
                continue;
            }

            // Add module header
            bundle_ast
                .body
                .push(self.create_module_header_comment(&module.name));

            let parsed_data = parsed_modules_data.get(&module.path).ok_or_else(|| {
                anyhow::anyhow!("Missing parsed data for module: {:?}", module.path)
            })?;

            let import_strategy = import_strategies
                .get(&module.name)
                .unwrap_or(&ImportStrategy::Dependency);

            // Process the module and get a transformed AST
            let module_ast =
                self.process_module_ast_to_ast(&module.name, parsed_data, import_strategy)?;

            // Extend the bundle AST with the module's statements
            bundle_ast.body.extend(module_ast.body);

            // Add an empty line between modules
            bundle_ast.body.push(self.create_comment_stmt(""));
        }

        // Add entry module last
        if let Some(entry_module_node) = modules.iter().find(|m| m.name == entry_module) {
            // Add entry module header
            bundle_ast
                .body
                .push(self.create_entry_module_header_comment(entry_module));

            let parsed_data = parsed_modules_data
                .get(&entry_module_node.path)
                .ok_or_else(|| {
                    anyhow::anyhow!(
                        "Missing parsed data for entry module: {:?}",
                        entry_module_node.path
                    )
                })?;

            // Process the entry module and get a transformed AST
            let entry_ast = self.process_module_ast_to_ast(
                &entry_module_node.name,
                parsed_data,
                &ImportStrategy::Dependency,
            )?;

            // Extend the bundle AST with the entry module's statements
            bundle_ast.body.extend(entry_ast.body);
        }

        // Generate the final Python code using the unparser
        let mut unparser = Unparser::new();
        for stmt in &bundle_ast.body {
            unparser.unparse_stmt(stmt);
        }

        Ok(unparser.source)
    }

    /// Process a single module's AST to produce a transformed AST for bundling
    fn process_module_ast_to_ast(
        &mut self,
        module_name: &str,
        parsed_data: &ParsedModuleData,
        import_strategy: &ImportStrategy,
    ) -> Result<ast::ModModule> {
        log::info!("Processing module AST '{}'", module_name);

        // Create a transformed AST by cloning the original
        let mut transformed_ast = parsed_data.ast.clone();

        // Remove first-party imports and unused imports using existing methods
        self.remove_first_party_imports(&mut transformed_ast, &parsed_data.first_party_imports)?;
        self.remove_unused_imports(&mut transformed_ast, &parsed_data.unused_imports)?;

        // Apply bundling strategy based on how this module is imported
        match import_strategy {
            ImportStrategy::ModuleImport => {
                // For modules imported as "import module", create a module namespace using AST nodes
                let module_ast = ast::ModModule {
                    body: self.create_module_namespace_ast(module_name, &transformed_ast)?,
                    type_ignores: Vec::new(),
                    range: Default::default(),
                };
                Ok(module_ast)
            }
            ImportStrategy::FromImport | ImportStrategy::Dependency => {
                // For modules imported as "from module import" or dependency modules,
                // return the transformed AST directly
                Ok(transformed_ast)
            }
        }
    }

    /// Create a module namespace using AST operations
    fn create_module_namespace_ast(
        &self,
        module_name: &str,
        module_ast: &ast::ModModule,
    ) -> Result<Vec<Stmt>> {
        // Start with the types import and namespace creation
        let mut namespace_stmts = self.create_module_namespace_structure(module_name)?;

        // Convert the module code to a string for the exec call
        // This is necessary because Python AST doesn't allow directly representing a module as an expression
        let mut unparser = Unparser::new();
        for stmt in &module_ast.body {
            unparser.unparse_stmt(stmt);
        }
        let module_code = unparser.source;

        // Add the exec call that will execute the module code in its namespace
        let exec_stmt = self.create_module_exec_statement(module_name, &module_code)?;
        namespace_stmts.push(exec_stmt);

        Ok(namespace_stmts)
    }

    /// Create module namespace structure as AST nodes
    fn create_module_namespace_structure(&self, module_name: &str) -> Result<Vec<Stmt>> {
        let mut statements = Vec::new();

        // 1. import types
        let import_types = ast::StmtImport {
            names: vec![ast::Alias {
                name: "types".into(),
                asname: None,
                range: Default::default(),
            }],
            range: Default::default(),
        };
        statements.push(Stmt::Import(import_types));

        // 2. Create parent namespaces first for nested modules (e.g., greetings.greeting)
        if module_name.contains('.') {
            let parts: Vec<&str> = module_name.split('.').collect();

            // Create each parent namespace level
            for i in 1..parts.len() {
                let parent_name = parts[..i].join(".");

                // Create assignment: parent = types.ModuleType('parent')
                let parent_type_call = ast::ExprCall {
                    func: Box::new(ast::Expr::Attribute(ast::ExprAttribute {
                        value: Box::new(ast::Expr::Name(ast::ExprName {
                            id: "types".into(),
                            ctx: ast::ExprContext::Load,
                            range: Default::default(),
                        })),
                        attr: "ModuleType".into(),
                        ctx: ast::ExprContext::Load,
                        range: Default::default(),
                    })),
                    args: vec![ast::Expr::Constant(ast::ExprConstant {
                        value: ast::Constant::Str(parent_name),
                        kind: None,
                        range: Default::default(),
                    })],
                    keywords: vec![],
                    range: Default::default(),
                };

                // For nested modules, create the proper assignment target
                let assignment_target = self.create_assignment_target(&parts, i)?;

                let parent_assignment = ast::StmtAssign {
                    targets: vec![assignment_target],
                    value: Box::new(ast::Expr::Call(parent_type_call)),
                    type_comment: None,
                    range: Default::default(),
                };
                statements.push(Stmt::Assign(parent_assignment));
            }
        }

        // 3. Create the main module: module_name = types.ModuleType('module_name')
        let module_type_call = ast::ExprCall {
            func: Box::new(ast::Expr::Attribute(ast::ExprAttribute {
                value: Box::new(ast::Expr::Name(ast::ExprName {
                    id: "types".into(),
                    ctx: ast::ExprContext::Load,
                    range: Default::default(),
                })),
                attr: "ModuleType".into(),
                ctx: ast::ExprContext::Load,
                range: Default::default(),
            })),
            args: vec![ast::Expr::Constant(ast::ExprConstant {
                value: ast::Constant::Str(module_name.into()),
                kind: None,
                range: Default::default(),
            })],
            keywords: vec![],
            range: Default::default(),
        };

        // Create the assignment target for the full module name
        let main_assignment_target = if module_name.contains('.') {
            // For "greetings.greeting", create "greetings.greeting = ..."
            let parts: Vec<&str> = module_name.split('.').collect();
            let mut attr_expr = ast::Expr::Name(ast::ExprName {
                id: parts[0].into(),
                ctx: ast::ExprContext::Load,
                range: Default::default(),
            });

            for part in &parts[1..parts.len() - 1] {
                attr_expr = ast::Expr::Attribute(ast::ExprAttribute {
                    value: Box::new(attr_expr),
                    attr: (*part).into(),
                    ctx: ast::ExprContext::Load,
                    range: Default::default(),
                });
            }

            ast::Expr::Attribute(ast::ExprAttribute {
                value: Box::new(attr_expr),
                attr: parts[parts.len() - 1].into(),
                ctx: ast::ExprContext::Store,
                range: Default::default(),
            })
        } else {
            // Simple module name
            ast::Expr::Name(ast::ExprName {
                id: module_name.into(),
                ctx: ast::ExprContext::Store,
                range: Default::default(),
            })
        };

        let module_assignment = ast::StmtAssign {
            targets: vec![main_assignment_target],
            value: Box::new(ast::Expr::Call(module_type_call)),
            type_comment: None,
            range: Default::default(),
        };
        statements.push(Stmt::Assign(module_assignment));

        Ok(statements)
    }

    /// Create assignment target for module namespace creation
    fn create_assignment_target(&self, parts: &[&str], i: usize) -> Result<ast::Expr> {
        if i == 1 {
            // Simple case: greetings = types.ModuleType('greetings')
            Ok(ast::Expr::Name(ast::ExprName {
                id: parts[0].into(),
                ctx: ast::ExprContext::Store,
                range: Default::default(),
            }))
        } else {
            // Complex case: greetings.submodule = types.ModuleType('greetings.submodule')
            let parent_parts: Vec<&str> = parts[..i].to_vec();
            let mut attr_expr = ast::Expr::Name(ast::ExprName {
                id: parent_parts[0].into(),
                ctx: ast::ExprContext::Load,
                range: Default::default(),
            });

            for part in &parent_parts[1..parent_parts.len() - 1] {
                attr_expr = ast::Expr::Attribute(ast::ExprAttribute {
                    value: Box::new(attr_expr),
                    attr: (*part).into(),
                    ctx: ast::ExprContext::Load,
                    range: Default::default(),
                });
            }

            Ok(ast::Expr::Attribute(ast::ExprAttribute {
                value: Box::new(attr_expr),
                attr: parent_parts[parent_parts.len() - 1].into(),
                ctx: ast::ExprContext::Store,
                range: Default::default(),
            }))
        }
    }

    /// Create an AST for the exec statement that executes module code in its namespace
    fn create_module_exec_statement(&self, module_name: &str, module_code: &str) -> Result<Stmt> {
        // Create the module code string constant for the exec call
        let module_code_constant = ast::ExprConstant {
            value: ast::Constant::Str(module_code.to_string()),
            kind: None,
            range: Default::default(),
        };

        // Create the __dict__ access for the full module name
        let module_dict_attr = if module_name.contains('.') {
            // For nested modules like "greetings.greeting", build the attribute chain
            let parts: Vec<&str> = module_name.split('.').collect();
            let mut attr_expr = ast::Expr::Name(ast::ExprName {
                id: parts[0].into(),
                ctx: ast::ExprContext::Load,
                range: Default::default(),
            });

            for part in &parts[1..] {
                attr_expr = ast::Expr::Attribute(ast::ExprAttribute {
                    value: Box::new(attr_expr),
                    attr: (*part).into(),
                    ctx: ast::ExprContext::Load,
                    range: Default::default(),
                });
            }

            ast::ExprAttribute {
                value: Box::new(attr_expr),
                attr: "__dict__".into(),
                ctx: ast::ExprContext::Load,
                range: Default::default(),
            }
        } else {
            // Simple case for non-nested modules
            ast::ExprAttribute {
                value: Box::new(ast::Expr::Name(ast::ExprName {
                    id: module_name.into(),
                    ctx: ast::ExprContext::Load,
                    range: Default::default(),
                })),
                attr: "__dict__".into(),
                ctx: ast::ExprContext::Load,
                range: Default::default(),
            }
        };

        // Create the exec call with the module code string and the module's __dict__
        let exec_call = ast::ExprCall {
            func: Box::new(ast::Expr::Name(ast::ExprName {
                id: "exec".into(),
                ctx: ast::ExprContext::Load,
                range: Default::default(),
            })),
            args: vec![
                ast::Expr::Constant(module_code_constant),
                ast::Expr::Attribute(module_dict_attr),
            ],
            keywords: vec![],
            range: Default::default(),
        };

        // Create the exec statement
        Ok(Stmt::Expr(ast::StmtExpr {
            value: Box::new(ast::Expr::Call(exec_call)),
            range: Default::default(),
        }))
    }

    /// Analyze how each module is imported by the entry module to determine bundling strategy
    fn analyze_import_strategies(
        &self,
        modules: &[&ModuleNode],
        entry_module: &str,
        parsed_modules_data: &HashMap<std::path::PathBuf, ParsedModuleData>,
    ) -> Result<HashMap<String, ImportStrategy>> {
        let mut strategies = HashMap::new();

        // Find the entry module data
        let entry_module_node = modules
            .iter()
            .find(|m| m.name == entry_module)
            .ok_or_else(|| anyhow::anyhow!("Entry module not found: {}", entry_module))?;

        let entry_parsed_data = parsed_modules_data
            .get(&entry_module_node.path)
            .ok_or_else(|| anyhow::anyhow!("Entry module data not found"))?;

        // Analyze import statements in the entry module
        for stmt in &entry_parsed_data.ast.body {
            match stmt {
                Stmt::Import(import_stmt) => {
                    self.process_import_strategies(import_stmt, &mut strategies);
                }
                Stmt::ImportFrom(import_from_stmt) => {
                    self.process_import_from_strategies(import_from_stmt, &mut strategies);
                }
                _ => {}
            }
        }

        Ok(strategies)
    }

    /// Process import statements for strategy analysis
    fn process_import_strategies(
        &self,
        import_stmt: &ast::StmtImport,
        strategies: &mut HashMap<String, ImportStrategy>,
    ) {
        // `import module` - needs namespace
        for alias in &import_stmt.names {
            let module_name = alias.name.as_str();
            if self.is_first_party_module(module_name) {
                strategies.insert(module_name.to_string(), ImportStrategy::ModuleImport);
            }
        }
    }

    /// Process import-from statements for strategy analysis
    fn process_import_from_strategies(
        &self,
        import_from_stmt: &ast::StmtImportFrom,
        strategies: &mut HashMap<String, ImportStrategy>,
    ) {
        // `from module import ...` - needs direct inlining
        if let Some(module) = &import_from_stmt.module {
            let module_name = module.as_str();
            if self.is_first_party_module(module_name) {
                strategies.insert(module_name.to_string(), ImportStrategy::FromImport);
            }
        }
    }

    /// Check if a module is a first-party module
    fn is_first_party_module(&self, module_name: &str) -> bool {
        matches!(
            self.resolver.classify_import(module_name),
            ImportType::FirstParty
        )
    }

    /// Remove first-party imports from AST (they will be inlined)
    fn remove_first_party_imports(
        &self,
        module: &mut ast::ModModule,
        first_party_imports: &HashSet<String>,
    ) -> Result<()> {
        log::info!("Removing first-party imports: {:?}", first_party_imports);
        module.body = self.filter_import_statements(&module.body, |import_name| {
            let is_first_party = first_party_imports.contains(import_name);
            let classification = self.resolver.classify_import(import_name);
            let keep = !is_first_party
                || matches!(
                    classification,
                    ImportType::StandardLibrary | ImportType::ThirdParty
                );
            log::info!(
                "Import '{}': first_party={}, classification={:?}, keep={}",
                import_name,
                is_first_party,
                classification,
                keep
            );
            keep
        })?;
        Ok(())
    }

    /// Remove unused imports from AST
    fn remove_unused_imports(
        &self,
        module: &mut ast::ModModule,
        unused_imports: &HashSet<String>,
    ) -> Result<()> {
        module.body = self.filter_import_statements(&module.body, |import_name| {
            !unused_imports.contains(import_name)
        })?;
        Ok(())
    }

    /// Filter import statements based on a predicate
    fn filter_import_statements<F>(
        &self,
        statements: &[Stmt],
        keep_predicate: F,
    ) -> Result<Vec<Stmt>>
    where
        F: Fn(&str) -> bool,
    {
        let mut filtered_statements = Vec::new();

        for stmt in statements {
            match stmt {
                Stmt::Import(import_stmt) => {
                    self.process_import_statement(
                        import_stmt,
                        &keep_predicate,
                        &mut filtered_statements,
                    );
                }
                Stmt::ImportFrom(import_from_stmt) => {
                    self.process_import_from_statement(
                        import_from_stmt,
                        &keep_predicate,
                        &mut filtered_statements,
                    );
                }
                _ => {
                    // Keep all non-import statements as-is
                    filtered_statements.push(stmt.clone());
                }
            }
        }

        Ok(filtered_statements)
    }

    /// Process a single import statement
    fn process_import_statement<F>(
        &self,
        import_stmt: &ast::StmtImport,
        keep_predicate: &F,
        filtered_statements: &mut Vec<Stmt>,
    ) where
        F: Fn(&str) -> bool,
    {
        let filtered_aliases = self.filter_import_aliases(&import_stmt.names, keep_predicate);

        if !filtered_aliases.is_empty() {
            let mut new_import = import_stmt.clone();
            new_import.names = filtered_aliases;
            filtered_statements.push(Stmt::Import(new_import));
        }
    }

    /// Process a single import-from statement
    fn process_import_from_statement<F>(
        &self,
        import_from_stmt: &ast::StmtImportFrom,
        keep_predicate: &F,
        filtered_statements: &mut Vec<Stmt>,
    ) where
        F: Fn(&str) -> bool,
    {
        let should_keep = self.should_keep_import_from_module(import_from_stmt, keep_predicate);

        if should_keep {
            let filtered_aliases =
                self.filter_import_from_aliases(&import_from_stmt.names, keep_predicate);

            if !filtered_aliases.is_empty() {
                let mut new_import = import_from_stmt.clone();
                new_import.names = filtered_aliases;
                filtered_statements.push(Stmt::ImportFrom(new_import));
            }
        }
    }

    /// Filter aliases for regular import statements
    fn filter_import_aliases<F>(
        &self,
        aliases: &[ast::Alias],
        keep_predicate: &F,
    ) -> Vec<ast::Alias>
    where
        F: Fn(&str) -> bool,
    {
        aliases
            .iter()
            .filter(|alias| {
                let import_name = alias.name.as_str();
                keep_predicate(import_name)
            })
            .cloned()
            .collect()
    }

    /// Filter aliases for import-from statements
    fn filter_import_from_aliases<F>(
        &self,
        aliases: &[ast::Alias],
        keep_predicate: &F,
    ) -> Vec<ast::Alias>
    where
        F: Fn(&str) -> bool,
    {
        aliases
            .iter()
            .filter(|alias| {
                let local_name = alias
                    .asname
                    .as_ref()
                    .map(|n| n.as_str())
                    .unwrap_or_else(|| alias.name.as_str());
                keep_predicate(local_name)
            })
            .cloned()
            .collect()
    }

    /// Determine if an import-from statement's module should be kept
    fn should_keep_import_from_module<F>(
        &self,
        import_from_stmt: &ast::StmtImportFrom,
        keep_predicate: &F,
    ) -> bool
    where
        F: Fn(&str) -> bool,
    {
        if let Some(module) = &import_from_stmt.module {
            keep_predicate(module.as_str())
        } else {
            // Relative import - keep for now (could be refined later)
            true
        }
    }

    /// Collect first-party imports from AST instead of re-parsing source
    fn collect_first_party_imports_from_ast(
        &self,
        module: &ast::ModModule,
    ) -> Result<HashSet<String>> {
        let mut first_party_imports = HashSet::new();

        for stmt in &module.body {
            self.collect_first_party_from_statement(stmt, &mut first_party_imports);
        }

        log::debug!("Collected first-party imports: {:?}", first_party_imports);
        Ok(first_party_imports)
    }

    /// Extract first-party imports from an AST statement
    fn collect_first_party_from_statement(&self, stmt: &Stmt, imports: &mut HashSet<String>) {
        match stmt {
            Stmt::Import(import_stmt) => {
                self.collect_first_party_from_import(import_stmt, imports);
            }
            Stmt::ImportFrom(import_from_stmt) => {
                self.collect_first_party_from_import_from(import_from_stmt, imports);
            }
            _ => {}
        }
    }

    /// Helper to collect first-party imports from "from ... import" statements
    fn collect_first_party_from_import_from(
        &self,
        import_from_stmt: &rustpython_parser::ast::StmtImportFrom,
        imports: &mut HashSet<String>,
    ) {
        // Handle relative imports (e.g., `from . import x`) as first-party
        if import_from_stmt.module.is_none() {
            if import_from_stmt.level.is_some() {
                // Insert empty string marker for relative import
                imports.insert(String::new());
            }
            return;
        }
        let module = import_from_stmt.module.as_ref().unwrap();

        let module_name = module.as_str();
        if matches!(
            self.resolver.classify_import(module_name),
            ImportType::FirstParty
        ) {
            imports.insert(module_name.to_string());
        }
    }

    /// Helper to collect first-party imports from regular import statements
    fn collect_first_party_from_import(
        &self,
        import_stmt: &rustpython_parser::ast::StmtImport,
        imports: &mut HashSet<String>,
    ) {
        for alias in &import_stmt.names {
            let import_name = alias.name.as_str();
            if matches!(
                self.resolver.classify_import(import_name),
                ImportType::FirstParty
            ) {
                imports.insert(import_name.to_string());
            }
        }
    }

    /// Check if a module name is valid (alphanumeric, underscores, dots only)
    fn is_valid_module_name(&self, module_name: &str) -> bool {
        !module_name.is_empty()
            && !module_name.contains(' ')
            && module_name
                .chars()
                .all(|c| c.is_alphanumeric() || c == '_' || c == '.')
    }

    /// Generate requirements.txt content from third-party imports
    pub fn generate_requirements(&mut self, modules: &[&ModuleNode]) -> Result<String> {
        let mut third_party_imports = HashSet::new();

        for module in modules {
            self.collect_third_party_imports_from_module(module, &mut third_party_imports);
        }

        let mut requirements: Vec<String> = third_party_imports.into_iter().collect();
        requirements.sort();

        Ok(requirements.join("\n"))
    }

    /// Collect third-party imports from a single module
    fn collect_third_party_imports_from_module(
        &mut self,
        module: &ModuleNode,
        third_party_imports: &mut HashSet<String>,
    ) {
        for import in &module.imports {
            if let ImportType::ThirdParty = self.resolver.classify_import(import) {
                // Extract top-level package name
                let package_name = import.split('.').next().unwrap_or(import);
                third_party_imports.insert(package_name.to_string());
            }
        }
    }

    /// Create a comment as a StmtExpr with string constant
    fn create_comment_stmt(&self, comment: &str) -> Stmt {
        let comment_expr = ast::ExprConstant {
            value: ast::Constant::Str(comment.to_string()),
            kind: None,
            range: Default::default(),
        };

        Stmt::Expr(ast::StmtExpr {
            value: Box::new(ast::Expr::Constant(comment_expr)),
            range: Default::default(),
        })
    }

    /// Create a module header comment
    fn create_module_header_comment(&self, module_name: &str) -> Stmt {
        self.create_comment_stmt(&format!("# ─ Module: {} ─", module_name))
    }

    /// Create entry module header comment
    fn create_entry_module_header_comment(&self, module_name: &str) -> Stmt {
        self.create_comment_stmt(&format!("# ─ Entry Module: {} ─", module_name))
    }

    /// Create preserved imports header comment
    fn create_preserved_imports_header(&self) -> Stmt {
        self.create_comment_stmt("# Preserved imports")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::Config;
    fn create_test_emitter() -> CodeEmitter {
        let config = Config::default();
        let resolver = ModuleResolver::new(config).unwrap();
        CodeEmitter::new(resolver, false, false)
    }

    #[test]
    fn test_filter_import_statements_basic_functionality() {
        let emitter = create_test_emitter();

        // This is just a simple test to verify the AST-based approach works
        let source = "import os\nimport sys\n";
        if let Ok(rustpython_parser::ast::Mod::Module(module)) =
            parse(source, Mode::Module, "<test>")
        {
            let keep_predicate = |_module: &str| true; // Keep all imports for this test
            let filtered = emitter
                .filter_import_statements(&module.body, keep_predicate)
                .unwrap();

            // Should keep both import statements
            assert_eq!(filtered.len(), 2);
        }
    }
}
