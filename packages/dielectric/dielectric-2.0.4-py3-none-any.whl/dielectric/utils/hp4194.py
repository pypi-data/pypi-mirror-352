
# https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyfit.html
from numpy.polynomial import polynomial as P
from pathlib import Path
import logging
import matplotlib.pyplot as plt
import matplotlib
from dielectric.constants import *

matplotlib.use("QtAgg")
# matplotlib.use('TkAgg')
logging.basicConfig(level=logging.INFO)


class HP4194(object):
    """Class for handling measurement files generated by HP4294A Impedance Analyzer.

    Attributes:
        file_name (str): Path to the measurement file.
        header_present (bool): presence of header in the measurement file.
        data_row (int): line number in file where "DATA" can be found.
        start_row (int): line number in file where x, y data begins.
        num_frequencies (int): number of frequency points.
        num_volumes (int): number of volumes measured.
        start_freq (float): starting frequency from file header.
        stop_freq (float): stopping frequency from file header.
        freq (array): array of frequency points.
        volume_ml (array): array of volumes.
        res (array): array of resistance values
        dres (array): array of resistance standard deviations.
        cap (array): array of capacitance values.
        dcap (array): array of capacitance standard deviations.
    """
    def __init__(self, file_name: str):
        self.file_name = file_name
        self.header_present = False
        self.data_row = -1
        self.start_row = 0
        self.num_frequencies = 0
        self.num_volumes = 0
        self.start_freq = 0.0
        self.stop_freq = 0.0

        self.freq = None
        self.volume_ml = None
        self.filling_heights = None
        self.res = None
        self.dres = None
        self.funcres = None
        self.cap = None
        self.dcap = None
        self.funccap = None
        logging.info(f" HP4294 object created from {Path(self.file_name).name}")
        self.read_file()

    def read_file(self):
        """Read measurement from file and store it in class attributes.
        """
        with open(self.file_name, 'r', encoding='utf-8') as file:
            lines = file.readlines()

        # find start and stop frequencies, if present
        self.header_present = False

        for i in range(len(lines)):
            line = lines[i]
            if 'START' in line:
                elements = line.split()
                try:
                    self.start_freq = float(elements[3])
                    self.header_present = True
                    logging.info(f"   Header present ({self.header_present}) \n")
                    logging.info(f"   Start frequency: {self.start_freq} Hz")
                except ValueError:
                    pass
            if 'STOP' in line:
                elements = line.split()
                try:
                    self.stop_freq = float(elements[3])
                    logging.info(f"   Stop frequency: {self.stop_freq} Hz")
                except ValueError:
                    pass
            if 'DATA' in line:
                self.data_row = i
                logging.info(f"   DATA statement in row {self.data_row}")

        if not self.header_present:
            logging.info(f"   Header not present ({self.header_present}) \n")

        if self.header_present:
            for i in range(self.data_row+1, len(lines)):
                line = lines[i]
                elements = line.split()
                if len(elements) == 1:
                    if i == self.data_row + 5:
                        try:
                            self.num_frequencies = int(elements[0])
                        except ValueError:
                            pass
                    elif i == self.data_row + 6:
                        try:
                            self.num_volumes = int(elements[0])
                        except ValueError:
                            pass
                    try:
                        first = float(elements[0])
                        if np.abs(first - self.start_freq) < 0.1:
                            self.start_row = i
                            break
                    except ValueError:
                        pass

            logging.info(f"   Start row: {self.start_row}")
            logging.info(f"   {self.num_frequencies} frequencies x {self.num_volumes} volumes")

        freq_list = []
        num_volume_entries = 0
        for i in range(self.start_row, len(lines)):
            elements = lines[i].split()
            if len(elements) == 1:
                try:
                    freq_list.append(float(elements[0]))
                except ValueError:
                    pass
            if len(elements) == 7:
                num_volume_entries += 1

        self.freq = np.asarray(freq_list)
        if not self.header_present:
            self.num_frequencies = len(freq_list)
            self.num_volumes = int(num_volume_entries / self.num_frequencies)

        shape = (self.num_frequencies, self.num_volumes)
        self.volume_ml = np.zeros(shape)
        self.cap = np.zeros(shape)
        self.dcap = np.zeros(shape)
        self.res = np.zeros(shape)
        self.dres = np.zeros(shape)

        for i in range(self.start_row, len(lines)):
            elements = lines[i].split()
            if len(elements) == 1:
                try:
                    freq_list.append(float(elements[0]))
                except ValueError:
                    pass
                for j in range(self.num_volumes):
                    elements = lines[i + j + 1].split()
                    if len(elements) == 7:
                        try:
                            col = int(elements[0]) - 1
                            self.volume_ml[col, j] = float(elements[2]) / 10
                            self.cap[col, j] = float(elements[3])
                            self.dcap[col, j] = float(elements[4])
                            self.res[col, j] = float(elements[5])
                            self.dres[col, j] = float(elements[6])
                        except ValueError:
                            pass

    def calc_heights(self, surf_o):
        """calculate filling heights

        Args:
            surf_o (float): surface of ring-shaped bottom area of the cylindrical cell.

        Note: the parameter `surf_o` is in units of m^2
        """
        if self.volume_ml is not None:
            surf_o *= 1.0e4  # m^2 --> cm^2
            self.filling_heights = self.volume_ml[0, :] / surf_o  # in cm
            self.filling_heights *= 1.0e-2  # cm --> m

    def calc_regression(self, show):
        """perform linear regression analysis  of res, cap vs filling height.

           Model is a first-order polynomial.
        """
        self.funcres = np.zeros(self.num_frequencies)
        self.funccap = np.zeros(self.num_frequencies)
        for k in range(self.num_frequencies):
            fit_res = P.polyfit(self.filling_heights, 1.0 / self.res[k, :], 1)
            self.funcres[k] = fit_res[1] / (2 * np.pi)

            fit_cap = P.polyfit(self.filling_heights, self.cap[k, :], 1)
            self.funccap[k] = fit_cap[1] / (2 * np.pi * EPS_ZERO) + 1

            if show:
                self.plot_regression(k, fit_res, fit_cap)

    def plot_regression(self, row, param_res, param_cap):
        """

        Args:
            row:
            param_res:
            param_cap:

        """
        fig, ax = plt.subplots(2, 1, figsize=(5, 8))
        ax[0].plot(self.filling_heights, 1.0 / self.res[row, :], 'or', label='conductance')
        ax[0].plot(self.filling_heights, param_res[0] + param_res[1] * self.filling_heights, '--g')
        ax[0].set_title(f"Conductance vs. liquid level ")
        ax[0].legend()
        # ax[0].set_xlabel("filling height (m)")
        ax[0].set_ylabel("conductance")
        # ax[0].set_ylim(-100, 100)
        # ax[0].set_ylim(70, 100)

        ax[1].plot(self.filling_heights, self.cap[row, :], 'or', label='capacitance')
        ax[1].plot(self.filling_heights, param_cap[0] + param_cap[1] * self.filling_heights, '--g')
        ax[1].set_title(f"Capacitance vs. liquid level ")
        ax[1].legend()
        ax[1].set_xlabel("filling height (m)")
        ax[1].set_ylabel("capacitance")
        # ax[1].set_ylim(-100, 100)
        # ax[1].set_ylim(70, 100)
        fig.suptitle(f"Regression analysis @ {self.freq[row]} Hz", fontweight='bold')
        plt.tight_layout()
        plt.show()

    def plot_permittivity(self, K1=None, save=False):
        """plot complex permittivity with theoretical value as optional argument.

        Args:
            K1 (float): optional theoretical value of conductivity.
        """
        fig, ax = plt.subplots(2, 1, figsize=(5, 8))
        for k in range(self.num_volumes):
            ax[0].semilogx(self.freq, (1.0 / self.res[:, k]) * (1.0 / (2 * np.pi * self.filling_heights[k])), '-k', label=f'{k}')
        ax[0].semilogx(self.freq, self.funcres, 'ok')
        if K1 is not None:
            ax[0].axhline(y=K1)

        ax[0].legend()
        # ax[0].set_xlabel("frequency (Hz")
        ax[0].set_ylabel("conductivity $\sigma$ (S/m)")
        # ax[0].set_ylim(-100, 100)
        # ax[0].set_ylim(70, 100)

        for k in range(self.num_volumes):
            ax[1].semilogx(self.freq, (self.cap[:, k]) * (1.0 / (2 * np.pi * self.filling_heights[k] * EPS_ZERO)), '-k', label=f'{k}')
        ax[1].semilogx(self.freq, self.funccap, 'ok')
        ax[1].axhline(y=EPS_WATER)

        ax[1].legend()
        ax[1].set_xlabel("frequency (Hz)")
        ax[1].set_ylabel("permittivity $\epsilon_r$")
        ax[1].set_ylim(60, 800)
        fig.suptitle(f"Complex permittivity for {Path(self.file_name).name}", fontweight='bold')
        plt.tight_layout()
        if save:
            plt.savefig(Path(self.file_name).with_suffix(".png"))
        plt.show()


if __name__ == '__main__':
    file_path = Path('C:/Users/PaulvanKan/surfdrive/PvKCC/DielectricSpectroscopy/NaCl - meas2012')
    meas1 = HP4194(str(file_path / "NaCl5mM.txt"))
    meas2 = HP4194(str(file_path / "original files" / "NACL5MM.001"))
