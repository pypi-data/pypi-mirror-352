#!/usr/bin/env -S python -u
import sys
from os.path import join, dirname, realpath
from datetime import datetime, timedelta
from re import fullmatch
from typing import List, Tuple
from graphai_client.client_api.utils import login
from graphai_client.utils import (
    status_msg, strfdelta, convert_subtitle_into_segments,
    combine_language_segments, add_initial_disclaimer, default_disclaimer, default_missing_transcript,
    insert_data_into_table, execute_query, update_data_into_table, get_piper_connection, GoogleResource
)
from graphai_client.client import process_audio, translate_subtitles, get_video_token_and_codec_types

language_to_short = {
    'french': 'fr',
    'english': 'en',
    'italian': 'it',
    'german': 'de'
}
short_to_language = {v: k for k, v in language_to_short.items()}


def process_audio_on_rcp(
        videos_platform_and_id: List[Tuple[str, str]], piper_mysql_json_file=None, graph_api_json=None,
        destination_languages=('fr', 'en'), force=False, force_download=False, debug=False,
        sections=('GRAPHAI', 'TRANSCRIBE')
):
    login_info = login(graph_api_json)
    with get_piper_connection(piper_mysql_json_file) as piper_connection:
        for platform, video_id in videos_platform_and_id:
            video_token, codec_types = get_video_token_and_codec_types(
                platform, video_id, piper_connection, login_info,
                force=force, force_download=force_download, debug=debug, sections=sections
            )
            if video_token is None or codec_types is None:
                continue
            subtitles = None
            audio_language = 'NA'
            audio_fingerprint = None
            if platform == 'mediaspace':
                subtitles = get_subtitles_from_kaltura(
                    video_id, login_info, piper_connection=piper_connection, force=force,
                    destination_languages=destination_languages, debug=debug
                )
            elif platform == 'youtube':
                # no caption download using the API key, need Oath2
                # subtitles = get_subtitles_from_youtube(video_id, youtube_resource)
                pass
            if subtitles:
                status_msg(
                    f'Subtitles for the {platform} video {video_id} are present on the platform, '
                    'skipping transcription and only detect language',
                    color='grey', sections=list(sections) + ['PROCESSING']
                )
                if 'audio' in codec_types:
                    audio_language, audio_fingerprint, _ = process_audio(
                        video_token, login_info, only_detect_language=True, force=force, debug=debug, sections=sections
                    )
            elif 'audio' in codec_types:
                audio_language, audio_fingerprint, subtitles = process_audio(
                    video_token, login_info, destination_languages=destination_languages, force=force, debug=debug,
                    sections=sections
                )
            audio_transcription_time = str(datetime.now())
            register_subtitles(piper_connection, platform, video_id, subtitles, audio_language)
            update_data_into_table(
                piper_connection, 'gen_video', "Videos",
                columns=("audioTranscriptionTime", "audioDetectedLanguage", "audioFingerprint"),
                pk_columns=("platform", "videoId"),
                data=[(audio_transcription_time, audio_language, audio_fingerprint, platform, video_id)]
            )
            piper_connection.commit()


def get_subtitles_from_kaltura(
        kaltura_video_id, login_info, piper_connection=None, piper_mysql_json_file=None, force=False,
        destination_languages=('en', 'fr'), ignore_autogenerated=True, debug=False
):
    close_connection = False
    if piper_connection is None:
        piper_connection = get_piper_connection(piper_mysql_json_file)
        close_connection = True
    subtitle_query = f'''
        SELECT captionData, fileExt, language 
        FROM ca_kaltura.Captions WHERE kalturaVideoId='{kaltura_video_id}'
    '''
    if ignore_autogenerated:
        partner_data_info = execute_query(
            piper_connection,
            f"SELECT partnerData FROM ca_kaltura.Videos WHERE kalturaVideoId='{kaltura_video_id}';"
        )
        languages_with_auto_captions = []
        if len(partner_data_info) > 0:
            if partner_data_info[0][0]:
                partner_data = partner_data_info[0][0].split(',')
                for data in partner_data:
                    matched = fullmatch(r'sub_([a-z]+)_auto', data)
                    if matched:
                        language_short = matched.group(1).lower()
                        languages_with_auto_captions.append('"' + short_to_language[language_short] + '"')
        if languages_with_auto_captions:
            subtitle_query += f' AND language NOT IN ({", ".join(languages_with_auto_captions)})'
    subtitles_in_kaltura = {}
    caption_info = execute_query(piper_connection, subtitle_query)
    if len(caption_info) > 0:
        for caption_data, file_ext, language in caption_info:
            if caption_data is None:
                continue
            if language.lower() in language_to_short:
                lang = language_to_short[language.lower()]
            else:
                status_msg(
                    f'Unknown caption language: {language}',
                    sections=['GRAPHAI', 'GET SUBTITLES', 'WARNING'], color='yellow'
                )
                continue
            try:
                segments = convert_subtitle_into_segments(caption_data, file_ext=file_ext)
            except Exception as e:
                status_msg(
                    f'Error parsing the {lang} subtitle for {kaltura_video_id}: {e}',
                    sections=['GRAPHAI', 'GET SUBTITLES', 'WARNING'], color='yellow'
                )
                continue
            if segments and len(segments) == 1 and \
                    segments[0]['text'] == default_missing_transcript.get(lang, None):
                continue
            subtitles_in_kaltura[lang] = segments
    if ignore_autogenerated:
        languages_to_ignore = []
        for lang, subtitles in subtitles_in_kaltura.items():
            if subtitles[0]:
                if subtitles[0]['text'].split('\n')[0] == default_disclaimer[lang]:
                    msg = f'Found automatic captions not tagged by "sub_{lang}_auto" in partnerData ' + \
                          f'for video "{kaltura_video_id}"'
                    status_msg(msg, sections=['GRAPHAI', 'GET SUBTITLES', 'WARNING'], color='yellow')
                    languages_to_ignore.append(lang)
        for lang in languages_to_ignore:
            del subtitles_in_kaltura[lang]
    if not subtitles_in_kaltura:
        return None
    subtitles = combine_language_segments(**subtitles_in_kaltura, precision_s=2)
    status_msg(
        f'Found subtitles ({len(subtitles)} segments) in kaltura in {", ".join(subtitles_in_kaltura.keys())}',
        color='grey', sections=['GRAPHAI', 'GET SUBTITLES', 'SUCCESS']
    )
    if destination_languages:
        missing_destination_language = []
        for lang in destination_languages:
            if lang not in subtitles_in_kaltura:
                missing_destination_language.append(lang)
        if missing_destination_language:
            if 'en' in subtitles_in_kaltura:
                translate_from = 'en'
            elif 'fr' in subtitles_in_kaltura:
                translate_from = 'fr'
            elif 'de' in subtitles_in_kaltura:
                translate_from = 'de'
            elif 'it' in subtitles_in_kaltura:
                translate_from = 'it'
            else:
                translate_from = list(subtitles_in_kaltura.keys())[0]
            status_msg(
                f'translate transcription for {len(subtitles)} segments in {translate_from}',
                color='grey', sections=['GRAPHAI', 'TRANSLATE', 'PROCESSING']
            )
            subtitles = translate_subtitles(
                subtitles, login_info, force=force, source_language=translate_from,
                destination_languages=missing_destination_language, debug=debug
            )
            subtitles = add_initial_disclaimer(subtitles, restrict_lang=missing_destination_language)
    if close_connection:
        piper_connection.close()
    return subtitles


def get_subtitles_from_youtube(video_id: str, youtube_resource: GoogleResource):
    captions = youtube_resource.captions()
    captions_request = captions.list(part='snippet,id', videoId=video_id)
    for captions_item in captions_request.execute()['items']:
        captions_snippet = captions_item['snippet']
        if captions_snippet['trackKind'].lower() == 'asr':
            continue
        caption_dl_request = captions.download(id=captions_item['id'])
        caption_dl_response = caption_dl_request.execute()
        print(caption_dl_response)
    subtitles = None
    return subtitles


def register_subtitles(
        db, platform, video_id, subtitles, audio_detected_language,
        sections=('VIDEO', 'PROCESSING', 'REGISTER SUBTITLES')
):
    if subtitles is None:
        return
    data_subtitles = []
    num_segment_orig = 0
    num_segment_french = 0
    num_segment_english = 0
    for idx, segment in enumerate(subtitles):
        segment_orig = segment.get(audio_detected_language, None)
        segment_french = segment.get('fr', None)
        segment_english = segment.get('en', None)
        data_subtitles.append(
            [
                platform, video_id, idx, int(segment['start'] * 1000), int(segment['end'] * 1000),
                strfdelta(timedelta(seconds=segment['start']), '{H:02}:{M:02}:{S:02}.{m:03}'),
                strfdelta(timedelta(seconds=segment['end']), '{H:02}:{M:02}:{S:02}.{m:03}'),
                segment_french, segment_english, segment_orig
            ]
        )
        if segment_orig:
            num_segment_orig += 1
        if segment_french:
            num_segment_french += 1
        if segment_english:
            num_segment_english += 1
    execute_query(
        db,
        f'DELETE FROM `gen_video`.`Subtitles` WHERE platform="{platform}" AND videoId="{video_id}"'
    )
    insert_data_into_table(
        db, 'gen_video', 'Subtitles',
        [
            'platform', 'videoId', 'segmentId', 'startMilliseconds', 'endMilliseconds',
            'startTime', 'endTime', 'textFr', 'textEn', 'textOriginal'
        ],
        data_subtitles
    )
    msg = f'registered {num_segment_orig} subtitles in {audio_detected_language}'
    translations = []
    if num_segment_french > 0 and audio_detected_language != 'fr':
        translations.append(
            f'French{" (" + str(num_segment_french) + ")" if num_segment_french != num_segment_orig else ""}'
        )
    if num_segment_english > 0 and audio_detected_language != 'en':
        translations.append(
            f'English{" (" + str(num_segment_english) + ")" if num_segment_english != num_segment_orig else ""}'
        )
    if translations:
        msg += f' and the translation in {" and ".join(translations)}'
    msg += f' for video {video_id} on {platform}'
    status_msg(msg, color='green', sections=list(sections) + ['SUCCESS'])


if __name__ == '__main__':
    executable_name = sys.argv.pop(0)
    force_str = sys.argv.pop(0)
    force = force_str.lower() == 'true'
    if len(sys.argv) % 2 != 0:
        raise ValueError('You must give a platform and an id for each video you want to process')
    videos_platform_and_id = []
    video_platform = None
    for arg in sys.argv:
        if video_platform is None:
            video_platform = arg
        else:
            videos_platform_and_id.append((video_platform, arg))
            video_platform = None
    print(f'Process audio for {len(videos_platform_and_id)} videos.')

    config_dir = realpath(join(dirname(__file__), '..',  'config'))
    piper_mysql_json_file = join(config_dir, "piper_db.json")
    graphai_json_file = join(config_dir, "graphai-api.json")
    process_audio_on_rcp(
        videos_platform_and_id, force=force,
        piper_mysql_json_file=piper_mysql_json_file, graph_api_json=graphai_json_file
    )

    print('Done')