"""
Visualization functions for cohort analysis using Plotly.

This module provides various visualization functions to help analyze and 
interpret cohort data generated by the generate_cohort_data function.
"""

from typing import Optional, Dict, Any, Literal, Union
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np


def plot_cohort_heatmap(
    cohort_data: pd.DataFrame,
    title: Optional[str] = None,
    color_scale: str = "Blues",
    show_values: bool = True,
    value_format: str = ".0f",
    width: int = 800,
    height: int = 600,
    show_colorscale: bool = True,
    reverse_y_axis: bool = False
) -> go.Figure:
    """
    Create a heatmap visualization of cohort data.
    
    Parameters:
    -----------
    cohort_data : pd.DataFrame
        Cohort data in pivot format (cohorts as rows, periods as columns)
    title : Optional[str], default None
        Title for the plot. If None, a default title will be generated
    color_scale : str, default "Blues"
        Color scale for the heatmap. Common options: "Blues", "Viridis", "RdYlBu", "Plasma"
    show_values : bool, default True
        Whether to show values on the heatmap cells
    value_format : str, default ".0f"
        Format string for displaying values (e.g., ".0f" for integers, ".1f" for 1 decimal)
    width : int, default 800
        Width of the plot in pixels
    height : int, default 600
        Height of the plot in pixels
    show_colorscale : bool, default True
        Whether to show the color scale bar on the right side of the plot
    reverse_y_axis : bool, default False
        Whether to reverse the y-axis order (newer cohorts at top)
        
    Returns:
    --------
    plotly.graph_objects.Figure
        Plotly figure object for the heatmap
        
    Examples:
    ---------
    >>> cohort_data = generate_cohort_data(df, date_column='date', user_column='user')
    >>> fig = plot_cohort_heatmap(cohort_data, title="User Retention Cohorts")
    >>> fig.show()
    """
    # Validate input
    if cohort_data.empty:
        raise ValueError("Input DataFrame is empty")
    
    # Validate color scale (let plotly handle the actual validation)
    valid_color_scales = [
        'aggrnyl', 'agsunset', 'algae', 'amp', 'armyrose', 'balance',
        'blackbody', 'bluered', 'blues', 'blugrn', 'bluyl', 'brbg',
        'brwnyl', 'bugn', 'bupu', 'burg', 'burgyl', 'cividis', 'curl',
        'darkmint', 'deep', 'delta', 'dense', 'earth', 'edge', 'electric',
        'emrld', 'fall', 'geyser', 'gnbu', 'gray', 'greens', 'greys',
        'haline', 'hot', 'hsv', 'ice', 'icefire', 'inferno', 'jet',
        'magenta', 'magma', 'matter', 'mint', 'mrybm', 'mygbm', 'oranges',
        'orrd', 'oryel', 'oxy', 'peach', 'phase', 'picnic', 'pinkyl',
        'piyg', 'plasma', 'plotly3', 'portland', 'prgn', 'pubu', 'pubugn',
        'puor', 'purd', 'purp', 'purples', 'purpor', 'rainbow', 'rdbu',
        'rdgy', 'rdpu', 'rdylbu', 'rdylgn', 'redor', 'reds', 'solar',
        'spectral', 'speed', 'sunset', 'sunsetdark', 'teal', 'tealgrn',
        'tealrose', 'tempo', 'temps', 'thermal', 'tropic', 'turbid',
        'turbo', 'twilight', 'viridis', 'ylgn', 'ylgnbu', 'ylorbr',
        'ylorrd'
    ]
    # Also allow reversed versions
    valid_color_scales_with_reverse = valid_color_scales + [cs + '_r' for cs in valid_color_scales]
    
    if color_scale.lower() not in [cs.lower() for cs in valid_color_scales_with_reverse]:
        raise ValueError(f"Invalid color scale '{color_scale}'. Must be one of the valid Plotly color scales.")
    
    if title is None:
        title = "Cohort Analysis Heatmap"
    
    # Convert index to string for better display
    cohort_data_display = cohort_data.copy()
    cohort_data_display.index = cohort_data_display.index.astype(str)
    
    # Create heatmap using go.Heatmap for better control
    fig = go.Figure(data=go.Heatmap(
        z=cohort_data_display.values,
        x=[f"Period {i}" for i in cohort_data_display.columns],
        y=cohort_data_display.index,
        colorscale=color_scale,
        showscale=show_colorscale,
        hoverongaps=False,
        text=cohort_data_display.values if show_values else None,
        texttemplate=f"%{{text:{value_format}}}" if show_values else None,
        textfont={"size": 12, "color": "white"}
    ))
    
    # Update layout
    fig.update_layout(
        title=title,
        xaxis_title="Analysis Period",
        yaxis_title="Cohort (Acquisition Period)",
        font=dict(size=12),
        width=width,
        height=height,
        yaxis=dict(autorange='reversed' if reverse_y_axis else True)
    )
    
    return fig


def plot_retention_curves(
    retention_data: pd.DataFrame,
    title: Optional[str] = None,
    show_legend: bool = True,
    width: int = 900,
    height: int = 600,
    max_cohorts: Optional[int] = 10
) -> go.Figure:
    """
    Create line plots showing retention curves for different cohorts.
    
    Parameters:
    -----------
    retention_data : pd.DataFrame
        Retention rate data in pivot format (should be retention percentages)
    title : Optional[str], default None
        Title for the plot
    show_legend : bool, default True
        Whether to show the legend
    width : int, default 900
        Width of the plot in pixels
    height : int, default 600
        Height of the plot in pixels
    max_cohorts : Optional[int], default 10
        Maximum number of cohorts to display (None for all)
        
    Returns:
    --------
    plotly.graph_objects.Figure
        Plotly figure object for the retention curves
        
    Examples:
    ---------
    >>> retention_data = generate_cohort_data(df, date_column='date', user_column='user', 
    ...                                       calculate_retention_rate=True)
    >>> fig = plot_retention_curves(retention_data)
    >>> fig.show()
    """
    if title is None:
        title = "Cohort Retention Curves"
    
    # Limit number of cohorts if specified
    data_to_plot = retention_data.copy()
    if max_cohorts is not None and len(data_to_plot) > max_cohorts:
        data_to_plot = data_to_plot.head(max_cohorts)
    
    fig = go.Figure()
    
    # Add a line for each cohort
    for cohort in data_to_plot.index:
        cohort_str = str(cohort)
        y_values = data_to_plot.loc[cohort].values
        x_values = list(range(len(y_values)))
        
        fig.add_trace(go.Scatter(
            x=x_values,
            y=y_values,
            mode='lines+markers',
            name=f'Cohort {cohort_str}',
            line=dict(width=2),
            marker=dict(size=6)
        ))
    
    # Update layout
    fig.update_layout(
        title=title,
        xaxis_title="Period",
        yaxis_title="Retention Rate (%)",
        showlegend=show_legend,
        width=width,
        height=height,
        hovermode='x unified'
    )
    
    # Add grid
    fig.update_xaxes(showgrid=True, gridwidth=1, gridcolor='lightgray')
    fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='lightgray')
    
    return fig


def plot_cohort_comparison(
    cohort_data_dict: Dict[str, pd.DataFrame],
    metric_names: Optional[Dict[str, str]] = None,
    title: Optional[str] = None,
    width: int = 1000,
    height: int = 600,
    show_colorscale: bool = True,
    reverse_y_axis: bool = False
) -> go.Figure:
    """
    Create subplots comparing different cohort metrics side by side.
    
    Parameters:
    -----------
    cohort_data_dict : Dict[str, pd.DataFrame]
        Dictionary mapping metric names to cohort data DataFrames
    metric_names : Optional[Dict[str, str]], default None
        Dictionary mapping keys to display names for metrics
    title : Optional[str], default None
        Main title for the plot
    width : int, default 1000
        Width of the plot in pixels
    height : int, default 600
        Height of the plot in pixels
    show_colorscale : bool, default True
        Whether to show the color scale bars for the heatmaps
    reverse_y_axis : bool, default False
        Whether to reverse the y-axis order (newer cohorts at top)
        
    Returns:
    --------
    plotly.graph_objects.Figure
        Plotly figure object with subplots
        
    Examples:
    ---------
    >>> user_data = generate_cohort_data(df, date_column='date', user_column='user')
    >>> revenue_data = generate_cohort_data(df, date_column='date', user_column='user', 
    ...                                     value_column='revenue', aggregation_function='sum')
    >>> fig = plot_cohort_comparison({'users': user_data, 'revenue': revenue_data})
    >>> fig.show()
    """
    if title is None:
        title = "Cohort Metrics Comparison"
    
    if metric_names is None:
        metric_names = {k: k.title() for k in cohort_data_dict.keys()}
    
    n_metrics = len(cohort_data_dict)
    cols = min(n_metrics, 2)
    rows = (n_metrics + cols - 1) // cols
    
    # Create subplots
    fig = make_subplots(
        rows=rows, cols=cols,
        subplot_titles=[metric_names.get(k, k) for k in cohort_data_dict.keys()],
        vertical_spacing=0.1,
        horizontal_spacing=0.1
    )
    
    for i, (metric_key, data) in enumerate(cohort_data_dict.items()):
        row = i // cols + 1
        col = i % cols + 1
        
        # Convert data for heatmap
        data_display = data.copy()
        data_display.index = data_display.index.astype(str)
        
        # Add heatmap
        heatmap = go.Heatmap(
            z=data_display.values,
            x=[f"P{j}" for j in data_display.columns],
            y=data_display.index,
            colorscale="Blues",
            showscale=show_colorscale and (i == 0),  # Only show colorscale for first subplot
            hoverongaps=False
        )
        
        fig.add_trace(heatmap, row=row, col=col)
    
    # Update layout
    fig.update_layout(
        title=title,
        width=width,
        height=height,
        font=dict(size=10)
    )
    
    # Update y-axis for all subplots if reverse_y_axis is True
    if reverse_y_axis:
        for i in range(1, rows * cols + 1):
            fig.update_yaxes(autorange='reversed', row=(i-1)//cols + 1, col=(i-1)%cols + 1)
    
    return fig


def plot_period_comparison(
    cohort_data: pd.DataFrame,
    periods_to_compare: Optional[list] = None,
    chart_type: Literal["bar", "line"] = "bar",
    title: Optional[str] = None,
    width: int = 800,
    height: int = 500
) -> go.Figure:
    """
    Compare specific periods across all cohorts.
    
    Parameters:
    -----------
    cohort_data : pd.DataFrame
        Cohort data in pivot format
    periods_to_compare : Optional[list], default None
        List of periods to compare. If None, uses [0, 1, 2, 3]
    chart_type : {"bar", "line"}, default "bar"
        Type of chart to create
    title : Optional[str], default None
        Title for the plot
    width : int, default 800
        Width of the plot in pixels
    height : int, default 500
        Height of the plot in pixels
        
    Returns:
    --------
    plotly.graph_objects.Figure
        Plotly figure object
        
    Examples:
    ---------
    >>> cohort_data = generate_cohort_data(df, date_column='date', user_column='user')
    >>> fig = plot_period_comparison(cohort_data, periods_to_compare=[0, 1, 3, 6])
    >>> fig.show()
    """
    if periods_to_compare is None:
        periods_to_compare = [0, 1, 2, 3]
    
    if title is None:
        title = f"Cohort Performance by Period"
    
    # Filter data for selected periods
    available_periods = [p for p in periods_to_compare if p in cohort_data.columns]
    if not available_periods:
        raise ValueError("None of the specified periods are available in the data")
    
    plot_data = cohort_data[available_periods].copy()
    plot_data.index = plot_data.index.astype(str)
    
    if chart_type == "bar":
        plot_data_reset = plot_data.reset_index()
        plot_data_melted = plot_data_reset.melt(
            id_vars=[plot_data_reset.columns[0]],  # Use the first column (index) as id_vars
            value_vars=available_periods,
            var_name='Period',
            value_name='Value'
        )
        fig = px.bar(
            plot_data_melted, 
            x=plot_data_melted.columns[0],  # Use the first column name
            y='Value',
            color='Period',
            title=title,
            labels={plot_data_melted.columns[0]: 'Cohort', 'Value': 'Value'},
            width=width,
            height=height
        )
    else:  # line chart
        fig = go.Figure()
        for period in available_periods:
            fig.add_trace(go.Scatter(
                x=plot_data.index,
                y=plot_data[period],
                mode='lines+markers',
                name=f'Period {period}',
                line=dict(width=2),
                marker=dict(size=6)
            ))
        
        fig.update_layout(
            title=title,
            xaxis_title="Cohort",
            yaxis_title="Value",
            width=width,
            height=height
        )
    
    return fig


def plot_cohort_summary_stats(
    cohort_data: pd.DataFrame,
    title: Optional[str] = None,
    width: int = 1200,
    height: int = 400
) -> go.Figure:
    """
    Create summary statistics visualization for cohort data.
    
    Parameters:
    -----------
    cohort_data : pd.DataFrame
        Cohort data in pivot format
    title : Optional[str], default None
        Title for the plot
    width : int, default 1200
        Width of the plot in pixels
    height : int, default 400
        Height of the plot in pixels
        
    Returns:
    --------
    plotly.graph_objects.Figure
        Plotly figure object with summary statistics
        
    Examples:
    ---------
    >>> cohort_data = generate_cohort_data(df, date_column='date', user_column='user')
    >>> fig = plot_cohort_summary_stats(cohort_data)
    >>> fig.show()
    """
    if title is None:
        title = "Cohort Summary Statistics by Period"
    
    # Calculate summary statistics
    stats_data = pd.DataFrame({
        'Mean': cohort_data.mean(),
        'Median': cohort_data.median(),
        'Min': cohort_data.min(),
        'Max': cohort_data.max(),
        'Std': cohort_data.std()
    })
    
    # Create subplots
    fig = make_subplots(
        rows=1, cols=2,
        subplot_titles=["Central Tendency", "Variability"],
        specs=[[{"secondary_y": False}, {"secondary_y": True}]]
    )
    
    # Plot 1: Mean and Median
    fig.add_trace(
        go.Scatter(x=stats_data.index, y=stats_data['Mean'], 
                  mode='lines+markers', name='Mean', line=dict(color='blue')),
        row=1, col=1
    )
    fig.add_trace(
        go.Scatter(x=stats_data.index, y=stats_data['Median'], 
                  mode='lines+markers', name='Median', line=dict(color='green')),
        row=1, col=1
    )
    
    # Plot 2: Min, Max, and Std
    fig.add_trace(
        go.Scatter(x=stats_data.index, y=stats_data['Min'], 
                  mode='lines+markers', name='Min', line=dict(color='red')),
        row=1, col=2
    )
    fig.add_trace(
        go.Scatter(x=stats_data.index, y=stats_data['Max'], 
                  mode='lines+markers', name='Max', line=dict(color='orange')),
        row=1, col=2
    )
    fig.add_trace(
        go.Scatter(x=stats_data.index, y=stats_data['Std'], 
                  mode='lines+markers', name='Std Dev', line=dict(color='purple')),
        row=1, col=2, secondary_y=True
    )
    
    # Update layout
    fig.update_layout(
        title=title,
        width=width,
        height=height,
        showlegend=True
    )
    
    # Update axes labels
    fig.update_xaxes(title_text="Period", row=1, col=1)
    fig.update_xaxes(title_text="Period", row=1, col=2)
    fig.update_yaxes(title_text="Value", row=1, col=1)
    fig.update_yaxes(title_text="Min/Max Value", row=1, col=2)
    fig.update_yaxes(title_text="Standard Deviation", row=1, col=2, secondary_y=True)
    
    return fig


def create_cohort_dashboard(
    cohort_data: pd.DataFrame,
    retention_data: Optional[pd.DataFrame] = None,
    revenue_data: Optional[pd.DataFrame] = None,
    title: str = "Cohort Analysis Dashboard",
    show_colorscale: bool = True,
    reverse_y_axis: bool = False
) -> go.Figure:
    """
    Create a comprehensive dashboard with multiple cohort visualizations.
    
    Parameters:
    -----------
    cohort_data : pd.DataFrame
        Main cohort data (usually user counts)
    retention_data : Optional[pd.DataFrame], default None
        Retention rate data (percentages)
    revenue_data : Optional[pd.DataFrame], default None
        Revenue cohort data
    title : str, default "Cohort Analysis Dashboard"
        Main title for the dashboard
    show_colorscale : bool, default True
        Whether to show color scales for the heatmaps
    reverse_y_axis : bool, default False
        Whether to reverse the y-axis order (newer cohorts at top)
        
    Returns:
    --------
    plotly.graph_objects.Figure
        Plotly figure object with multiple subplots
        
    Examples:
    ---------
    >>> user_data = generate_cohort_data(df, date_column='date', user_column='user')
    >>> retention_data = generate_cohort_data(df, date_column='date', user_column='user', 
    ...                                       calculate_retention_rate=True)
    >>> revenue_data = generate_cohort_data(df, date_column='date', user_column='user',
    ...                                     value_column='revenue', aggregation_function='sum')
    >>> fig = create_cohort_dashboard(user_data, retention_data, revenue_data)
    >>> fig.show()
    """
    # Determine subplot layout
    n_plots = 1 + (1 if retention_data is not None else 0) + (1 if revenue_data is not None else 0)
    
    if n_plots == 1:
        rows, cols = 1, 1
    elif n_plots == 2:
        rows, cols = 1, 2
    else:
        rows, cols = 2, 2
    
    # Create subplot titles
    subplot_titles = ["User Cohorts"]
    if retention_data is not None:
        subplot_titles.append("Retention Rates")
    if revenue_data is not None:
        subplot_titles.append("Revenue Cohorts")
    
    fig = make_subplots(
        rows=rows, cols=cols,
        subplot_titles=subplot_titles,
        vertical_spacing=0.15,
        horizontal_spacing=0.1
    )
    
    # Add user cohort heatmap
    cohort_display = cohort_data.copy()
    cohort_display.index = cohort_display.index.astype(str)
    
    fig.add_trace(
        go.Heatmap(
            z=cohort_display.values,
            x=[f"P{i}" for i in cohort_display.columns],
            y=cohort_display.index,
            colorscale="Blues",
            showscale=show_colorscale,
            name="Users"
        ),
        row=1, col=1
    )
    
    # Add retention data if provided
    if retention_data is not None:
        retention_display = retention_data.copy()
        retention_display.index = retention_display.index.astype(str)
        
        col_pos = 2 if n_plots >= 2 else 1
        fig.add_trace(
            go.Heatmap(
                z=retention_display.values,
                x=[f"P{i}" for i in retention_display.columns],
                y=retention_display.index,
                colorscale="RdYlBu_r",
                showscale=show_colorscale and n_plots >= 2,
                name="Retention %"
            ),
            row=1, col=col_pos
        )
    
    # Add revenue data if provided
    if revenue_data is not None:
        revenue_display = revenue_data.copy()
        revenue_display.index = revenue_display.index.astype(str)
        
        row_pos = 2 if n_plots > 2 else 1
        col_pos = 1 if n_plots > 2 else (2 if retention_data is None else 3)
        if col_pos > cols:
            col_pos = 1
            row_pos = 2
        
        fig.add_trace(
            go.Heatmap(
                z=revenue_display.values,
                x=[f"P{i}" for i in revenue_display.columns],
                y=revenue_display.index,
                colorscale="Viridis",
                showscale=show_colorscale and n_plots > 2,
                name="Revenue"
            ),
            row=row_pos, col=col_pos
        )
    
    # Update layout
    fig.update_layout(
        title=title,
        width=1200,
        height=800 if rows > 1 else 500,
        font=dict(size=10)
    )
    
    # Update y-axis for all subplots if reverse_y_axis is True
    if reverse_y_axis:
        for i in range(1, rows * cols + 1):
            fig.update_yaxes(autorange='reversed', row=(i-1)//cols + 1, col=(i-1)%cols + 1)
    
    return fig
